diff -uprN -b -B ./pristine/linux-4.9.5/include/linux/cred.h ./linux-4.9.5/include/linux/cred.h
--- ./pristine/linux-4.9.5/include/linux/cred.h	2017-01-20 10:56:02.000000000 +0100
+++ ./linux-4.9.5/include/linux/cred.h	2017-01-23 19:44:14.949586120 +0100
@@ -139,6 +139,9 @@ struct cred {
 #endif
 #ifdef CONFIG_SECURITY
 	void		*security;	/* subjective LSM security */
+#ifdef CONFIG_SECURITY_PROVENANCE
+	void 		*provenance; /* subjective LSM provenance */
+#endif
 #endif
 	struct user_struct *user;	/* real user ID subscription */
 	struct user_namespace *user_ns; /* user_ns the caps and keyrings are relative to. */
@@ -363,6 +366,7 @@ static inline void put_cred(const struct
 #define current_cap()		(current_cred_xxx(cap_effective))
 #define current_user()		(current_cred_xxx(user))
 #define current_security()	(current_cred_xxx(security))
+#define current_provenance()	(current_cred_xxx(provenance))

 extern struct user_namespace init_user_ns;
 #ifdef CONFIG_USER_NS
diff -uprN -b -B ./pristine/linux-4.9.5/include/linux/fs.h ./linux-4.9.5/include/linux/fs.h
--- ./pristine/linux-4.9.5/include/linux/fs.h	2017-01-20 10:56:02.000000000 +0100
+++ ./linux-4.9.5/include/linux/fs.h	2017-01-23 19:44:14.949586120 +0100
@@ -619,6 +619,7 @@ struct inode {

 #ifdef CONFIG_SECURITY
 	void			*i_security;
+	void 			*i_provenance;
 #endif

 	/* Stat data, not accessed from path walking */
@@ -1355,6 +1356,9 @@ struct super_block {
 	atomic_t		s_active;
 #ifdef CONFIG_SECURITY
 	void                    *s_security;
+#ifdef CONFIG_SECURITY_PROVENANCE
+	void										*s_provenance;
+#endif
 #endif
 	const struct xattr_handler **s_xattr;

diff -uprN -b -B ./pristine/linux-4.9.5/include/linux/ipc.h ./linux-4.9.5/include/linux/ipc.h
--- ./pristine/linux-4.9.5/include/linux/ipc.h	2017-01-20 10:56:02.000000000 +0100
+++ ./linux-4.9.5/include/linux/ipc.h	2017-01-23 19:44:14.950586128 +0100
@@ -21,6 +21,9 @@ struct kern_ipc_perm
 	umode_t		mode;
 	unsigned long	seq;
 	void		*security;
+#ifdef CONFIG_SECURITY_PROVENANCE
+	void		*provenance;
+#endif
 };

 #endif /* _LINUX_IPC_H */
diff -uprN -b -B ./pristine/linux-4.9.5/include/linux/lsm_hooks.h ./linux-4.9.5/include/linux/lsm_hooks.h
--- ./pristine/linux-4.9.5/include/linux/lsm_hooks.h	2017-01-20 10:56:02.000000000 +0100
+++ ./linux-4.9.5/include/linux/lsm_hooks.h	2017-01-23 19:44:14.948586113 +0100
@@ -1928,6 +1928,11 @@ extern void __init yama_add_hooks(void);
 #else
 static inline void __init yama_add_hooks(void) { }
 #endif
+#ifdef CONFIG_SECURITY_PROVENANCE
+extern void __init provenance_add_hooks(void);
+#else
+static inline void __init provenance_add_hooks(void) { }
+#endif
 #ifdef CONFIG_SECURITY_LOADPIN
 void __init loadpin_add_hooks(void);
 #else
diff -uprN -b -B ./pristine/linux-4.9.5/include/linux/msg.h ./linux-4.9.5/include/linux/msg.h
--- ./pristine/linux-4.9.5/include/linux/msg.h	2017-01-20 10:56:02.000000000 +0100
+++ ./linux-4.9.5/include/linux/msg.h	2017-01-23 19:44:14.950586128 +0100
@@ -11,6 +11,9 @@ struct msg_msg {
 	size_t m_ts;		/* message text size */
 	struct msg_msgseg *next;
 	void *security;
+#ifdef CONFIG_SECURITY_PROVENANCE
+	void *provenance;
+#endif
 	/* the actual message follows immediately */
 };

diff -uprN -b -B ./pristine/linux-4.9.5/include/net/sock.h ./linux-4.9.5/include/net/sock.h
--- ./pristine/linux-4.9.5/include/net/sock.h	2017-01-20 10:56:02.000000000 +0100
+++ ./linux-4.9.5/include/net/sock.h	2017-01-23 19:44:14.946586098 +0100
@@ -292,6 +292,7 @@ struct sock_common {
   *	@sk_peek_off: current peek_offset value
   *	@sk_send_head: front of stuff to transmit
   *	@sk_security: used by security modules
+	*	@sk_provenance: used by provenance modules
   *	@sk_mark: generic packet mark
   *	@sk_cgrp_data: cgroup data for this cgroup
   *	@sk_memcg: this socket's memory cgroup association
@@ -436,6 +437,9 @@ struct sock {
 	int			sk_write_pending;
 #ifdef CONFIG_SECURITY
 	void			*sk_security;
+#ifdef CONFIG_SECURITY_PROVENANCE
+	void			*sk_provenance;
+#endif
 #endif
 	struct sock_cgroup_data	sk_cgrp_data;
 	struct mem_cgroup	*sk_memcg;
diff -uprN -b -B ./pristine/linux-4.9.5/include/uapi/linux/camflow.h ./linux-4.9.5/include/uapi/linux/camflow.h
--- ./pristine/linux-4.9.5/include/uapi/linux/camflow.h	1970-01-01 01:00:00.000000000 +0100
+++ ./linux-4.9.5/include/uapi/linux/camflow.h	2017-01-23 19:44:14.947586105 +0100
@@ -0,0 +1,24 @@
+/*
+ *
+ * Author: Thomas Pasquier <thomas.pasquier@cl.cam.ac.uk>
+ *
+ * Copyright (C) 2016 University of Cambridge
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2, as
+ * published by the Free Software Foundation; either version 2 of the License, or
+ *	(at your option) any later version.
+ *
+ */
+#ifndef _UAPI_LINUX_CAMFLOW_H
+#define _UAPI_LINUX_CAMFLOW_H
+
+#define xstr(s) str(s)
+#define str(s) # s
+
+#define CAMFLOW_VERSION_MAJOR     0
+#define CAMFLOW_VERSION_MINOR     2
+#define CAMFLOW_VERSION_PATCH     0
+#define CAMFLOW_VERSION_STR       "v"xstr (CAMFLOW_VERSION_MAJOR)"."xstr (CAMFLOW_VERSION_MINOR)"."xstr (CAMFLOW_VERSION_PATCH)
+
+#endif
diff -uprN -b -B ./pristine/linux-4.9.5/include/uapi/linux/Kbuild ./linux-4.9.5/include/uapi/linux/Kbuild
--- ./pristine/linux-4.9.5/include/uapi/linux/Kbuild	2017-01-20 10:56:02.000000000 +0100
+++ ./linux-4.9.5/include/uapi/linux/Kbuild	2017-01-23 19:44:14.947586105 +0100
@@ -77,6 +77,7 @@ header-y += bpqether.h
 header-y += bsg.h
 header-y += bt-bmc.h
 header-y += btrfs.h
+header-y += camflow.h
 header-y += can.h
 header-y += capability.h
 header-y += capi.h
@@ -346,6 +347,7 @@ header-y += ppp_defs.h
 header-y += ppp-ioctl.h
 header-y += pps.h
 header-y += prctl.h
+header-y += provenance.h
 header-y += psci.h
 header-y += ptp_clock.h
 header-y += ptrace.h
diff -uprN -b -B ./pristine/linux-4.9.5/include/uapi/linux/provenance.h ./linux-4.9.5/include/uapi/linux/provenance.h
--- ./pristine/linux-4.9.5/include/uapi/linux/provenance.h	1970-01-01 01:00:00.000000000 +0100
+++ ./linux-4.9.5/include/uapi/linux/provenance.h	2017-01-23 19:44:14.948586113 +0100
@@ -0,0 +1,498 @@
+/*
+ *
+ * Author: Thomas Pasquier <thomas.pasquier@cl.cam.ac.uk>
+ *
+ * Copyright (C) 2015 University of Cambridge
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2, as
+ * published by the Free Software Foundation; either version 2 of the License, or
+ *	(at your option) any later version.
+ *
+ */
+#ifndef _UAPI_LINUX_PROVENANCE_H
+#define _UAPI_LINUX_PROVENANCE_H
+
+#ifndef __KERNEL__
+#include <linux/limits.h>
+#else
+#include <linux/socket.h>
+#include <uapi/linux/limits.h>
+#include <linux/mutex.h>
+#endif
+
+#define PROV_GOLDEN_RATIO_64 0x61C8864680B583EBUL
+static inline uint32_t prov_hash(uint64_t val)
+{
+	return (val * PROV_GOLDEN_RATIO_64) >> (64 - 8);
+}
+
+#define PROV_K_HASH 7
+#define PROV_M_BITS 256
+#define PROV_N_BYTES (PROV_M_BITS / 8)
+#define PROV_BYTE_INDEX(a) (a / 8)
+#define PROV_BIT_INDEX(a) (a % 8)
+
+static inline void prov_bloom_add(uint8_t bloom[PROV_N_BYTES], uint64_t val)
+{
+	uint8_t i;
+	uint32_t pos;
+
+	for (i = 0; i < PROV_K_HASH; i++) {
+		pos = prov_hash(val + i) % PROV_M_BITS;
+		bloom[PROV_BYTE_INDEX(pos)] |= 1 << PROV_BIT_INDEX(pos);
+	}
+}
+
+/* element in set belong to super */
+static inline bool prov_bloom_match(const uint8_t super[PROV_N_BYTES], const uint8_t set[PROV_N_BYTES])
+{
+	uint8_t i;
+
+	for (i = 0; i < PROV_N_BYTES; i++)
+		if ((super[i] & set[i]) != set[i])
+			return false;
+	return true;
+}
+
+static inline bool prov_bloom_in(const uint8_t bloom[PROV_N_BYTES], uint64_t val)
+{
+	uint8_t tmp[PROV_N_BYTES];
+
+	memset(tmp, 0, PROV_N_BYTES);
+	prov_bloom_add(tmp, val);
+	return prov_bloom_match(bloom, tmp);
+}
+
+/* merge src into dest (dest=dest U src) */
+static inline void prov_bloom_merge(uint8_t dest[PROV_N_BYTES], const uint8_t src[PROV_N_BYTES])
+{
+	uint8_t i;
+
+	for (i = 0; i < PROV_N_BYTES; i++)
+		dest[i] |= src[i];
+}
+
+
+static inline bool prov_bloom_empty(const uint8_t bloom[PROV_N_BYTES])
+{
+	uint8_t i;
+
+	for (i = 0; i < PROV_N_BYTES; i++)
+		if (bloom[i] != 0)
+			return false;
+	return true;
+}
+
+#define PROV_ENABLE_FILE                      "/sys/kernel/security/provenance/enable"
+#define PROV_ALL_FILE                         "/sys/kernel/security/provenance/all"
+#define PROV_NODE_FILE                        "/sys/kernel/security/provenance/node"
+#define PROV_RELATION_FILE                    "/sys/kernel/security/provenance/relation"
+#define PROV_SELF_FILE                        "/sys/kernel/security/provenance/self"
+#define PROV_MACHINE_ID_FILE                  "/sys/kernel/security/provenance/machine_id"
+#define PROV_NODE_FILTER_FILE                 "/sys/kernel/security/provenance/node_filter"
+#define PROV_RELATION_FILTER_FILE             "/sys/kernel/security/provenance/relation_filter"
+#define PROV_PROPAGATE_NODE_FILTER_FILE       "/sys/kernel/security/provenance/propagate_node_filter"
+#define PROV_PROPAGATE_RELATION_FILTER_FILE   "/sys/kernel/security/provenance/propagate_relation_filter"
+#define PROV_FLUSH_FILE                       "/sys/kernel/security/provenance/flush"
+#define PROV_FILE_FILE                        "/sys/kernel/security/provenance/file"
+#define PROV_PROCESS_FILE                     "/sys/kernel/security/provenance/process"
+#define PROV_IPV4_INGRESS_FILE                "/sys/kernel/security/provenance/ipv4_ingress"
+#define PROV_IPV4_EGRESS_FILE                 "/sys/kernel/security/provenance/ipv4_egress"
+#define PROV_SECCTX                           "/sys/kernel/security/provenance/secctx"
+#define PROV_SECCTX_FILTER                    "/sys/kernel/security/provenance/secctx_filter"
+#define PROV_CGROUP_FILTER										"/sys/kernel/security/provenance/cgroup"
+
+#define PROV_RELAY_NAME                       "/sys/kernel/debug/provenance"
+#define PROV_LONG_RELAY_NAME                  "/sys/kernel/debug/long_provenance"
+
+#define TYPE_MASK             0xFFFF000000000000UL
+#define SUBTYPE_MASK          0x0000FFFFFFFFFFFFUL
+
+#define W3C_TYPE(type)        (type & TYPE_MASK)
+#define SUBTYPE(type)         (type & SUBTYPE_MASK)
+
+/* W3C PROV TYPES */
+#define DM_RELATION           0x8000000000000000UL
+#define DM_ACTIVITY           0x4000000000000000UL
+#define DM_ENTITY             0x2000000000000000UL
+#define DM_AGENT              0x1000000000000000UL
+/* ALLOWED/DISALLOWED */
+#define RL_ALLOWED            0x0200000000000000UL
+#define RL_DISALLOWED         0x0100000000000000UL
+/* SUBTYPES */
+/* RELATIONS W3C TYPE*/
+#define RL_DERIVED            (DM_RELATION | 0x0080000000000000ULL)
+#define RL_GENERATED          (DM_RELATION | 0x0040000000000000ULL)
+#define RL_ATTRIBUTED         (DM_RELATION | 0x0020000000000000ULL)
+#define RL_USED               (DM_RELATION | 0x0010000000000000ULL)
+#define RL_INFORMED           (DM_RELATION | 0x0008000000000000ULL)
+#define RL_ASSOCIATED         (DM_RELATION | 0x0004000000000000ULL)
+#define RL_BEHALF             (DM_RELATION | 0x0002000000000000ULL)
+#define RL_UNKNOWN            (DM_RELATION | 0x0001000000000000ULL)
+/* DERIVED SUBTYPES */
+#define RL_NAMED              (RL_DERIVED   | 0x0000000000000001ULL)
+#define RL_VERSION            (RL_DERIVED   | 0x0000000000000002ULL)
+#define RL_MMAP               (RL_DERIVED   | 0x0000000000000004ULL)
+#define RL_SND_PACKET         (RL_DERIVED   | 0x0000000000000008ULL)
+#define RL_RCV_PACKET         (RL_DERIVED   | 0x0000000000000010ULL)
+/* GENERATED SUBTYPES */
+#define RL_CREATE             (RL_GENERATED | 0x0000000000000020ULL)
+#define RL_WRITE              (RL_GENERATED | 0x0000000000000040ULL)
+#define RL_PERM_WRITE         (RL_GENERATED | 0x0000000000000080ULL)
+#define RL_MMAP_WRITE         (RL_GENERATED | 0x0000000000000100ULL)
+#define RL_SH_WRITE           (RL_GENERATED | 0x0000000000000200ULL)
+#define RL_CONNECT            (RL_GENERATED | 0x0000000000000400ULL)
+#define RL_LISTEN             (RL_GENERATED | 0x0000000000000800ULL)
+#define RL_BIND               (RL_GENERATED | 0x0000000000001000ULL)
+#define RL_SND                (RL_GENERATED | 0x0000000000002000ULL)
+#define RL_LINK               (RL_GENERATED | 0x0000000000004000ULL)
+#define RL_SETATTR            (RL_GENERATED | 0x0000000000008000ULL)
+#define RL_SETXATTR           (RL_GENERATED | 0x0000000000010000ULL)
+#define RL_RMVXATTR           (RL_GENERATED | 0x0000000000020000ULL)
+/* USED SUBTYPES */
+#define RL_READ               (RL_USED      | 0x0000000000040000ULL)
+#define RL_MMAP_READ          (RL_USED      | 0x0000000000080000ULL)
+#define RL_PERM_READ          (RL_USED      | 0x0000000000100000ULL)
+#define RL_SH_READ            (RL_USED      | 0x0000000000200000ULL)
+#define RL_EXEC               (RL_USED      | 0x0000000000400000ULL)
+#define RL_MMAP_EXEC          (RL_USED      | 0x0000000000800000ULL)
+#define RL_PERM_EXEC          (RL_USED      | 0x0000000001000000ULL)
+#define RL_ACCEPT             (RL_USED      | 0x0000000002000000ULL)
+#define RL_RCV                (RL_USED      | 0x0000000004000000ULL)
+#define RL_OPEN               (RL_USED      | 0x0000000008000000ULL)
+#define RL_SEARCH             (RL_USED      | 0x0000000010000000ULL)
+#define RL_GETATTR            (RL_USED      | 0x0000000020000000ULL)
+#define RL_READLINK           (RL_USED      | 0x0000000040000000ULL)
+#define RL_GETXATTR           (RL_USED      | 0x0000000080000000ULL)
+#define RL_LSTXATTR           (RL_USED      | 0x0000000100000000ULL)
+#define RL_NAMED_PROCESS      (RL_USED      | 0x0000000200000000ULL)
+/* INFORMED SUBTYPES */
+#define RL_CLONE              (RL_INFORMED  | 0x0000000400000000ULL)
+#define RL_VERSION_PROCESS    (RL_INFORMED  | 0x0000000800000000ULL)
+#define RL_CHANGE             (RL_INFORMED  | 0x0000001000000000ULL)
+#define RL_EXEC_PROCESS       (RL_INFORMED  | 0x0000002000000000ULL)
+
+/* ACTIVITY SUBTYPES */
+#define ACT_TASK              (DM_ACTIVITY  | 0x0000000000000001ULL)
+#define ACT_DISC              (DM_ACTIVITY  | 0x0000000000000002ULL)
+/* AGENT SUBTYPES */
+#define AGT_USR               (DM_AGENT     | 0x0000000000000004ULL)
+#define AGT_GRP               (DM_AGENT     | 0x0000000000000008ULL)
+#define AGT_DISC              (DM_AGENT     | 0x0000000000000010ULL)
+/* ENTITY SUBTYPES */
+#define ENT_STR               (DM_ENTITY    | 0x0000000000000020ULL)
+#define ENT_INODE_UNKNOWN     (DM_ENTITY    | 0x0000000000000040ULL)
+#define ENT_INODE_LINK        (DM_ENTITY    | 0x0000000000000080ULL)
+#define ENT_INODE_FILE        (DM_ENTITY    | 0x0000000000000100ULL)
+#define ENT_INODE_DIRECTORY   (DM_ENTITY    | 0x0000000000000200ULL)
+#define ENT_INODE_CHAR        (DM_ENTITY    | 0x0000000000000400ULL)
+#define ENT_INODE_BLOCK       (DM_ENTITY    | 0x0000000000000800ULL)
+#define ENT_INODE_FIFO        (DM_ENTITY    | 0x0000000000001000ULL)
+#define ENT_INODE_SOCKET      (DM_ENTITY    | 0x0000000000002000ULL)
+#define ENT_INODE_MMAP        (DM_ENTITY    | 0x0000000000004000ULL)
+#define ENT_MSG               (DM_ENTITY    | 0x0000000000008000ULL)
+#define ENT_SHM               (DM_ENTITY    | 0x0000000000010000ULL)
+#define ENT_ADDR              (DM_ENTITY    | 0x0000000000020000ULL)
+#define ENT_SBLCK             (DM_ENTITY    | 0x0000000000040000ULL)
+#define ENT_FILE_NAME         (DM_ENTITY    | 0x0000000000080000ULL)
+#define ENT_PACKET            (DM_ENTITY    | 0x0000000000100000ULL)
+#define ENT_DISC              (DM_ENTITY    | 0x0000000000200000ULL)
+#define ENT_IATTR             (DM_ENTITY    | 0x0000000000400000ULL)
+#define ENT_XATTR             (DM_ENTITY    | 0x0000000000800000ULL)
+#define ENT_PCKCNT						(DM_ENTITY    | 0x0000000001000000ULL)
+
+#define FLOW_ALLOWED        1
+#define FLOW_DISALLOWED     0
+
+#define prov_type(prov)               ((prov)->node_info.identifier.node_id.type)
+#define prov_id_buffer(prov)          ((prov)->node_info.identifier.buffer)
+#define node_identifier(node)         ((node)->node_info.identifier.node_id)
+#define relation_identifier(relation) ((relation)->relation_info.identifier.relation_id)
+#define packet_identifier(packet)     ((packet)->pck_info.identifier.packet_id)
+#define prov_is_relation(prov)             ((relation_identifier(prov).type & DM_RELATION) != 0)
+#define prov_is_node(prov)                 ((node_identifier(prov).type & DM_RELATION) == 0)
+
+#define prov_flag(prov) ((prov)->msg_info.flag)
+#define prov_taint(prov) ((prov)->msg_info.taint)
+#define prov_jiffies(prov) ((prov)->msg_info.jiffies)
+
+struct node_identifier {
+	uint64_t type;
+	uint64_t id;
+	uint32_t boot_id;
+	uint32_t machine_id;
+	uint32_t version;
+};
+
+struct relation_identifier {
+	uint64_t type;
+	uint64_t id;
+	uint32_t boot_id;
+	uint32_t machine_id;
+};
+
+struct packet_identifier {
+	uint64_t type;
+	uint16_t id;
+	uint32_t snd_ip;
+	uint32_t rcv_ip;
+	uint16_t snd_port;
+	uint16_t rcv_port;
+	uint8_t protocol;
+	uint32_t seq;
+};
+
+#define PROV_IDENTIFIER_BUFFER_LENGTH sizeof(struct node_identifier)
+
+typedef union prov_identifier {
+	struct node_identifier node_id;
+	struct relation_identifier relation_id;
+	struct packet_identifier packet_id;
+	uint8_t buffer[PROV_IDENTIFIER_BUFFER_LENGTH];
+} prov_identifier_t;
+
+#define prov_set_flag(node, nbit) prov_flag(node) |= 1 << nbit
+#define prov_clear_flag(node, nbit) prov_flag(node) &= ~(1 << nbit)
+#define prov_check_flag(node, nbit) ((prov_flag(node) & (1 << nbit)) == (1 << nbit))
+
+#define RECORDED_BIT 0
+#define set_recorded(node)                  prov_set_flag(node, RECORDED_BIT)
+#define clear_recorded(node)                prov_clear_flag(node, RECORDED_BIT)
+#define provenance_is_recorded(node)        prov_check_flag(node, RECORDED_BIT)
+
+#define NAME_RECORDED_BIT 1
+#define set_name_recorded(node)             prov_set_flag(node, NAME_RECORDED_BIT)
+#define clear__name_recorded(node)          prov_clear_flag(node, NAME_RECORDED_BIT)
+#define provenance_is_name_recorded(node)   prov_check_flag(node, NAME_RECORDED_BIT)
+
+#define TRACKED_BIT 2
+#define set_tracked(node)                   prov_set_flag(node, TRACKED_BIT)
+#define clear_tracked(node)                 prov_clear_flag(node, TRACKED_BIT)
+#define provenance_is_tracked(node)         prov_check_flag(node, TRACKED_BIT)
+
+#define OPAQUE_BIT 3
+#define set_opaque(node)                    prov_set_flag(node, OPAQUE_BIT)
+#define clear_opaque(node)                  prov_clear_flag(node, OPAQUE_BIT)
+#define provenance_is_opaque(node)          prov_check_flag(node, OPAQUE_BIT)
+
+#define PROPAGATE_BIT 4
+#define set_propagate(node)                 prov_set_flag(node, PROPAGATE_BIT)
+#define clear_propagate(node)               prov_clear_flag(node, PROPAGATE_BIT)
+#define provenance_does_propagate(node)     prov_check_flag(node, PROPAGATE_BIT)
+
+#define RECORD_PACKET_BIT 5
+#define set_record_packet(node)							prov_set_flag(node, RECORD_PACKET_BIT)
+#define clear_record_packet(node)						prov_clear_flag(node, RECORD_PACKET_BIT)
+#define provenance_records_packet(node)			prov_check_flag(node, RECORD_PACKET_BIT)
+
+#define basic_elements prov_identifier_t identifier; uint8_t flag; uint64_t jiffies; uint8_t taint[PROV_N_BYTES]
+
+struct msg_struct {
+	basic_elements;
+};
+
+#define FILE_INFO_SET 0x01
+
+struct relation_struct {
+	basic_elements;
+	uint8_t allowed;
+	prov_identifier_t snd;
+	prov_identifier_t rcv;
+	uint8_t set;
+	int64_t offset;
+};
+
+struct node_struct {
+	basic_elements;
+};
+
+struct task_prov_struct {
+	basic_elements;
+	uint32_t uid;
+	uint32_t gid;
+	uint32_t pid;
+	uint32_t vpid;
+	uint32_t cid;
+	uint32_t secid;
+};
+
+struct inode_prov_struct {
+	basic_elements;
+	uint64_t ino;
+	uint32_t uid;
+	uint32_t gid;
+	uint16_t mode;
+	uint8_t sb_uuid[16];
+	uint32_t secid;
+};
+
+struct iattr_prov_struct {
+	basic_elements;
+	uint32_t valid;
+	uint16_t mode;
+	uint32_t uid;
+	uint32_t gid;
+	int64_t size;
+	int64_t atime;
+	int64_t ctime;
+	int64_t mtime;
+};
+
+struct msg_msg_struct {
+	basic_elements;
+	long type;
+};
+
+struct shm_struct {
+	basic_elements;
+	uint16_t mode;
+};
+
+struct sb_struct {
+	basic_elements;
+	uint8_t uuid[16];
+};
+
+struct pck_struct {
+	basic_elements;
+	uint16_t length;
+};
+
+typedef union prov_msg {
+	struct msg_struct msg_info;
+	struct relation_struct relation_info;
+	struct node_struct node_info;
+	struct task_prov_struct task_info;
+	struct inode_prov_struct inode_info;
+	struct msg_msg_struct msg_msg_info;
+	struct shm_struct shm_info;
+	struct sb_struct sb_info;
+	struct pck_struct pck_info;
+	struct iattr_prov_struct iattr_info;
+} prov_msg_t;
+
+struct str_struct {
+	basic_elements;
+	char str[PATH_MAX];
+	size_t length;
+};
+
+struct file_name_struct {
+	basic_elements;
+	char name[PATH_MAX];
+	size_t length;
+};
+
+struct address_struct {
+	basic_elements;
+	struct sockaddr addr;
+	size_t length;
+};
+
+#define PROV_TRUNCATED 1
+struct pckcnt_struct {
+	basic_elements;
+	uint8_t content[PATH_MAX];
+	size_t length;
+	uint8_t truncated;
+};
+
+#define PROV_XATTR_NAME_SIZE    256
+#define PROV_XATTR_VALUE_SIZE   (PATH_MAX - PROV_XATTR_NAME_SIZE)
+struct xattr_prov_struct {
+	basic_elements;
+	char name[PROV_XATTR_NAME_SIZE]; // max Linux characters
+	int32_t flags;
+	uint8_t value[PROV_XATTR_VALUE_SIZE];
+	size_t size;
+};
+
+struct disc_node_struct {
+	basic_elements;
+	size_t length;
+	char content[PATH_MAX];
+	prov_identifier_t parent;
+};
+
+typedef union long_msg {
+	struct msg_struct msg_info;
+	struct node_struct node_info;
+	struct str_struct str_info;
+	struct file_name_struct file_name_info;
+	struct address_struct address_info;
+	struct pckcnt_struct pckcnt_info;
+	struct disc_node_struct disc_node_info;
+	struct xattr_prov_struct xattr_info;
+} long_prov_msg_t;
+
+struct prov_filter {
+	uint64_t filter;
+	uint64_t mask;
+	uint8_t add;
+};
+
+#define PROV_SET_TRACKED      0x01
+#define PROV_SET_OPAQUE       0x02
+#define PROV_SET_PROPAGATE    0x04
+#define PROV_SET_TAINT        0x08
+
+struct prov_file_config {
+	char name[PATH_MAX];
+	prov_msg_t prov;
+	uint8_t op;
+};
+
+struct prov_self_config {
+	prov_msg_t prov;
+	uint8_t op;
+};
+
+struct prov_process_config {
+	prov_msg_t prov;
+	uint8_t op;
+	uint32_t vpid;
+};
+
+#define PROV_NET_TRACKED      0x01
+#define PROV_NET_OPAQUE       0x02
+#define PROV_NET_PROPAGATE    0x04
+#define PROV_NET_TAINT        0x08
+#define PROV_NET_RECORD       0x10
+#define PROV_NET_DELETE       0x20 // to actually delete a filter from the list
+
+struct prov_ipv4_filter {
+	uint32_t ip;
+	uint32_t mask;
+	uint16_t port;
+	uint8_t op;
+	uint64_t taint;
+};
+
+#define PROV_SEC_TRACKED      0x01
+#define PROV_SEC_OPAQUE       0x02
+#define PROV_SEC_PROPAGATE    0x04
+#define PROV_SEC_TAINT        0x08
+#define PROV_SEC_DELETE       0x10 // to actually delete a filter from the list
+
+struct secinfo {
+	uint32_t secid;
+	char secctx[PATH_MAX];
+	uint32_t len;
+	uint8_t op;
+	uint64_t taint;
+};
+
+#define PROV_CGROUP_TRACKED      0x01
+#define PROV_CGROUP_OPAQUE       0x02
+#define PROV_CGROUP_PROPAGATE    0x04
+#define PROV_CGROUP_TAINT        0x08
+#define PROV_CGROUP_DELETE       0x10 // to actually delete a filter from the list
+
+struct cgroupinfo {
+	uint32_t cid;
+	uint8_t op;
+	uint64_t taint;
+};
+
+#endif
diff -uprN -b -B ./pristine/linux-4.9.5/security/Kconfig ./linux-4.9.5/security/Kconfig
--- ./pristine/linux-4.9.5/security/Kconfig	2017-01-20 10:56:02.000000000 +0100
+++ ./linux-4.9.5/security/Kconfig	2017-01-23 19:44:14.820585144 +0100
@@ -164,6 +164,7 @@ source security/tomoyo/Kconfig
 source security/apparmor/Kconfig
 source security/loadpin/Kconfig
 source security/yama/Kconfig
+source security/provenance/Kconfig

 source security/integrity/Kconfig

diff -uprN -b -B ./pristine/linux-4.9.5/security/Makefile ./linux-4.9.5/security/Makefile
--- ./pristine/linux-4.9.5/security/Makefile	2017-01-20 10:56:02.000000000 +0100
+++ ./linux-4.9.5/security/Makefile	2017-01-23 19:44:14.823585167 +0100
@@ -8,6 +8,7 @@ subdir-$(CONFIG_SECURITY_SMACK)		+= smac
 subdir-$(CONFIG_SECURITY_TOMOYO)        += tomoyo
 subdir-$(CONFIG_SECURITY_APPARMOR)	+= apparmor
 subdir-$(CONFIG_SECURITY_YAMA)		+= yama
+subdir-$(CONFIG_SECURITY_PROVENANCE)	+= provenance
 subdir-$(CONFIG_SECURITY_LOADPIN)	+= loadpin

 # always enable default capabilities
@@ -23,6 +24,7 @@ obj-$(CONFIG_AUDIT)			+= lsm_audit.o
 obj-$(CONFIG_SECURITY_TOMOYO)		+= tomoyo/
 obj-$(CONFIG_SECURITY_APPARMOR)		+= apparmor/
 obj-$(CONFIG_SECURITY_YAMA)		+= yama/
+obj-$(CONFIG_SECURITY_PROVENANCE)		+= provenance/
 obj-$(CONFIG_SECURITY_LOADPIN)		+= loadpin/
 obj-$(CONFIG_CGROUP_DEVICE)		+= device_cgroup.o

diff -uprN -b -B ./pristine/linux-4.9.5/security/provenance/fs.c ./linux-4.9.5/security/provenance/fs.c
--- ./pristine/linux-4.9.5/security/provenance/fs.c	1970-01-01 01:00:00.000000000 +0100
+++ ./linux-4.9.5/security/provenance/fs.c	2017-01-23 19:44:14.816585113 +0100
@@ -0,0 +1,714 @@
+/*
+ *
+ * Author: Thomas Pasquier <thomas.pasquier@cl.cam.ac.uk>
+ *
+ * Copyright (C) 2015 University of Cambridge
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2, as
+ * published by the Free Software Foundation; either version 2 of the License, or
+ *	(at your option) any later version.
+ *
+ */
+
+#include <linux/security.h>
+
+#include "provenance.h"
+#include "provenance_inode.h"
+#include "provenance_task.h"
+#include "provenance_secctx.h"
+#include "provenance_cgroup.h"
+
+#define TMPBUFLEN       12
+
+#define declare_file_operations(ops_name, write_op, read_op) static const struct file_operations ops_name = { \
+		.write		= write_op, \
+		.read		= read_op, \
+		.llseek		= generic_file_llseek, \
+}
+
+static ssize_t no_read(struct file *filp, char __user *buf,
+		       size_t count, loff_t *ppos)
+{
+	return -EPERM; // write only
+}
+
+static ssize_t no_write(struct file *file, const char __user *buf,
+			size_t count, loff_t *ppos)
+{
+	return -EPERM; // read only
+}
+
+static inline void __init_opaque(void)
+{
+	provenance_mark_as_opaque(PROV_ENABLE_FILE);
+	provenance_mark_as_opaque(PROV_ALL_FILE);
+	provenance_mark_as_opaque(PROV_NODE_FILE);
+	provenance_mark_as_opaque(PROV_RELATION_FILE);
+	provenance_mark_as_opaque(PROV_SELF_FILE);
+	provenance_mark_as_opaque(PROV_MACHINE_ID_FILE);
+	provenance_mark_as_opaque(PROV_NODE_FILTER_FILE);
+	provenance_mark_as_opaque(PROV_RELATION_FILTER_FILE);
+	provenance_mark_as_opaque(PROV_PROPAGATE_NODE_FILTER_FILE);
+	provenance_mark_as_opaque(PROV_PROPAGATE_RELATION_FILTER_FILE);
+	provenance_mark_as_opaque(PROV_FLUSH_FILE);
+	provenance_mark_as_opaque(PROV_FILE_FILE);
+	provenance_mark_as_opaque(PROV_PROCESS_FILE);
+	provenance_mark_as_opaque(PROV_IPV4_INGRESS_FILE);
+	provenance_mark_as_opaque(PROV_IPV4_EGRESS_FILE);
+	provenance_mark_as_opaque(PROV_SECCTX);
+	provenance_mark_as_opaque(PROV_SECCTX_FILTER);
+	provenance_mark_as_opaque(PROV_CGROUP_FILTER);
+}
+
+static inline ssize_t __write_flag(struct file *file, const char __user *buf,
+				   size_t count, loff_t *ppos, bool *flag)
+
+{
+	char *page = NULL;
+	ssize_t length;
+	bool new_value;
+	uint32_t tmp;
+
+	/* no partial write */
+	if (*ppos > 0)
+		return -EINVAL;
+
+	if (!capable(CAP_AUDIT_CONTROL))
+		return -EPERM;
+
+	page = (char *)get_zeroed_page(GFP_KERNEL);
+	if (!page)
+		return -ENOMEM;
+
+	length =  -EFAULT;
+	if (copy_from_user(page, buf, count))
+		goto out;
+
+	length = kstrtouint(page, 2, &tmp);
+	if (length)
+		goto out;
+
+	new_value = tmp;
+	(*flag) = new_value;
+	length = count;
+out:
+	free_page((unsigned long)page);
+	return length;
+}
+
+static ssize_t __read_flag(struct file *filp, char __user *buf,
+			   size_t count, loff_t *ppos, bool flag)
+{
+	char tmpbuf[TMPBUFLEN];
+	ssize_t length;
+	int tmp = flag;
+
+	length = scnprintf(tmpbuf, TMPBUFLEN, "%d", tmp);
+	return simple_read_from_buffer(buf, count, ppos, tmpbuf, length);
+}
+
+#define declare_write_flag_fcn(fcn_name, flag) static ssize_t fcn_name(struct file *file, const char __user *buf, size_t count, loff_t *ppos) \
+	{ \
+		return __write_flag(file, buf, count, ppos, &flag); \
+	}
+#define declare_read_flag_fcn(fcn_name, flag) static ssize_t fcn_name(struct file *filp, char __user *buf, size_t count, loff_t *ppos) \
+	{ \
+		return __read_flag(filp, buf, count, ppos, flag); \
+	}
+
+declare_write_flag_fcn(prov_write_enable, prov_enabled);
+declare_read_flag_fcn(prov_read_enable, prov_enabled);
+declare_file_operations(prov_enable_ops, prov_write_enable, prov_read_enable);
+
+declare_write_flag_fcn(prov_write_all, prov_all);
+declare_read_flag_fcn(prov_read_all, prov_all);
+declare_file_operations(prov_all_ops, prov_write_all, prov_read_all);
+
+static ssize_t prov_write_machine_id(struct file *file, const char __user *buf,
+				     size_t count, loff_t *ppos)
+{
+	uint32_t *tmp = (uint32_t *)buf;
+
+	// ideally should be decoupled from set machine id
+	__init_opaque();
+
+	if (!capable(CAP_AUDIT_CONTROL))
+		return -EPERM;
+
+	if (count < sizeof(uint32_t))
+		return -ENOMEM;
+
+	if (copy_from_user(&prov_machine_id, tmp, sizeof(uint32_t)))
+		return -EAGAIN;
+
+	return count; // read only
+}
+
+static ssize_t prov_read_machine_id(struct file *filp, char __user *buf,
+				    size_t count, loff_t *ppos)
+{
+	if (count < sizeof(uint32_t))
+		return -ENOMEM;
+
+	if (copy_to_user(buf, &prov_machine_id, sizeof(uint32_t)))
+		return -EAGAIN;
+
+	return count;
+}
+declare_file_operations(prov_machine_id_ops, prov_write_machine_id, prov_read_machine_id);
+
+static ssize_t prov_write_node(struct file *file, const char __user *buf,
+			       size_t count, loff_t *ppos)
+
+{
+	struct provenance *cprov = current_provenance();
+	long_prov_msg_t *node = NULL;
+
+	if (!capable(CAP_AUDIT_WRITE))
+		return -EPERM;
+
+	if (count < sizeof(struct disc_node_struct))
+		return -ENOMEM;
+
+	node = kzalloc(sizeof(long_prov_msg_t), GFP_KERNEL);
+	if (copy_from_user(node, buf, sizeof(struct disc_node_struct))) {
+		count = -ENOMEM;
+		goto out;
+	}
+	if (prov_type(node) == ENT_DISC || prov_type(node) == ACT_DISC || prov_type(node) == AGT_DISC) {
+		spin_lock_nested(prov_lock(cprov), PROVENANCE_LOCK_TASK);
+		__record_node(prov_msg(cprov));
+		copy_node_info(&node->disc_node_info.parent, &prov_msg(cprov)->node_info.identifier);
+		spin_unlock(prov_lock(cprov));
+		node_identifier(node).id = prov_next_node_id();
+		node_identifier(node).boot_id = prov_boot_id;
+		node_identifier(node).machine_id = prov_machine_id;
+		long_prov_write(node);
+	} else{ // the node is not of disclosed type
+		count = -EINVAL;
+		goto out;
+	}
+
+	if (copy_to_user((void *)buf, &node, count)) {
+		count = -ENOMEM;
+		goto out;
+	}
+
+out:
+	if (node != NULL)
+		kfree(node);
+	return count;
+}
+declare_file_operations(prov_node_ops, prov_write_node, no_read);
+
+static ssize_t prov_write_relation(struct file *file, const char __user *buf,
+				   size_t count, loff_t *ppos)
+{
+	prov_msg_t relation;
+
+	if (!capable(CAP_AUDIT_WRITE))
+		return -EPERM;
+
+	if (count < sizeof(struct relation_struct))
+		return -ENOMEM;
+
+	if (copy_from_user(&relation, buf, sizeof(struct relation_struct)))
+		return -ENOMEM;
+
+	prov_write(&relation);
+	return count;
+}
+declare_file_operations(prov_relation_ops, prov_write_relation, no_read);
+
+static ssize_t prov_write_self(struct file *file, const char __user *buf,
+			       size_t count, loff_t *ppos)
+{
+	struct prov_self_config msg;
+	struct provenance *prov = current_provenance();
+	prov_msg_t *setting;
+	uint8_t op;
+
+	if (count < sizeof(struct prov_self_config))
+		return -EINVAL;
+
+	if (copy_from_user(&msg, buf, sizeof(struct prov_self_config)))
+		return -ENOMEM;
+
+	setting = &(msg.prov);
+	op = msg.op;
+	spin_lock_nested(prov_lock(prov), PROVENANCE_LOCK_TASK);
+	if ((op & PROV_SET_TRACKED) != 0) {
+		if (provenance_is_tracked(setting))
+			set_tracked(prov_msg(prov));
+		else
+			clear_tracked(prov_msg(prov));
+	}
+
+	if ((op & PROV_SET_OPAQUE) != 0) {
+		if (provenance_is_opaque(setting))
+			set_opaque(prov_msg(prov));
+		else
+			clear_opaque(prov_msg(prov));
+	}
+
+	if ((op & PROV_SET_PROPAGATE) != 0) {
+		if (provenance_does_propagate(setting))
+			set_propagate(prov_msg(prov));
+		else
+			clear_propagate(prov_msg(prov));
+	}
+
+	if ((op & PROV_SET_TAINT) != 0)
+		prov_bloom_merge(prov_taint(prov_msg(prov)), prov_taint(setting));
+	spin_unlock(prov_lock(prov));
+
+	return sizeof(struct prov_self_config);
+}
+
+static ssize_t prov_read_self(struct file *filp, char __user *buf,
+			      size_t count, loff_t *ppos)
+{
+	struct provenance *cprov = current_provenance();
+	prov_msg_t *tmp = (prov_msg_t *)buf;
+
+	if (count < sizeof(struct task_prov_struct))
+		return -ENOMEM;
+
+	spin_lock_nested(prov_lock(cprov), PROVENANCE_LOCK_TASK);
+	if (copy_to_user(tmp, prov_msg(cprov), sizeof(prov_msg_t)))
+		count = -EAGAIN;
+	spin_unlock(prov_lock(cprov));
+	return count; // write only
+}
+declare_file_operations(prov_self_ops, prov_write_self, prov_read_self);
+
+static inline ssize_t __write_filter(struct file *file, const char __user *buf,
+				     size_t count, uint64_t *filter)
+{
+	struct prov_filter *setting;
+
+	if (!capable(CAP_AUDIT_CONTROL))
+		return -EPERM;
+
+	if (count < sizeof(struct prov_filter))
+		return -ENOMEM;
+
+	setting = (struct prov_filter *)buf;
+
+	if (setting->add != 0)
+		(*filter) |= setting->filter & setting->mask;
+	else
+		(*filter) &=  ~(setting->filter & setting->mask);
+
+	return count;
+}
+
+static inline ssize_t __read_filter(struct file *filp, char __user *buf,
+				    size_t count, uint64_t filter)
+{
+	if (count < sizeof(uint64_t))
+		return -ENOMEM;
+
+	if (copy_to_user(buf, &filter, sizeof(uint64_t)))
+		return -EAGAIN;
+
+	return count;
+}
+
+#define declare_write_filter_fcn(fcn_name, filter) static ssize_t fcn_name(struct file *file, const char __user *buf, size_t count, loff_t *ppos) \
+	{ \
+		return __write_filter(file, buf, count, &filter); \
+	}
+#define declare_reader_filter_fcn(fcn_name, filter) static ssize_t fcn_name(struct file *filp, char __user *buf, size_t count, loff_t *ppos) \
+	{ \
+		return __read_filter(filp, buf, count, filter);	\
+	}
+
+uint64_t prov_node_filter;
+declare_write_filter_fcn(prov_write_node_filter, prov_node_filter);
+declare_reader_filter_fcn(prov_read_node_filter, prov_node_filter);
+declare_file_operations(prov_node_filter_ops, prov_write_node_filter, prov_read_node_filter);
+
+uint64_t prov_relation_filter;
+declare_write_filter_fcn(prov_write_relation_filter, prov_relation_filter);
+declare_reader_filter_fcn(prov_read_relation_filter, prov_relation_filter);
+declare_file_operations(prov_relation_filter_ops, prov_write_relation_filter, prov_read_relation_filter);
+
+uint64_t prov_propagate_node_filter;
+declare_write_filter_fcn(prov_write_propagate_node_filter, prov_propagate_node_filter);
+declare_reader_filter_fcn(prov_read_propagate_node_filter, prov_propagate_node_filter);
+declare_file_operations(prov_propagate_node_filter_ops, prov_write_propagate_node_filter, prov_read_propagate_node_filter);
+
+uint64_t prov_propagate_relation_filter;
+declare_write_filter_fcn(prov_write_propagate_relation_filter, prov_propagate_relation_filter);
+declare_reader_filter_fcn(prov_read_propagate_relation_filter, prov_propagate_relation_filter);
+declare_file_operations(prov_propagate_relation_filter_ops, prov_write_propagate_relation_filter, prov_read_propagate_relation_filter);
+
+static ssize_t prov_write_flush(struct file *file, const char __user *buf,
+				size_t count, loff_t *ppos)
+
+{
+	if (!capable(CAP_AUDIT_CONTROL))
+		return -EPERM;
+
+	prov_flush();
+	return 0;
+}
+declare_file_operations(prov_flush_ops, prov_write_flush, no_read);
+
+static ssize_t prov_write_file(struct file *file, const char __user *buf,
+			       size_t count, loff_t *ppos)
+{
+	struct prov_file_config *msg;
+	struct inode *in;
+	struct provenance *prov;
+	prov_msg_t *setting;
+	uint8_t op;
+
+	if (!capable(CAP_AUDIT_CONTROL))
+		return -EPERM;
+
+	if (count < sizeof(struct prov_file_config))
+		return -EINVAL;
+
+	msg = (struct prov_file_config *)buf;
+
+	in = file_name_to_inode(msg->name);
+	if (!in) {
+		printk(KERN_ERR "Provenance: could not find %s file.", msg->name);
+		return -EINVAL;
+	}
+	op = msg->op;
+	setting = &msg->prov;
+	prov = inode_provenance(in);
+	spin_lock_nested(prov_lock(prov), PROVENANCE_LOCK_INODE);
+	if ((op & PROV_SET_TRACKED) != 0) {
+		if (provenance_is_tracked(setting))
+			set_tracked(prov_msg(prov));
+		else
+			clear_tracked(prov_msg(prov));
+	}
+
+	if ((op & PROV_SET_OPAQUE) != 0) {
+		if (provenance_is_opaque(setting))
+			set_opaque(prov_msg(prov));
+		else
+			clear_opaque(prov_msg(prov));
+	}
+
+	if ((op & PROV_SET_PROPAGATE) != 0) {
+		if (provenance_does_propagate(setting))
+			set_propagate(prov_msg(prov));
+		else
+			clear_propagate(prov_msg(prov));
+	}
+
+	if ((op & PROV_SET_TAINT) != 0)
+		prov_bloom_merge(prov_taint(prov_msg(prov)), prov_taint(setting));
+	spin_unlock(prov_lock(prov));
+	return sizeof(struct prov_file_config);
+}
+
+static ssize_t prov_read_file(struct file *filp, char __user *buf,
+			      size_t count, loff_t *ppos)
+{
+	struct prov_file_config *msg;
+	struct inode *in;
+	struct provenance *prov;
+	int rtn = sizeof(struct prov_file_config);
+
+	if (count < sizeof(struct prov_file_config))
+		return -EINVAL;
+
+	msg = (struct prov_file_config *)buf;
+	in = file_name_to_inode(msg->name);
+	if (!in) {
+		printk(KERN_ERR "Provenance: could not find %s file.", msg->name);
+		return -EINVAL;
+	}
+
+	prov = inode_provenance(in);
+	spin_lock_nested(prov_lock(prov), PROVENANCE_LOCK_INODE);
+	if (copy_to_user(&msg->prov, prov, sizeof(prov_msg_t)))
+		rtn = -ENOMEM;
+	spin_unlock(prov_lock(prov));
+	return rtn;
+}
+declare_file_operations(prov_file_ops, prov_write_file, prov_read_file);
+
+static ssize_t prov_write_process(struct file *file, const char __user *buf,
+				  size_t count, loff_t *ppos)
+{
+	struct prov_process_config *msg;
+	struct provenance *prov;
+	prov_msg_t *setting;
+	uint8_t op;
+
+	if (!capable(CAP_AUDIT_CONTROL))
+		return -EPERM;
+
+	if (count < sizeof(struct prov_process_config))
+		return -EINVAL;
+
+	msg = (struct prov_process_config *)buf;
+
+	setting = &(msg->prov);
+	op = msg->op;
+
+	prov = prov_from_vpid(msg->vpid);
+	if (prov == NULL)
+		return -EINVAL;
+
+	spin_lock_nested(prov_lock(prov), PROVENANCE_LOCK_TASK);
+	if ((op & PROV_SET_TRACKED) != 0) {
+		if (provenance_is_tracked(setting))
+			set_tracked(prov_msg(prov));
+		else
+			clear_tracked(prov_msg(prov));
+	}
+
+	if ((op & PROV_SET_OPAQUE) != 0) {
+		if (provenance_is_opaque(setting))
+			set_opaque(prov_msg(prov));
+		else
+			clear_opaque(prov_msg(prov));
+	}
+
+	if ((op & PROV_SET_PROPAGATE) != 0) {
+		if (provenance_does_propagate(setting))
+			set_propagate(prov_msg(prov));
+		else
+			clear_propagate(prov_msg(prov));
+	}
+
+	if ((op & PROV_SET_TAINT) != 0)
+		prov_bloom_merge(prov_taint(prov_msg(prov)), prov_taint(setting));
+
+	spin_unlock(prov_lock(prov));
+	return sizeof(struct prov_process_config);
+}
+
+static ssize_t prov_read_process(struct file *filp, char __user *buf,
+				 size_t count, loff_t *ppos)
+{
+	struct prov_process_config *msg;
+	struct provenance *prov;
+	int rtn = sizeof(struct prov_process_config);
+
+	if (count < sizeof(struct prov_process_config))
+		return -EINVAL;
+
+	msg = (struct prov_process_config *)buf;
+
+	prov = prov_from_vpid(msg->vpid);
+	if (prov == NULL)
+		return -EINVAL;
+
+	spin_lock_nested(prov_lock(prov), PROVENANCE_LOCK_TASK);
+	if (copy_to_user(&msg->prov, prov_msg(prov), sizeof(prov_msg_t)))
+		rtn = -ENOMEM;
+	spin_unlock(prov_lock(prov));
+	return rtn;
+}
+declare_file_operations(prov_process_ops, prov_write_process, prov_read_process);
+
+static inline ssize_t __write_ipv4_filter(struct file *file, const char __user *buf,
+					  size_t count, struct ipv4_filters *filters)
+{
+	struct ipv4_filters     *f;
+
+	if (!capable(CAP_AUDIT_CONTROL))
+		return -EPERM;
+
+	if (count < sizeof(struct prov_ipv4_filter))
+		return -ENOMEM;
+
+	f = kzalloc(sizeof(struct ipv4_filters), GFP_KERNEL);
+	if (copy_from_user(&f->filter, buf, sizeof(struct prov_ipv4_filter)))
+		return -EAGAIN;
+	f->filter.ip = f->filter.ip & f->filter.mask;
+
+	// we are not trying to delete something
+	if ((f->filter.op & PROV_NET_DELETE) != PROV_NET_DELETE)
+		prov_ipv4_add_or_update(filters, f);
+	else
+		prov_ipv4_delete(filters, f);
+	return sizeof(struct prov_ipv4_filter);
+}
+
+static inline ssize_t __read_ipv4_filter(struct file *filp, char __user *buf,
+					 size_t count, struct ipv4_filters *filters)
+{
+	struct ipv4_filters *tmp;
+	size_t pos = 0;
+
+	if (count < sizeof(struct prov_ipv4_filter))
+		return -ENOMEM;
+
+	list_for_each_entry(tmp, &(filters->list), list) {
+		if (count < pos + sizeof(struct prov_ipv4_filter))
+			return -ENOMEM;
+
+		if (copy_to_user(buf + pos, &(tmp->filter), sizeof(struct prov_ipv4_filter)))
+			return -EAGAIN;
+
+		pos += sizeof(struct prov_ipv4_filter);
+	}
+	return pos;
+}
+
+#define declare_write_ipv4_filter_fcn(fcn_name, filter) static ssize_t fcn_name(struct file *file, const char __user *buf, size_t count, loff_t *ppos) \
+	{ \
+		return __write_ipv4_filter(file, buf, count, &filter); \
+	}
+#define declare_reader_ipv4_filter_fcn(fcn_name, filter) static ssize_t fcn_name(struct file *filp, char __user *buf, size_t count, loff_t *ppos) \
+	{ \
+		return __read_ipv4_filter(filp, buf, count, &filter); \
+	}
+
+declare_write_ipv4_filter_fcn(prov_write_ipv4_ingress_filter, ingress_ipv4filters);
+declare_reader_ipv4_filter_fcn(prov_read_ipv4_ingress_filter, ingress_ipv4filters);
+declare_file_operations(prov_ipv4_ingress_filter_ops, prov_write_ipv4_ingress_filter, prov_read_ipv4_ingress_filter);
+
+declare_write_ipv4_filter_fcn(prov_write_ipv4_egress_filter, egress_ipv4filters);
+declare_reader_ipv4_filter_fcn(prov_read_ipv4_egress_filter, egress_ipv4filters);
+declare_file_operations(prov_ipv4_egress_filter_ops, prov_write_ipv4_egress_filter, prov_read_ipv4_egress_filter);
+
+static ssize_t prov_read_secctx(struct file *filp, char __user *buf,
+				size_t count, loff_t *ppos)
+{
+	char *ctx = NULL;
+	uint32_t len;
+	struct secinfo *data;
+	int rtn = 0;
+
+	if (count < sizeof(struct secinfo))
+		return -ENOMEM;
+	data = (struct secinfo *)buf;
+
+	rtn = security_secid_to_secctx(data->secid, &ctx, &len); // read secctx
+	if (rtn < 0)
+		goto out;
+	if (len < PATH_MAX) {
+		if (copy_to_user(data->secctx, ctx, len)) {
+			rtn = -ENOMEM;
+			goto out;
+		}
+		data->secctx[len] = '\0'; // maybe unecessary
+		data->len = len;
+	} else
+		rtn = -ENOMEM;
+out:
+	security_release_secctx(ctx, len); // security module dealloc
+	return rtn;
+}
+declare_file_operations(prov_secctx_ops, no_write, prov_read_secctx);
+
+static ssize_t prov_write_secctx_filter(struct file *file, const char __user *buf,
+					size_t count, loff_t *ppos)
+{
+	struct secctx_filters *s;
+
+	if (count < sizeof(struct secinfo))
+		return -ENOMEM;
+
+	s = kzalloc(sizeof(struct secctx_filters), GFP_KERNEL);
+	if (copy_from_user(&s->filter, buf, sizeof(struct secinfo)))
+		return -EAGAIN;
+
+	security_secctx_to_secid(s->filter.secctx, s->filter.len, &s->filter.secid);
+	if ((s->filter.op & PROV_SEC_DELETE) != PROV_SEC_DELETE)
+		prov_secctx_add_or_update(&secctx_filters, s);
+	else
+		prov_secctx_delete(&secctx_filters, s);
+	return 0;
+}
+
+static ssize_t prov_read_secctx_filter(struct file *filp, char __user *buf,
+				       size_t count, loff_t *ppos)
+{
+	struct secctx_filters *tmp;
+	size_t pos = 0;
+
+	if (count < sizeof(struct secinfo))
+		return -ENOMEM;
+
+	list_for_each_entry(tmp, &(secctx_filters.list), list) {
+		if (count < pos + sizeof(struct secinfo))
+			return -ENOMEM;
+
+		if (copy_to_user(buf + pos, &(tmp->filter), sizeof(struct secinfo)))
+			return -EAGAIN;
+		pos += sizeof(struct secinfo);
+	}
+	return pos;
+}
+declare_file_operations(prov_secctx_filter_ops, prov_write_secctx_filter, prov_read_secctx_filter);
+
+static ssize_t prov_write_cgroup_filter(struct file *file, const char __user *buf,
+					size_t count, loff_t *ppos)
+{
+	struct cgroup_filters *s;
+
+	if (count < sizeof(struct cgroupinfo))
+		return -ENOMEM;
+
+	s = kzalloc(sizeof(struct cgroup_filters), GFP_KERNEL);
+	if (copy_from_user(&s->filter, buf, sizeof(struct cgroupinfo)))
+		return -EAGAIN;
+	if ((s->filter.op & PROV_CGROUP_DELETE) != PROV_CGROUP_DELETE)
+		prov_cgroup_add_or_update(&cgroup_filters, s);
+	else
+		prov_cgroup_delete(&cgroup_filters, s);
+	return 0;
+}
+
+static ssize_t prov_read_cgroup_filter(struct file *filp, char __user *buf,
+				       size_t count, loff_t *ppos)
+{
+	struct cgroup_filters *tmp;
+	size_t pos = 0;
+
+	if (count < sizeof(struct cgroupinfo))
+		return -ENOMEM;
+
+	list_for_each_entry(tmp, &(cgroup_filters.list), list) {
+		if (count < pos + sizeof(struct cgroupinfo))
+			return -ENOMEM;
+
+		if (copy_to_user(buf + pos, &(tmp->filter), sizeof(struct cgroupinfo)))
+			return -EAGAIN;
+		pos += sizeof(struct cgroupinfo);
+	}
+	return pos;
+}
+declare_file_operations(prov_cgroup_filter_ops, prov_write_cgroup_filter, prov_read_cgroup_filter);
+
+static int __init init_prov_fs(void)
+{
+	struct dentry *prov_dir;
+	prov_dir = securityfs_create_dir("provenance", NULL);
+	securityfs_create_file("enable", 0644, prov_dir, NULL, &prov_enable_ops);
+	securityfs_create_file("all", 0644, prov_dir, NULL, &prov_all_ops);
+	securityfs_create_file("node", 0666, prov_dir, NULL, &prov_node_ops);
+	securityfs_create_file("relation", 0666, prov_dir, NULL, &prov_relation_ops);
+	securityfs_create_file("self", 0666, prov_dir, NULL, &prov_self_ops);
+	securityfs_create_file("machine_id", 0444, prov_dir, NULL, &prov_machine_id_ops);
+	securityfs_create_file("node_filter", 0644, prov_dir, NULL, &prov_node_filter_ops);
+	securityfs_create_file("relation_filter", 0644, prov_dir, NULL, &prov_relation_filter_ops);
+	securityfs_create_file("propagate_node_filter", 0644, prov_dir, NULL, &prov_propagate_node_filter_ops);
+	securityfs_create_file("propagate_relation_filter", 0644, prov_dir, NULL, &prov_propagate_relation_filter_ops);
+	securityfs_create_file("flush", 0600, prov_dir, NULL, &prov_flush_ops);
+	securityfs_create_file("file", 0644, prov_dir, NULL, &prov_file_ops);
+	securityfs_create_file("process", 0644, prov_dir, NULL, &prov_process_ops);
+	securityfs_create_file("ipv4_ingress", 0644, prov_dir, NULL, &prov_ipv4_ingress_filter_ops);
+	securityfs_create_file("ipv4_egress", 0644, prov_dir, NULL, &prov_ipv4_egress_filter_ops);
+	securityfs_create_file("secctx", 0644, prov_dir, NULL, &prov_secctx_ops);
+	securityfs_create_file("secctx_filter", 0644, prov_dir, NULL, &prov_secctx_filter_ops);
+	securityfs_create_file("cgroup", 0644, prov_dir, NULL, &prov_cgroup_filter_ops);
+	printk(KERN_INFO "Provenance fs ready.\n");
+	return 0;
+}
+
+core_initcall(init_prov_fs);
diff -uprN -b -B ./pristine/linux-4.9.5/security/provenance/hooks.c ./linux-4.9.5/security/provenance/hooks.c
--- ./pristine/linux-4.9.5/security/provenance/hooks.c	1970-01-01 01:00:00.000000000 +0100
+++ ./linux-4.9.5/security/provenance/hooks.c	2017-01-23 19:44:14.815585106 +0100
@@ -0,0 +1,1284 @@
+/*
+ *
+ * Author: Thomas Pasquier <thomas.pasquier@cl.cam.ac.uk>
+ *
+ * Copyright (C) 2015 University of Cambridge
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2, as
+ * published by the Free Software Foundation; either version 2 of the License, or
+ *	(at your option) any later version.
+ *
+ */
+#include <linux/slab.h>
+#include <linux/lsm_hooks.h>
+#include <linux/msg.h>
+#include <net/sock.h>
+#include <linux/binfmts.h>
+#include <linux/random.h>
+#include <linux/xattr.h>
+#include <linux/file.h>
+
+#include "av_utils.h"
+#include "provenance.h"
+#include "provenance_net.h"
+#include "provenance_inode.h"
+#include "provenance_task.h"
+#include "provenance_long.h"
+#include "provenance_secctx.h"
+#include "provenance_cgroup.h"
+
+/*
+ * initialise the security for the init task
+ */
+static void cred_init_provenance(void)
+{
+	struct cred *cred = (struct cred *)current->real_cred;
+	struct provenance *prov = alloc_provenance(ACT_TASK, GFP_KERNEL);
+
+	if (!prov)
+		panic("Provenance:  Failed to initialize initial task.\n");
+	prov_msg(prov)->task_info.uid = __kuid_val(cred->euid);
+	prov_msg(prov)->task_info.gid = __kgid_val(cred->egid);
+	cred->provenance = prov;
+}
+
+/*
+ * @cred points to the credentials.
+ * @gfp indicates the atomicity of any memory allocations.
+ * Only allocate sufficient memory and attach to @cred such that
+ * cred_transfer() will not get ENOMEM.
+ */
+static int provenance_cred_alloc_blank(struct cred *cred, gfp_t gfp)
+{
+	struct provenance *prov  = alloc_provenance(ACT_TASK, gfp);
+
+	if (!prov)
+		return -ENOMEM;
+
+	prov_msg(prov)->task_info.uid = __kuid_val(cred->euid);
+	prov_msg(prov)->task_info.gid = __kgid_val(cred->egid);
+
+	cred->provenance = prov;
+	return 0;
+}
+
+/*
+ * @cred points to the credentials.
+ * Deallocate and clear the cred->security field in a set of credentials.
+ */
+static void provenance_cred_free(struct cred *cred)
+{
+	free_provenance(cred->provenance);
+	cred->provenance = NULL;
+}
+
+/*
+ * @new points to the new credentials.
+ * @old points to the original credentials.
+ * @gfp indicates the atomicity of any memory allocations.
+ * Prepare a new set of credentials by copying the data from the old set.
+ */
+static int provenance_cred_prepare(struct cred *new, const struct cred *old, gfp_t gfp)
+{
+	struct provenance *old_prov = old->provenance;
+	struct provenance *prov = alloc_provenance(ACT_TASK, gfp);
+
+	if (!prov)
+		return -ENOMEM;
+	//task_config_from_file(current);
+	prov_msg(prov)->task_info.uid = __kuid_val(new->euid);
+	prov_msg(prov)->task_info.gid = __kgid_val(new->egid);
+	spin_lock_nested(prov_lock(old_prov), PROVENANCE_LOCK_TASK);
+	prov->has_mmap = old_prov->has_mmap;
+	flow_between_activities(RL_CLONE, old_prov, prov, FLOW_ALLOWED, NULL);
+	spin_unlock(prov_lock(old_prov));
+	new->provenance = prov;
+	return 0;
+}
+
+/*
+ * @new points to the new credentials.
+ * @old points to the original credentials.
+ * Transfer data from original creds to new creds
+ */
+static void provenance_cred_transfer(struct cred *new, const struct cred *old)
+{
+	const struct provenance *old_prov = old->provenance;
+	struct provenance *prov = new->provenance;
+
+	*prov =  *old_prov;
+}
+
+/*
+ * Update the module's state after setting one or more of the user
+ * identity attributes of the current process.  The @flags parameter
+ * indicates which of the set*uid system calls invoked this hook.if
+ * @new is the set of credentials that will be installed.  Modifications
+ * should be made to this rather than to @current->cred.
+ * @old is the set of credentials that are being replaces
+ * @flags contains one of the LSM_SETID_* values.
+ * Return 0 on success.
+ */
+static int provenance_task_fix_setuid(struct cred *new, const struct cred *old, int flags)
+{
+	struct provenance *old_prov = old->provenance;
+	struct provenance *prov = new->provenance;
+
+	spin_lock_nested(prov_lock(old_prov), PROVENANCE_LOCK_TASK);
+	flow_between_activities(RL_CHANGE, old_prov, prov, FLOW_ALLOWED, NULL);
+	spin_unlock(prov_lock(old_prov));
+	return 0;
+}
+
+/*
+ * Allocate and attach a security structure to @inode->i_security.  The
+ * i_security field is initialized to NULL when the inode structure is
+ * allocated.
+ * @inode contains the inode structure.
+ * Return 0 if operation was successful.
+ */
+static int provenance_inode_alloc_security(struct inode *inode)
+{
+	struct provenance *iprov = alloc_provenance(ENT_INODE_UNKNOWN, GFP_KERNEL);
+	struct provenance *sprov;
+
+	if (unlikely(!iprov))
+		return -ENOMEM;
+
+	prov_msg(iprov)->inode_info.ino = inode->i_ino;
+	prov_msg(iprov)->inode_info.uid = __kuid_val(inode->i_uid);
+	prov_msg(iprov)->inode_info.gid = __kgid_val(inode->i_gid);
+	security_inode_getsecid(inode, &(prov_msg(iprov)->inode_info.secid));
+	record_inode_type(inode->i_mode, iprov);
+	sprov = inode->i_sb->s_provenance;
+	memcpy(prov_msg(iprov)->inode_info.sb_uuid, prov_msg(sprov)->sb_info.uuid, 16 * sizeof(uint8_t));
+
+	inode->i_provenance = iprov;
+	return 0;
+}
+
+/*
+ * @inode contains the inode structure.
+ * Deallocate the inode security structure and set @inode->i_security to
+ * NULL.
+ */
+static void provenance_inode_free_security(struct inode *inode)
+{
+	free_provenance(inode->i_provenance);
+	inode->i_provenance = NULL;
+}
+
+/*
+ * Check permission to create a regular file.
+ * @dir contains inode structure of the parent of the new file.
+ * @dentry contains the dentry structure for the file to be created.
+ * @mode contains the file mode of the file to be created.
+ * Return 0 if permission is granted.
+ */
+static int provenance_inode_create(struct inode *dir, struct dentry *dentry, umode_t mode)
+{
+	struct provenance *cprov = get_current_provenance();
+	struct provenance *iprov = inode_provenance(dir);
+
+	if (!iprov)
+		return -ENOMEM;
+
+	spin_lock_nested(prov_lock(cprov), PROVENANCE_LOCK_TASK);
+	spin_lock_nested(prov_lock(iprov), PROVENANCE_LOCK_DIR);
+	flow_from_activity(RL_WRITE, cprov, iprov, FLOW_ALLOWED, NULL);
+	spin_unlock(prov_lock(iprov));
+	spin_unlock(prov_lock(cprov));
+	return 0;
+}
+
+/*
+ * Check permission before accessing an inode.  This hook is called by the
+ * existing Linux permission function, so a security module can use it to
+ * provide additional checking for existing Linux permission checks.
+ * Notice that this hook is called when a file is opened (as well as many
+ * other operations), whereas the file_security_ops permission hook is
+ * called when the actual read/write operations are performed.
+ * @inode contains the inode structure to check.
+ * @mask contains the permission mask.
+ * Return 0 if permission is granted.
+ */
+static int provenance_inode_permission(struct inode *inode, int mask)
+{
+	struct provenance *cprov = get_current_provenance();
+	struct provenance *iprov = NULL;
+	uint32_t perms;
+
+	if (!mask)
+		return 0;
+	if (unlikely(IS_PRIVATE(inode)))
+		return 0;
+	iprov = inode->i_provenance;
+	if (iprov == NULL)
+		return -ENOMEM;
+
+	perms = file_mask_to_perms(inode->i_mode, mask);
+	spin_lock_nested(prov_lock(cprov), PROVENANCE_LOCK_TASK);
+	spin_lock_nested(prov_lock(iprov), PROVENANCE_LOCK_INODE);
+	if (is_inode_dir(inode)) {
+		if ((perms & (DIR__WRITE)) != 0)
+			flow_from_activity(RL_PERM_WRITE, cprov, iprov, FLOW_ALLOWED, NULL);
+		if ((perms & (DIR__READ)) != 0)
+			flow_to_activity(RL_PERM_READ, iprov, cprov, FLOW_ALLOWED, NULL);
+		if ((perms & (DIR__SEARCH)) != 0)
+			flow_to_activity(RL_PERM_EXEC, iprov, cprov, FLOW_ALLOWED, NULL);
+	} else if (is_inode_socket(inode)) {
+		if ((perms & (FILE__WRITE | FILE__APPEND)) != 0)
+			flow_from_activity(RL_PERM_WRITE, cprov, iprov, FLOW_ALLOWED, NULL);
+		if ((perms & (FILE__READ)) != 0)
+			flow_to_activity(RL_PERM_READ, iprov, cprov, FLOW_ALLOWED, NULL);
+	} else {
+		if ((perms & (FILE__WRITE | FILE__APPEND)) != 0)
+			flow_from_activity(RL_PERM_WRITE, cprov, iprov, FLOW_ALLOWED, NULL);
+		if ((perms & (FILE__READ)) != 0)
+			flow_to_activity(RL_PERM_READ, iprov, cprov, FLOW_ALLOWED, NULL);
+		if ((perms & (FILE__EXECUTE)) != 0)
+			flow_to_activity(RL_PERM_EXEC, iprov, cprov, FLOW_ALLOWED, NULL);
+	}
+	spin_unlock(prov_lock(iprov));
+	spin_unlock(prov_lock(cprov));
+	return 0;
+}
+
+/*
+ * Check permission before creating a new hard link to a file.
+ * @old_dentry contains the dentry structure for an existing
+ * link to the file.
+ * @dir contains the inode structure of the parent directory
+ * of the new link.
+ * @new_dentry contains the dentry structure for the new link.
+ * Return 0 if permission is granted.
+ */
+
+static int provenance_inode_link(struct dentry *old_dentry, struct inode *dir, struct dentry *new_dentry)
+{
+	struct provenance *cprov = get_current_provenance();
+	struct provenance *dprov = NULL;
+	struct provenance *iprov;
+
+	iprov = dentry_provenance(old_dentry);
+	if (!iprov)
+		return -ENOMEM;
+
+	dprov = inode_provenance(dir);
+	if (!dprov)
+		return -ENOMEM;
+	spin_lock_nested(prov_lock(cprov), PROVENANCE_LOCK_TASK);
+	spin_lock_nested(prov_lock(dprov), PROVENANCE_LOCK_DIR);
+	spin_lock_nested(prov_lock(iprov), PROVENANCE_LOCK_INODE);
+	flow_from_activity(RL_LINK, cprov, dprov, FLOW_ALLOWED, NULL);
+	flow_from_activity(RL_LINK, cprov, iprov, FLOW_ALLOWED, NULL);
+	flow_between_entities(RL_LINK, dprov, iprov, FLOW_ALLOWED, NULL);
+	spin_unlock(prov_lock(iprov));
+	spin_unlock(prov_lock(dprov));
+	spin_unlock(prov_lock(cprov));
+	record_inode_name_from_dentry(new_dentry, iprov);
+	return 0;
+}
+
+/*
+ * Check for permission to rename a file or directory.
+ * @old_dir contains the inode structure for parent of the old link.
+ * @old_dentry contains the dentry structure of the old link.
+ * @new_dir contains the inode structure for parent of the new link.
+ * @new_dentry contains the dentry structure of the new link.
+ * Return 0 if permission is granted.
+ */
+static int provenance_inode_rename(struct inode *old_dir, struct dentry *old_dentry,
+				   struct inode *new_dir, struct dentry *new_dentry)
+{
+	return provenance_inode_link(old_dentry, new_dir, new_dentry);
+}
+
+/*
+ * Check permission before setting file attributes.  Note that the kernel
+ * call to notify_change is performed from several locations, whenever
+ * file attributes change (such as when a file is truncated, chown/chmod
+ * operations, transferring disk quotas, etc).
+ * @dentry contains the dentry structure for the file.
+ * @attr is the iattr structure containing the new file attributes.
+ * Return 0 if permission is granted.
+ */
+static int provenance_inode_setattr(struct dentry *dentry, struct iattr *iattr)
+{
+	struct provenance *cprov = get_current_provenance();
+	struct provenance *iprov;
+	struct provenance *iattrprov;
+
+	iprov = dentry_provenance(dentry);
+	if (!iprov)
+		return -ENOMEM;
+	iattrprov = alloc_provenance(ENT_IATTR, GFP_KERNEL);
+
+	prov_msg(iattrprov)->iattr_info.valid = iattr->ia_valid;
+	prov_msg(iattrprov)->iattr_info.mode = iattr->ia_mode;
+	prov_msg(iattrprov)->iattr_info.uid = __kuid_val(iattr->ia_uid);
+	prov_msg(iattrprov)->iattr_info.gid = __kgid_val(iattr->ia_gid);
+	prov_msg(iattrprov)->iattr_info.size = iattr->ia_size;
+	prov_msg(iattrprov)->iattr_info.atime = iattr->ia_atime.tv_sec;
+	prov_msg(iattrprov)->iattr_info.mtime = iattr->ia_mtime.tv_sec;
+	prov_msg(iattrprov)->iattr_info.ctime = iattr->ia_ctime.tv_sec;
+
+	spin_lock_nested(prov_lock(cprov), PROVENANCE_LOCK_TASK);
+	spin_lock_nested(prov_lock(iprov), PROVENANCE_LOCK_INODE);
+	flow_from_activity(RL_SETATTR, cprov, iattrprov, FLOW_ALLOWED, NULL);
+	flow_between_entities(RL_SETATTR, iattrprov, iprov, FLOW_ALLOWED, NULL);
+	spin_unlock(prov_lock(iprov));
+	spin_unlock(prov_lock(cprov));
+	free_provenance(iattrprov);
+	return 0;
+}
+
+/*
+ * Check permission before obtaining file attributes.
+ * @path contains the path structure for the file.
+ * Return 0 if permission is granted.
+ */
+int provenance_inode_getattr(const struct path *path)
+{
+	struct provenance *cprov = get_current_provenance();
+	struct provenance *iprov = dentry_provenance(path->dentry);
+
+	if (!iprov)
+		return -ENOMEM;
+
+	spin_lock_nested(prov_lock(cprov), PROVENANCE_LOCK_TASK);
+	spin_lock_nested(prov_lock(iprov), PROVENANCE_LOCK_INODE);
+	flow_to_activity(RL_GETATTR, iprov, cprov, FLOW_ALLOWED, NULL);
+	spin_unlock(prov_lock(iprov));
+	spin_unlock(prov_lock(cprov));
+	return 0;
+}
+
+/*
+ * Check the permission to read the symbolic link.
+ * @dentry contains the dentry structure for the file link.
+ * Return 0 if permission is granted.
+ */
+static int provenance_inode_readlink(struct dentry *dentry)
+{
+	struct provenance *cprov = get_current_provenance();
+	struct provenance *iprov = dentry_provenance(dentry);
+
+	if (!iprov)
+		return -ENOMEM;
+
+	spin_lock_nested(prov_lock(cprov), PROVENANCE_LOCK_TASK);
+	spin_lock_nested(prov_lock(iprov), PROVENANCE_LOCK_INODE);
+	flow_to_activity(RL_READLINK, iprov, cprov, FLOW_ALLOWED, NULL);
+	spin_unlock(prov_lock(iprov));
+	spin_unlock(prov_lock(cprov));
+	return 0;
+}
+
+/*
+ * Update inode security field after successful setxattr operation.
+ * @value identified by @name for @dentry.
+ */
+static void provenance_inode_post_setxattr(struct dentry *dentry, const char *name,
+					   const void *value, size_t size, int flags)
+{
+	struct provenance *cprov = get_current_provenance();
+	struct provenance *iprov = dentry_provenance(dentry);
+
+	if (!iprov)
+		return;
+	spin_lock_nested(prov_lock(cprov), PROVENANCE_LOCK_TASK);
+	spin_lock_nested(prov_lock(iprov), PROVENANCE_LOCK_INODE);
+	if (provenance_is_opaque(prov_msg(cprov)) || provenance_is_opaque(prov_msg(iprov)))
+		goto out;
+	if (!provenance_is_tracked(prov_msg(cprov)) && !provenance_is_tracked(prov_msg(iprov)))
+		goto out;
+	record_write_xattr(RL_SETXATTR, prov_msg(iprov), prov_msg(cprov), name, value, size, flags, FLOW_ALLOWED);
+out:
+	spin_unlock(prov_lock(iprov));
+	spin_unlock(prov_lock(cprov));
+}
+
+/*
+ * Check permission before obtaining the extended attributes
+ * identified by @name for @dentry.
+ * Return 0 if permission is granted.
+ */
+static int provenance_inode_getxattr(struct dentry *dentry, const char *name)
+{
+	struct provenance *cprov = get_current_provenance();
+	struct provenance *iprov = dentry_provenance(dentry);
+	int rtn = 0;
+
+	if (!iprov)
+		return -ENOMEM;
+	spin_lock_nested(prov_lock(cprov), PROVENANCE_LOCK_TASK);
+	spin_lock_nested(prov_lock(iprov), PROVENANCE_LOCK_INODE);
+	if (provenance_is_opaque(prov_msg(cprov)) || provenance_is_opaque(prov_msg(iprov)))
+		goto out;
+	if (!provenance_is_tracked(prov_msg(cprov)) && !provenance_is_tracked(prov_msg(iprov)))
+		goto out;
+	record_read_xattr(RL_GETXATTR, prov_msg(cprov), prov_msg(iprov), name, FLOW_ALLOWED);
+out:
+	spin_unlock(prov_lock(iprov));
+	spin_unlock(prov_lock(cprov));
+	return rtn;
+}
+
+/*
+ * Check permission before obtaining the list of extended attribute
+ * names for @dentry.
+ * Return 0 if permission is granted.
+ */
+static int provenance_inode_listxattr(struct dentry *dentry)
+{
+	struct provenance *cprov = get_current_provenance();
+	struct provenance *iprov = dentry_provenance(dentry);
+
+	if (!iprov)
+		return -ENOMEM;
+	spin_lock_nested(prov_lock(cprov), PROVENANCE_LOCK_TASK);
+	spin_lock_nested(prov_lock(iprov), PROVENANCE_LOCK_INODE);
+	flow_to_activity(RL_LSTXATTR, iprov, cprov, FLOW_ALLOWED, NULL);
+	spin_unlock(prov_lock(iprov));
+	spin_unlock(prov_lock(cprov));
+	return 0;
+}
+
+/*
+ * Check permission before removing the extended attribute
+ * identified by @name for @dentry.
+ * Return 0 if permission is granted.
+ */
+static int provenance_inode_removexattr(struct dentry *dentry, const char *name)
+{
+	struct provenance *cprov = get_current_provenance();
+	struct provenance *iprov = dentry_provenance(dentry);
+
+	if (!iprov)
+		return -ENOMEM;
+
+	spin_lock_nested(prov_lock(cprov), PROVENANCE_LOCK_TASK);
+	spin_lock_nested(prov_lock(iprov), PROVENANCE_LOCK_INODE);
+	if (provenance_is_opaque(prov_msg(cprov)) || provenance_is_opaque(prov_msg(iprov)))
+		goto out;
+	if (!provenance_is_tracked(prov_msg(cprov)) && !provenance_is_tracked(prov_msg(iprov)))
+		goto out;
+	record_write_xattr(RL_RMVXATTR, prov_msg(iprov), prov_msg(cprov), name, NULL, 0, 0, FLOW_ALLOWED);
+out:
+	spin_unlock(prov_lock(iprov));
+	spin_unlock(prov_lock(cprov));
+	return 0;
+}
+
+
+/*
+ * Check file permissions before accessing an open file.  This hook is
+ * called by various operations that read or write files.  A security
+ * module can use this hook to perform additional checking on these
+ * operations, e.g.  to revalidate permissions on use to support privilege
+ * bracketing or policy changes.  Notice that this hook is used when the
+ * actual read/write operations are performed, whereas the
+ * inode_security_ops hook is called when a file is opened (as well as
+ * many other operations).
+ * Caveat:  Although this hook can be used to revalidate permissions for
+ * various system call operations that read or write files, it does not
+ * address the revalidation of permissions for memory-mapped files.
+ * Security modules must handle this separately if they need such
+ * revalidation.
+ * @file contains the file structure being accessed.
+ * @mask contains the requested permissions.
+ * Return 0 if permission is granted.
+ */
+static int provenance_file_permission(struct file *file, int mask)
+{
+	struct provenance *cprov = get_current_provenance();
+	struct provenance *iprov = file_provenance(file);
+	struct inode *inode = file_inode(file);
+	uint32_t perms;
+
+	if (iprov == NULL)
+		return -ENOMEM;
+
+	perms = file_mask_to_perms(inode->i_mode, mask);
+	spin_lock_nested(prov_lock(cprov), PROVENANCE_LOCK_TASK);
+	spin_lock_nested(prov_lock(iprov), PROVENANCE_LOCK_INODE);
+	if (is_inode_dir(inode)) {
+		if ((perms & (DIR__WRITE)) != 0)
+			flow_from_activity(RL_WRITE, cprov, iprov, FLOW_ALLOWED, file);
+		if ((perms & (DIR__READ)) != 0)
+			flow_to_activity(RL_READ, iprov, cprov, FLOW_ALLOWED, file);
+		if ((perms & (DIR__SEARCH)) != 0)
+			flow_to_activity(RL_SEARCH, iprov, cprov, FLOW_ALLOWED, file);
+	} else if (is_inode_socket(inode)) {
+		if ((perms & (FILE__WRITE | FILE__APPEND)) != 0)
+			flow_from_activity(RL_SND, cprov, iprov, FLOW_ALLOWED, file);
+		if ((perms & (FILE__READ)) != 0)
+			flow_to_activity(RL_RCV, iprov, cprov, FLOW_ALLOWED, file);
+	} else{
+		if ((perms & (FILE__WRITE | FILE__APPEND)) != 0)
+			flow_from_activity(RL_WRITE, cprov, iprov, FLOW_ALLOWED, file);
+		if ((perms & (FILE__READ)) != 0)
+			flow_to_activity(RL_READ, iprov, cprov, FLOW_ALLOWED, file);
+		if ((perms & (FILE__EXECUTE)) != 0)
+			flow_to_activity(RL_EXEC, iprov, cprov, FLOW_ALLOWED, file);
+	}
+	spin_unlock(prov_lock(iprov));
+	spin_unlock(prov_lock(cprov));
+	return 0;
+}
+
+/*
+ * Save open-time permission checking state for later use upon
+ * file_permission, and recheck access if anything has changed
+ * since inode_permission.
+ */
+static int provenance_file_open(struct file *file, const struct cred *cred)
+{
+	struct provenance *cprov = get_current_provenance();
+	struct provenance *iprov = file_provenance(file);
+
+	if (!iprov)
+		return -ENOMEM;
+	spin_lock_nested(prov_lock(cprov), PROVENANCE_LOCK_TASK);
+	spin_lock_nested(prov_lock(iprov), PROVENANCE_LOCK_INODE);
+	flow_to_activity(RL_OPEN, iprov, cprov, FLOW_ALLOWED, file);
+	spin_unlock(prov_lock(iprov));
+	spin_unlock(prov_lock(cprov));
+	return 0;
+}
+
+/*
+ * Check permissions for a mmap operation.  The @file may be NULL, e.g.
+ * if mapping anonymous memory.
+ * @file contains the file structure for file to map (may be NULL).
+ * @reqprot contains the protection requested by the application.
+ * @prot contains the protection that will be applied by the kernel.
+ * @flags contains the operational flags.
+ * Return 0 if permission is granted.
+ */
+static int provenance_mmap_file(struct file *file, unsigned long reqprot, unsigned long prot, unsigned long flags)
+{
+	struct provenance *cprov = get_current_provenance();
+	struct provenance *iprov = NULL;
+	struct provenance *bprov = NULL;
+
+	if (unlikely(file == NULL))
+		return 0;
+	iprov = file_provenance(file);
+	if ((flags & MAP_TYPE) == MAP_SHARED) {
+		spin_lock_nested(prov_lock(cprov), PROVENANCE_LOCK_TASK);
+		spin_lock_nested(prov_lock(iprov), PROVENANCE_LOCK_INODE);
+		cprov->has_mmap = 1;
+		if ((prot & (PROT_WRITE)) != 0)
+			flow_from_activity(RL_MMAP_WRITE, cprov, iprov, FLOW_ALLOWED, file);
+		if ((prot & (PROT_READ)) != 0)
+			flow_to_activity(RL_MMAP_READ, iprov, cprov, FLOW_ALLOWED, file);
+		if ((prot & (PROT_EXEC)) != 0)
+			flow_to_activity(RL_MMAP_EXEC, iprov, cprov, FLOW_ALLOWED, file);
+		spin_unlock(prov_lock(iprov));
+		spin_unlock(prov_lock(cprov));
+	} else{
+		bprov = branch_mmap(prov_msg(iprov), prov_msg(cprov));
+		if (bprov == NULL)
+			return 0;
+		spin_lock_nested(prov_lock(cprov), PROVENANCE_LOCK_TASK);
+		spin_lock_nested(prov_lock(iprov), PROVENANCE_LOCK_INODE);
+		if ((prot & (PROT_WRITE)) != 0)
+			flow_from_activity(RL_MMAP_WRITE, cprov, bprov, FLOW_ALLOWED, file);
+		if ((prot & (PROT_READ)) != 0)
+			flow_to_activity(RL_MMAP_READ, bprov, cprov, FLOW_ALLOWED, file);
+		if ((prot & (PROT_EXEC)) != 0)
+			flow_to_activity(RL_MMAP_EXEC, bprov, cprov, FLOW_ALLOWED, file);
+		spin_unlock(prov_lock(iprov));
+		spin_unlock(prov_lock(cprov));
+		free_provenance(bprov);
+	}
+	return 0;
+}
+
+/*
+ * @file contains the file structure.
+ * @cmd contains the operation to perform.
+ * @arg contains the operational arguments.
+ * Check permission for an ioctl operation on @file.  Note that @arg
+ * sometimes represents a user space pointer; in other cases, it may be a
+ * simple integer value.  When @arg represents a user space pointer, it
+ * should never be used by the security module.
+ * Return 0 if permission is granted.
+ */
+static int provenance_file_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
+{
+	struct provenance *cprov = get_current_provenance();
+	struct provenance *iprov = file_provenance(file);
+
+	if (!iprov)
+		return -ENOMEM;
+	spin_lock_nested(prov_lock(cprov), PROVENANCE_LOCK_TASK);
+	spin_lock_nested(prov_lock(iprov), PROVENANCE_LOCK_INODE);
+	flow_from_activity(RL_WRITE, cprov, iprov, FLOW_ALLOWED, NULL);
+	flow_to_activity(RL_READ, iprov, cprov, FLOW_ALLOWED, NULL);
+	spin_unlock(prov_lock(iprov));
+	spin_unlock(prov_lock(cprov));
+	return 0;
+}
+
+/* msg */
+
+/*
+ * Allocate and attach a security structure to the msg->security field.
+ * The security field is initialized to NULL when the structure is first
+ * created.
+ * @msg contains the message structure to be modified.
+ * Return 0 if operation was successful and permission is granted.
+ */
+static int provenance_msg_msg_alloc_security(struct msg_msg *msg)
+{
+	struct provenance *cprov = get_current_provenance();
+	struct provenance *mprov;
+
+	/* alloc new prov struct with generated id */
+	mprov = alloc_provenance(ENT_MSG, GFP_KERNEL);
+
+	if (!mprov)
+		return -ENOMEM;
+	prov_msg(mprov)->msg_msg_info.type = msg->m_type;
+	msg->provenance = mprov;
+	spin_lock_nested(prov_lock(cprov), PROVENANCE_LOCK_TASK);
+	flow_from_activity(RL_CREATE, cprov, mprov, FLOW_ALLOWED, NULL);
+	spin_unlock(prov_lock(cprov));
+	return 0;
+}
+
+/*
+ * Deallocate the security structure for this message.
+ * @msg contains the message structure to be modified.
+ */
+static void provenance_msg_msg_free_security(struct msg_msg *msg)
+{
+	free_provenance(msg->provenance);
+	msg->provenance = NULL;
+}
+
+/*
+ * Check permission before a message, @msg, is enqueued on the message
+ * queue, @msq.
+ * @msq contains the message queue to send message to.
+ * @msg contains the message to be enqueued.
+ * @msqflg contains operational flags.
+ * Return 0 if permission is granted.
+ */
+static int provenance_msg_queue_msgsnd(struct msg_queue *msq, struct msg_msg *msg, int msqflg)
+{
+	struct provenance *cprov = get_current_provenance();
+	struct provenance *mprov = msg->provenance;
+
+	spin_lock_nested(prov_lock(cprov), PROVENANCE_LOCK_TASK);
+	spin_lock_nested(prov_lock(mprov), PROVENANCE_LOCK_MSG);
+	flow_from_activity(RL_CREATE, cprov, mprov, FLOW_ALLOWED, NULL);
+	spin_unlock(prov_lock(mprov));
+	spin_unlock(prov_lock(cprov));
+	return 0;
+}
+
+/*
+ * Check permission before a message, @msg, is removed from the message
+ * queue, @msq.  The @target task structure contains a pointer to the
+ * process that will be receiving the message (not equal to the current
+ * process when inline receives are being performed).
+ * @msq contains the message queue to retrieve message from.
+ * @msg contains the message destination.
+ * @target contains the task structure for recipient process.
+ * @type contains the type of message requested.
+ * @mode contains the operational flags.
+ * Return 0 if permission is granted.
+ */
+static int provenance_msg_queue_msgrcv(struct msg_queue *msq, struct msg_msg *msg,
+				       struct task_struct *target,
+				       long type, int mode)
+{
+	struct provenance *cprov = target->cred->provenance;
+	struct provenance *mprov = msg->provenance;
+
+	spin_lock_nested(prov_lock(cprov), PROVENANCE_LOCK_TASK);
+	spin_lock_nested(prov_lock(mprov), PROVENANCE_LOCK_MSG);
+	flow_to_activity(RL_READ, mprov, cprov, FLOW_ALLOWED, NULL);
+	spin_unlock(prov_lock(mprov));
+	spin_unlock(prov_lock(cprov));
+	return 0;
+}
+
+/*
+ * Allocate and attach a security structure to the shp->shm_perm.security
+ * field.  The security field is initialized to NULL when the structure is
+ * first created.
+ * @shp contains the shared memory structure to be modified.
+ * Return 0 if operation was successful and permission is granted.
+ */
+static int provenance_shm_alloc_security(struct shmid_kernel *shp)
+{
+	struct provenance *cprov = get_current_provenance();
+	struct provenance *sprov = alloc_provenance(ENT_SHM, GFP_KERNEL);
+
+	if (!sprov)
+		return -ENOMEM;
+	prov_msg(sprov)->shm_info.mode = shp->shm_perm.mode;
+	shp->shm_perm.provenance = sprov;
+	spin_lock_nested(prov_lock(cprov), PROVENANCE_LOCK_TASK);
+	flow_to_activity(RL_WRITE, sprov, cprov, FLOW_ALLOWED, NULL);
+	flow_from_activity(RL_READ, cprov, sprov, FLOW_ALLOWED, NULL);
+	spin_unlock(prov_lock(cprov));
+	return 0;
+}
+
+/*
+ * Deallocate the security struct for this memory segment.
+ * @shp contains the shared memory structure to be modified.
+ */
+static void provenance_shm_free_security(struct shmid_kernel *shp)
+{
+	free_provenance(shp->shm_perm.provenance);
+	shp->shm_perm.provenance = NULL;
+}
+
+/*
+ * Check permissions prior to allowing the shmat system call to attach the
+ * shared memory segment @shp to the data segment of the calling process.
+ * The attaching address is specified by @shmaddr.
+ * @shp contains the shared memory structure to be modified.
+ * @shmaddr contains the address to attach memory region to.
+ * @shmflg contains the operational flags.
+ * Return 0 if permission is granted.
+ */
+static int provenance_shm_shmat(struct shmid_kernel *shp,
+				char __user *shmaddr, int shmflg)
+{
+	struct provenance *cprov = get_current_provenance();
+	struct provenance *sprov = shp->shm_perm.provenance;
+
+	if (!sprov)
+		return -ENOMEM;
+	spin_lock_nested(prov_lock(cprov), PROVENANCE_LOCK_TASK);
+	spin_lock_nested(prov_lock(sprov), PROVENANCE_LOCK_SHM);
+	if (shmflg & SHM_RDONLY)
+		flow_to_activity(RL_READ, sprov, cprov, FLOW_ALLOWED, NULL);
+	else {
+		flow_to_activity(RL_READ, sprov, cprov, FLOW_ALLOWED, NULL);
+		flow_from_activity(RL_WRITE, cprov, sprov, FLOW_ALLOWED, NULL);
+	}
+	spin_unlock(prov_lock(sprov));
+	spin_unlock(prov_lock(cprov));
+	return 0;
+}
+
+/*
+ * Allocate and attach a security structure to the sk->sk_security field,
+ * which is used to copy security attributes between local stream sockets.
+ */
+static int provenance_sk_alloc_security(struct sock *sk, int family, gfp_t priority)
+{
+	struct provenance *skprov = get_current_provenance();
+
+	if (!skprov)
+		return -ENOMEM;
+	sk->sk_provenance = skprov;
+	return 0;
+}
+
+/*
+ * This hook allows a module to update or allocate a per-socket security
+ * structure. Note that the security field was not added directly to the
+ * socket structure, but rather, the socket security information is stored
+ * in the associated inode.  Typically, the inode alloc_security hook will
+ * allocate and and attach security information to
+ * sock->inode->i_security.  This hook may be used to update the
+ * sock->inode->i_security field with additional information that wasn't
+ * available when the inode was allocated.
+ * @sock contains the newly created socket structure.
+ * @family contains the requested protocol family.
+ * @type contains the requested communications type.
+ * @protocol contains the requested protocol.
+ * @kern set to 1 if a kernel socket.
+ */
+static int provenance_socket_post_create(struct socket *sock, int family,
+					 int type, int protocol, int kern)
+{
+	struct provenance *cprov  = get_current_provenance();
+	struct provenance *iprov = socket_inode_provenance(sock);
+
+	if (kern)
+		return 0;
+	spin_lock_nested(prov_lock(cprov), PROVENANCE_LOCK_TASK);
+	spin_lock_nested(prov_lock(iprov), PROVENANCE_LOCK_INODE);
+	flow_from_activity(RL_CREATE, cprov, iprov, FLOW_ALLOWED, NULL);
+	spin_unlock(prov_lock(iprov));
+	spin_unlock(prov_lock(cprov));
+	return 0;
+}
+
+/*
+ * Check permission before socket protocol layer bind operation is
+ * performed and the socket @sock is bound to the address specified in the
+ * @address parameter.
+ * @sock contains the socket structure.
+ * @address contains the address to bind to.
+ * @addrlen contains the length of address.
+ * Return 0 if permission is granted.
+ */
+static int provenance_socket_bind(struct socket *sock, struct sockaddr *address, int addrlen)
+{
+	struct provenance *cprov  = get_current_provenance();
+	struct provenance *iprov = socket_inode_provenance(sock);
+	struct sockaddr_in *ipv4_addr;
+	uint8_t op;
+
+	if (!iprov)
+		return -ENOMEM;
+
+	if (provenance_is_opaque(prov_msg(cprov)))
+		return 0;
+
+	/* should we start tracking this socket */
+	if (address->sa_family == AF_INET) {
+		ipv4_addr = (struct sockaddr_in *)address;
+		op = prov_ipv4_ingressOP(ipv4_addr->sin_addr.s_addr, ipv4_addr->sin_port);
+		if ((op & PROV_NET_TRACKED) != 0) {
+			set_tracked(prov_msg(iprov));
+			set_tracked(prov_msg(cprov));
+		}
+		if ((op & PROV_NET_PROPAGATE) != 0) {
+			set_propagate(prov_msg(iprov));
+			set_propagate(prov_msg(cprov));
+		}
+		if ((op & PROV_NET_RECORD) != 0)
+			set_record_packet(prov_msg(iprov));
+	}
+	provenance_record_address(address, addrlen, iprov);
+	flow_from_activity(RL_BIND, cprov, iprov, FLOW_ALLOWED, NULL);
+	return 0;
+}
+
+/*
+ * Check permission before socket protocol layer connect operation
+ * attempts to connect socket @sock to a remote address, @address.
+ * @sock contains the socket structure.
+ * @address contains the address of remote endpoint.
+ * @addrlen contains the length of address.
+ * Return 0 if permission is granted.
+ */
+static int provenance_socket_connect(struct socket *sock, struct sockaddr *address, int addrlen)
+{
+	struct provenance *cprov  = get_current_provenance();
+	struct provenance *iprov = socket_inode_provenance(sock);
+	struct sockaddr_in *ipv4_addr;
+	uint8_t op;
+
+	if (!iprov)
+		return -ENOMEM;
+
+	spin_lock_nested(prov_lock(cprov), PROVENANCE_LOCK_TASK);
+	spin_lock_nested(prov_lock(iprov), PROVENANCE_LOCK_INODE);
+	if (provenance_is_opaque(prov_msg(cprov)))
+		goto out;
+
+	/* should we start tracking this socket */
+	if (address->sa_family == AF_INET) {
+		ipv4_addr = (struct sockaddr_in *)address;
+		op = prov_ipv4_egressOP(ipv4_addr->sin_addr.s_addr, ipv4_addr->sin_port);
+		if ((op & PROV_NET_TRACKED) != 0) {
+			set_tracked(prov_msg(iprov));
+			set_tracked(prov_msg(cprov));
+		}
+		if ((op & PROV_NET_PROPAGATE) != 0) {
+			set_propagate(prov_msg(iprov));
+			set_propagate(prov_msg(cprov));
+		}
+		if ((op & PROV_NET_RECORD) != 0)
+			set_record_packet(prov_msg(iprov));
+	}
+	provenance_record_address(address, addrlen, iprov);
+	flow_from_activity(RL_CONNECT, cprov, iprov, FLOW_ALLOWED, NULL);
+out:
+	spin_unlock(prov_lock(iprov));
+	spin_unlock(prov_lock(cprov));
+	return 0;
+}
+
+/*
+ * Check permission before socket protocol layer listen operation.
+ * @sock contains the socket structure.
+ * @backlog contains the maximum length for the pending connection queue.
+ * Return 0 if permission is granted.
+ */
+static int provenance_socket_listen(struct socket *sock, int backlog)
+{
+	struct provenance *cprov  = get_current_provenance();
+	struct provenance *iprov = socket_inode_provenance(sock);
+
+	if (!iprov)
+		return -ENOMEM;
+	spin_lock_nested(prov_lock(cprov), PROVENANCE_LOCK_TASK);
+	spin_lock_nested(prov_lock(iprov), PROVENANCE_LOCK_INODE);
+	flow_from_activity(RL_LISTEN, cprov, iprov, FLOW_ALLOWED, NULL);
+	spin_unlock(prov_lock(iprov));
+	spin_unlock(prov_lock(cprov));
+	return 0;
+}
+
+/*
+ * Check permission before accepting a new connection.  Note that the new
+ * socket, @newsock, has been created and some information copied to it,
+ * but the accept operation has not actually been performed.
+ * @sock contains the listening socket structure.
+ * @newsock contains the newly created server socket for connection.
+ * Return 0 if permission is granted.
+ */
+static int provenance_socket_accept(struct socket *sock, struct socket *newsock)
+{
+	struct provenance *cprov  = get_current_provenance();
+	struct provenance *iprov = socket_inode_provenance(sock);
+	struct provenance *niprov = socket_inode_provenance(newsock);
+
+	spin_lock_nested(prov_lock(cprov), PROVENANCE_LOCK_TASK);
+	spin_lock_nested(prov_lock(iprov), PROVENANCE_LOCK_INODE);
+	flow_between_entities(RL_CREATE, iprov, niprov, FLOW_ALLOWED, NULL);
+	flow_to_activity(RL_ACCEPT, niprov, cprov, FLOW_ALLOWED, NULL);
+	spin_unlock(prov_lock(iprov));
+	spin_unlock(prov_lock(cprov));
+	return 0;
+}
+
+/*
+ * Check permission before transmitting a message to another socket.
+ * @sock contains the socket structure.
+ * @msg contains the message to be transmitted.
+ * @size contains the size of message.
+ * Return 0 if permission is granted.
+ */
+static int provenance_socket_sendmsg(struct socket *sock, struct msghdr *msg,
+				     int size)
+{
+	struct provenance *cprov = get_current_provenance();
+	struct provenance *iprov = socket_inode_provenance(sock);
+
+	if (iprov == NULL)
+		return -ENOMEM;
+	spin_lock_nested(prov_lock(cprov), PROVENANCE_LOCK_TASK);
+	spin_lock_nested(prov_lock(iprov), PROVENANCE_LOCK_INODE);
+	flow_from_activity(RL_SND, cprov, iprov, FLOW_ALLOWED, NULL);
+	spin_unlock(prov_lock(iprov));
+	spin_unlock(prov_lock(cprov));
+	return 0;
+}
+
+/*
+ * Check permission before receiving a message from a socket.
+ * @sock contains the socket structure.
+ * @msg contains the message structure.
+ * @size contains the size of message structure.
+ * @flags contains the operational flags.
+ * Return 0 if permission is granted.
+ */
+static int provenance_socket_recvmsg(struct socket *sock, struct msghdr *msg,
+				     int size, int flags)
+{
+	struct provenance *cprov = get_current_provenance();
+	struct provenance *iprov = socket_inode_provenance(sock);
+
+	if (iprov == NULL)
+		return -ENOMEM;
+	spin_lock_nested(prov_lock(cprov), PROVENANCE_LOCK_TASK);
+	spin_lock_nested(prov_lock(iprov), PROVENANCE_LOCK_INODE);
+	flow_to_activity(RL_RCV, iprov, cprov, FLOW_ALLOWED, NULL);
+	spin_unlock(prov_lock(iprov));
+	spin_unlock(prov_lock(cprov));
+	return 0;
+}
+
+/*
+ * Check permissions on incoming network packets.  This hook is distinct
+ * from Netfilter's IP input hooks since it is the first time that the
+ * incoming sk_buff @skb has been associated with a particular socket, @sk.
+ * Must not sleep inside this hook because some callers hold spinlocks.
+ * @sk contains the sock (not socket) associated with the incoming sk_buff.
+ * @skb contains the incoming network data.
+ */
+static int provenance_socket_sock_rcv_skb(struct sock *sk, struct sk_buff *skb)
+{
+	struct provenance *cprov = sk_provenance(sk);
+	struct provenance *iprov;
+	prov_msg_t pckprov;
+	uint16_t family = sk->sk_family;
+
+	if (cprov == NULL)
+		return 0;
+	if (family != PF_INET)
+		return 0;
+	iprov = sk_inode_provenance(sk);
+	if (iprov == NULL)
+		return 0;
+	if (provenance_is_tracked(prov_msg(iprov))) {
+		provenance_parse_skb_ipv4(skb, &pckprov);
+		record_pck_to_inode(&pckprov, prov_msg(iprov));
+
+		if (provenance_is_tracked(prov_msg(cprov)))
+			flow_to_activity(RL_RCV, iprov, cprov, FLOW_ALLOWED, NULL);
+		if(provenance_records_packet(prov_msg(iprov)))
+			record_packet_content(&pckprov, skb);
+	}
+	return 0;
+}
+
+/*
+ * Check permissions before establishing a Unix domain stream connection
+ * between @sock and @other.
+ * @sock contains the sock structure.
+ * @other contains the peer sock structure.
+ * @newsk contains the new sock structure.
+ * Return 0 if permission is granted.
+ */
+static int provenance_unix_stream_connect(struct sock *sock,
+					  struct sock *other,
+					  struct sock *newsk)
+{
+	/*struct provenance* cprov  = get_current_provenance();
+	   struct provenance* skprov = sk_provenance(sock);
+	   struct provenance* nskprov = sk_provenance(newsk);
+	   struct provenance* okprov = sk_provenance(other);
+
+	      record_relation(RL_CONNECT, cprov, skprov, FLOW_ALLOWED);
+	      record_relation(RL_ASSOCIATE, skprov, nskprov, FLOW_ALLOWED);
+	      record_relation(RL_ASSOCIATE, skprov, okprov, FLOW_ALLOWED);*/
+	return 0;
+}
+
+/*
+ * Check permissions before connecting or sending datagrams from @sock to
+ * @other.
+ * @sock contains the socket structure.
+ * @other contains the peer socket structure.
+ * Return 0 if permission is granted.
+ */
+static int provenance_unix_may_send(struct socket *sock,
+				    struct socket *other)
+{
+	/*struct provenance* skprov = socket_inode_provenance(sock);
+	   struct provenance* okprov = socket_inode_provenance(other);
+
+	      record_relation(RL_UNKNOWN, skprov, okprov, FLOW_ALLOWED);*/
+	return 0;
+}
+
+/* outdated description */
+/*
+ * Save security information in the bprm->security field, typically based
+ * on information about the bprm->file, for later use by the apply_creds
+ * hook.  This hook may also optionally check permissions (e.g. for
+ * transitions between security domains).
+ * This hook may be called multiple times during a single execve, e.g. for
+ * interpreters.  The hook can tell whether it has already been called by
+ * checking to see if @bprm->security is non-NULL.if so, then the hook
+ * may decide either to retain the security information saved earlier or
+ * to replace it.
+ * @bprm contains the linux_binprm structure.
+ * Return 0 if the hook is successful and permission is granted.
+ */
+static int provenance_bprm_set_creds(struct linux_binprm *bprm)
+{
+	struct provenance *nprov = bprm->cred->provenance;
+	struct provenance *iprov = file_provenance(bprm->file);
+
+	if (!nprov)
+		return -ENOMEM;
+
+	if (provenance_is_opaque(prov_msg(iprov))) {
+		set_opaque(prov_msg(nprov));
+		return 0;
+	}
+	spin_lock_nested(prov_lock(iprov), PROVENANCE_LOCK_INODE);
+	flow_to_activity(RL_EXEC, iprov, nprov, FLOW_ALLOWED, NULL);
+	spin_unlock(prov_lock(iprov));
+	return 0;
+}
+
+/*
+ * Prepare to install the new security attributes of a process being
+ * transformed by an execve operation, based on the old credentials
+ * pointed to by @current->cred and the information set in @bprm->cred by
+ * the bprm_set_creds hook.  @bprm points to the linux_binprm structure.
+ * This hook is a good place to perform state changes on the process such
+ * as closing open file descriptors to which access will no longer be
+ * granted when the attributes are changed.  This is called immediately
+ * before commit_creds().
+ */
+static void provenance_bprm_committing_creds(struct linux_binprm *bprm)
+{
+	struct provenance *cprov  = get_current_provenance();
+	struct provenance *nprov = bprm->cred->provenance;
+	struct provenance *iprov = file_provenance(bprm->file);
+
+	if (provenance_is_opaque(prov_msg(iprov))) {
+		set_opaque(prov_msg(nprov));
+		return;
+	}
+	spin_lock_nested(prov_lock(cprov), PROVENANCE_LOCK_TASK);
+	spin_lock_nested(prov_lock(iprov), PROVENANCE_LOCK_INODE);
+	flow_between_activities(RL_EXEC_PROCESS, cprov, nprov, FLOW_ALLOWED, NULL);
+	flow_to_activity(RL_EXEC, iprov, nprov, FLOW_ALLOWED, NULL);
+	spin_unlock(prov_lock(iprov));
+	spin_unlock(prov_lock(cprov));
+}
+
+/*
+ * Allocate and attach a security structure to the sb->s_security field.
+ * The s_security field is initialized to NULL when the structure is
+ * allocated.
+ * @sb contains the super_block structure to be modified.
+ * Return 0 if operation was successful.
+ */
+static int provenance_sb_alloc_security(struct super_block *sb)
+{
+	struct provenance *sbprov  = alloc_provenance(ENT_SBLCK, GFP_KERNEL);
+
+	if (!sbprov)
+		return -ENOMEM;
+	sb->s_provenance = sbprov;
+	return 0;
+}
+
+/*
+ * Deallocate and clear the sb->s_security field.
+ * @sb contains the super_block structure to be modified.
+ */
+static void provenance_sb_free_security(struct super_block *sb)
+{
+	free_provenance(sb->s_provenance);
+	sb->s_provenance = NULL;
+}
+
+static int provenance_sb_kern_mount(struct super_block *sb, int flags, void *data)
+{
+	int i;
+	uint8_t c = 0;
+	struct provenance *sbprov = sb->s_provenance;
+
+	for (i = 0; i < 16; i++) {
+		prov_msg(sbprov)->sb_info.uuid[i] = sb->s_uuid[i];
+		c |= sb->s_uuid[i];
+	}
+	if (c == 0) // no uuid defined, generate random one
+		get_random_bytes(prov_msg(sbprov)->sb_info.uuid, 16 * sizeof(uint8_t));
+	return 0;
+}
+
+static struct security_hook_list provenance_hooks[] = {
+	/* task related hooks */
+	LSM_HOOK_INIT(cred_alloc_blank,	      provenance_cred_alloc_blank),
+	LSM_HOOK_INIT(cred_free,	      provenance_cred_free),
+	LSM_HOOK_INIT(cred_prepare,	      provenance_cred_prepare),
+	LSM_HOOK_INIT(cred_transfer,	      provenance_cred_transfer),
+	LSM_HOOK_INIT(task_fix_setuid,	      provenance_task_fix_setuid),
+
+	/* inode related hooks */
+	LSM_HOOK_INIT(inode_alloc_security,   provenance_inode_alloc_security),
+	LSM_HOOK_INIT(inode_create,	      provenance_inode_create),
+	LSM_HOOK_INIT(inode_free_security,    provenance_inode_free_security),
+	LSM_HOOK_INIT(inode_permission,	      provenance_inode_permission),
+	LSM_HOOK_INIT(inode_link,	      provenance_inode_link),
+	LSM_HOOK_INIT(inode_rename,	      provenance_inode_rename),
+	LSM_HOOK_INIT(inode_setattr,	      provenance_inode_setattr),
+	LSM_HOOK_INIT(inode_getattr,	      provenance_inode_getattr),
+	LSM_HOOK_INIT(inode_readlink,	      provenance_inode_readlink),
+	LSM_HOOK_INIT(inode_post_setxattr,    provenance_inode_post_setxattr),
+	LSM_HOOK_INIT(inode_getxattr,	      provenance_inode_getxattr),
+	LSM_HOOK_INIT(inode_listxattr,	      provenance_inode_listxattr),
+	LSM_HOOK_INIT(inode_removexattr,      provenance_inode_removexattr),
+
+	/* file related hooks */
+	LSM_HOOK_INIT(file_permission,	      provenance_file_permission),
+	LSM_HOOK_INIT(mmap_file,	      provenance_mmap_file),
+	LSM_HOOK_INIT(file_ioctl,	      provenance_file_ioctl),
+	LSM_HOOK_INIT(file_open,	      provenance_file_open),
+
+	/* msg related hooks */
+	LSM_HOOK_INIT(msg_msg_alloc_security, provenance_msg_msg_alloc_security),
+	LSM_HOOK_INIT(msg_msg_free_security,  provenance_msg_msg_free_security),
+	LSM_HOOK_INIT(msg_queue_msgsnd,	      provenance_msg_queue_msgsnd),
+	LSM_HOOK_INIT(msg_queue_msgrcv,	      provenance_msg_queue_msgrcv),
+
+	/* shared memory related hooks */
+	LSM_HOOK_INIT(shm_alloc_security,     provenance_shm_alloc_security),
+	LSM_HOOK_INIT(shm_free_security,      provenance_shm_free_security),
+	LSM_HOOK_INIT(shm_shmat,	      provenance_shm_shmat),
+
+	/* socket related hooks */
+	LSM_HOOK_INIT(sk_alloc_security,      provenance_sk_alloc_security),
+	LSM_HOOK_INIT(socket_post_create,     provenance_socket_post_create),
+	LSM_HOOK_INIT(socket_bind,	      provenance_socket_bind),
+	LSM_HOOK_INIT(socket_connect,	      provenance_socket_connect),
+	LSM_HOOK_INIT(socket_listen,	      provenance_socket_listen),
+	LSM_HOOK_INIT(socket_accept,	      provenance_socket_accept),
+	LSM_HOOK_INIT(socket_sendmsg,	      provenance_socket_sendmsg),
+	LSM_HOOK_INIT(socket_recvmsg,	      provenance_socket_recvmsg),
+	LSM_HOOK_INIT(socket_sock_rcv_skb,    provenance_socket_sock_rcv_skb),
+	LSM_HOOK_INIT(unix_stream_connect,    provenance_unix_stream_connect),
+	LSM_HOOK_INIT(unix_may_send,	      provenance_unix_may_send),
+
+	/* exec related hooks */
+	LSM_HOOK_INIT(bprm_set_creds,	      provenance_bprm_set_creds),
+	LSM_HOOK_INIT(bprm_committing_creds,  provenance_bprm_committing_creds),
+
+	/* file system related hooks */
+	LSM_HOOK_INIT(sb_alloc_security,      provenance_sb_alloc_security),
+	LSM_HOOK_INIT(sb_free_security,	      provenance_sb_free_security),
+	LSM_HOOK_INIT(sb_kern_mount,	      provenance_sb_kern_mount)
+};
+
+struct kmem_cache *provenance_cache;
+
+uint32_t prov_machine_id;
+uint32_t prov_boot_id;
+
+struct prov_boot_buffer         *boot_buffer;
+struct prov_long_boot_buffer    *long_boot_buffer;
+
+struct ipv4_filters ingress_ipv4filters;
+struct ipv4_filters egress_ipv4filters;
+struct secctx_filters secctx_filters;
+struct cgroup_filters cgroup_filters;
+bool prov_enabled;
+bool prov_all;
+
+void __init provenance_add_hooks(void)
+{
+	INIT_LIST_HEAD(&ingress_ipv4filters.list);
+	INIT_LIST_HEAD(&egress_ipv4filters.list);
+	INIT_LIST_HEAD(&secctx_filters.list);
+	INIT_LIST_HEAD(&cgroup_filters.list);
+	prov_enabled = true;
+#ifdef CONFIG_SECURITY_PROVENANCE_WHOLE_SYSTEM
+	prov_all = true;
+#else
+	prov_all = false;
+#endif
+	prov_machine_id = 1;
+	get_random_bytes(&prov_boot_id, sizeof(uint32_t)); // proper counter instead of random id?
+	provenance_cache = kmem_cache_create("provenance_struct",
+					     sizeof(struct provenance),
+					     0, SLAB_PANIC, NULL);
+	/* init relay buffers, to deal with provenance before FS is ready */
+	boot_buffer = kzalloc(sizeof(struct prov_boot_buffer), GFP_KERNEL);
+	if (unlikely(boot_buffer == NULL))
+		panic("Provenance: could not allocate boot_buffer.");
+	long_boot_buffer = kzalloc(sizeof(struct prov_long_boot_buffer), GFP_KERNEL);
+	if (unlikely(long_boot_buffer == NULL))
+		panic("Provenance: could not allocate long_boot_buffer.");
+
+	relay_ready=false;
+	cred_init_provenance();
+	/* register the provenance security hooks */
+	security_add_hooks(provenance_hooks, ARRAY_SIZE(provenance_hooks));
+	printk(KERN_INFO "Provenance Camflow %s\n", CAMFLOW_VERSION_STR);
+	printk(KERN_INFO "Provenance hooks ready.\n");
+}
diff -uprN -b -B ./pristine/linux-4.9.5/security/provenance/include/av_utils.h ./linux-4.9.5/security/provenance/include/av_utils.h
--- ./pristine/linux-4.9.5/security/provenance/include/av_utils.h	1970-01-01 01:00:00.000000000 +0100
+++ ./linux-4.9.5/security/provenance/include/av_utils.h	2017-01-23 19:44:14.819585136 +0100
@@ -0,0 +1,1068 @@
+/*
+ *
+ * Author: Thomas Pasquier <tfjmp@seas.harvard.edu>
+ *
+ * Copyright (C) 2016 Harvard University
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2, as
+ * published by the Free Software Foundation.
+ *
+ */
+
+#ifndef _AV_UTILS_PROVENANCE_H
+#define _AV_UTILS_PROVENANCE_H
+
+// that is nasty, need to replace at some point
+#define COMMON_FILE__IOCTL                               0x00000001UL
+#define COMMON_FILE__READ                                0x00000002UL
+#define COMMON_FILE__WRITE                               0x00000004UL
+#define COMMON_FILE__CREATE                              0x00000008UL
+#define COMMON_FILE__GETATTR                             0x00000010UL
+#define COMMON_FILE__SETATTR                             0x00000020UL
+#define COMMON_FILE__LOCK                                0x00000040UL
+#define COMMON_FILE__RELABELFROM                         0x00000080UL
+#define COMMON_FILE__RELABELTO                           0x00000100UL
+#define COMMON_FILE__APPEND                              0x00000200UL
+#define COMMON_FILE__UNLINK                              0x00000400UL
+#define COMMON_FILE__LINK                                0x00000800UL
+#define COMMON_FILE__RENAME                              0x00001000UL
+#define COMMON_FILE__EXECUTE                             0x00002000UL
+#define COMMON_FILE__SWAPON                              0x00004000UL
+#define COMMON_FILE__QUOTAON                             0x00008000UL
+#define COMMON_FILE__MOUNTON                             0x00010000UL
+#define COMMON_SOCKET__IOCTL                             0x00000001UL
+#define COMMON_SOCKET__READ                              0x00000002UL
+#define COMMON_SOCKET__WRITE                             0x00000004UL
+#define COMMON_SOCKET__CREATE                            0x00000008UL
+#define COMMON_SOCKET__GETATTR                           0x00000010UL
+#define COMMON_SOCKET__SETATTR                           0x00000020UL
+#define COMMON_SOCKET__LOCK                              0x00000040UL
+#define COMMON_SOCKET__RELABELFROM                       0x00000080UL
+#define COMMON_SOCKET__RELABELTO                         0x00000100UL
+#define COMMON_SOCKET__APPEND                            0x00000200UL
+#define COMMON_SOCKET__BIND                              0x00000400UL
+#define COMMON_SOCKET__CONNECT                           0x00000800UL
+#define COMMON_SOCKET__LISTEN                            0x00001000UL
+#define COMMON_SOCKET__ACCEPT                            0x00002000UL
+#define COMMON_SOCKET__GETOPT                            0x00004000UL
+#define COMMON_SOCKET__SETOPT                            0x00008000UL
+#define COMMON_SOCKET__SHUTDOWN                          0x00010000UL
+#define COMMON_SOCKET__RECVFROM                          0x00020000UL
+#define COMMON_SOCKET__SENDTO                            0x00040000UL
+#define COMMON_SOCKET__RECV_MSG                          0x00080000UL
+#define COMMON_SOCKET__SEND_MSG                          0x00100000UL
+#define COMMON_SOCKET__NAME_BIND                         0x00200000UL
+#define COMMON_IPC__CREATE                               0x00000001UL
+#define COMMON_IPC__DESTROY                              0x00000002UL
+#define COMMON_IPC__GETATTR                              0x00000004UL
+#define COMMON_IPC__SETATTR                              0x00000008UL
+#define COMMON_IPC__READ                                 0x00000010UL
+#define COMMON_IPC__WRITE                                0x00000020UL
+#define COMMON_IPC__ASSOCIATE                            0x00000040UL
+#define COMMON_IPC__UNIX_READ                            0x00000080UL
+#define COMMON_IPC__UNIX_WRITE                           0x00000100UL
+#define COMMON_DATABASE__CREATE                          0x00000001UL
+#define COMMON_DATABASE__DROP                            0x00000002UL
+#define COMMON_DATABASE__GETATTR                         0x00000004UL
+#define COMMON_DATABASE__SETATTR                         0x00000008UL
+#define COMMON_DATABASE__RELABELFROM                     0x00000010UL
+#define COMMON_DATABASE__RELABELTO                       0x00000020UL
+#define FILESYSTEM__MOUNT                         0x00000001UL
+#define FILESYSTEM__REMOUNT                       0x00000002UL
+#define FILESYSTEM__UNMOUNT                       0x00000004UL
+#define FILESYSTEM__GETATTR                       0x00000008UL
+#define FILESYSTEM__RELABELFROM                   0x00000010UL
+#define FILESYSTEM__RELABELTO                     0x00000020UL
+#define FILESYSTEM__TRANSITION                    0x00000040UL
+#define FILESYSTEM__ASSOCIATE                     0x00000080UL
+#define FILESYSTEM__QUOTAMOD                      0x00000100UL
+#define FILESYSTEM__QUOTAGET                      0x00000200UL
+#define DIR__IOCTL                                0x00000001UL
+#define DIR__READ                                 0x00000002UL
+#define DIR__WRITE                                0x00000004UL
+#define DIR__CREATE                               0x00000008UL
+#define DIR__GETATTR                              0x00000010UL
+#define DIR__SETATTR                              0x00000020UL
+#define DIR__LOCK                                 0x00000040UL
+#define DIR__RELABELFROM                          0x00000080UL
+#define DIR__RELABELTO                            0x00000100UL
+#define DIR__APPEND                               0x00000200UL
+#define DIR__UNLINK                               0x00000400UL
+#define DIR__LINK                                 0x00000800UL
+#define DIR__RENAME                               0x00001000UL
+#define DIR__EXECUTE                              0x00002000UL
+#define DIR__SWAPON                               0x00004000UL
+#define DIR__QUOTAON                              0x00008000UL
+#define DIR__MOUNTON                              0x00010000UL
+#define DIR__ADD_NAME                             0x00020000UL
+#define DIR__REMOVE_NAME                          0x00040000UL
+#define DIR__REPARENT                             0x00080000UL
+#define DIR__SEARCH                               0x00100000UL
+#define DIR__RMDIR                                0x00200000UL
+#define DIR__OPEN                                 0x00400000UL
+#define FILE__IOCTL                               0x00000001UL
+#define FILE__READ                                0x00000002UL
+#define FILE__WRITE                               0x00000004UL
+#define FILE__CREATE                              0x00000008UL
+#define FILE__GETATTR                             0x00000010UL
+#define FILE__SETATTR                             0x00000020UL
+#define FILE__LOCK                                0x00000040UL
+#define FILE__RELABELFROM                         0x00000080UL
+#define FILE__RELABELTO                           0x00000100UL
+#define FILE__APPEND                              0x00000200UL
+#define FILE__UNLINK                              0x00000400UL
+#define FILE__LINK                                0x00000800UL
+#define FILE__RENAME                              0x00001000UL
+#define FILE__EXECUTE                             0x00002000UL
+#define FILE__SWAPON                              0x00004000UL
+#define FILE__QUOTAON                             0x00008000UL
+#define FILE__MOUNTON                             0x00010000UL
+#define FILE__EXECUTE_NO_TRANS                    0x00020000UL
+#define FILE__ENTRYPOINT                          0x00040000UL
+#define FILE__EXECMOD                             0x00080000UL
+#define FILE__OPEN                                0x00100000UL
+#define LNK_FILE__IOCTL                           0x00000001UL
+#define LNK_FILE__READ                            0x00000002UL
+#define LNK_FILE__WRITE                           0x00000004UL
+#define LNK_FILE__CREATE                          0x00000008UL
+#define LNK_FILE__GETATTR                         0x00000010UL
+#define LNK_FILE__SETATTR                         0x00000020UL
+#define LNK_FILE__LOCK                            0x00000040UL
+#define LNK_FILE__RELABELFROM                     0x00000080UL
+#define LNK_FILE__RELABELTO                       0x00000100UL
+#define LNK_FILE__APPEND                          0x00000200UL
+#define LNK_FILE__UNLINK                          0x00000400UL
+#define LNK_FILE__LINK                            0x00000800UL
+#define LNK_FILE__RENAME                          0x00001000UL
+#define LNK_FILE__EXECUTE                         0x00002000UL
+#define LNK_FILE__SWAPON                          0x00004000UL
+#define LNK_FILE__QUOTAON                         0x00008000UL
+#define LNK_FILE__MOUNTON                         0x00010000UL
+#define CHR_FILE__IOCTL                           0x00000001UL
+#define CHR_FILE__READ                            0x00000002UL
+#define CHR_FILE__WRITE                           0x00000004UL
+#define CHR_FILE__CREATE                          0x00000008UL
+#define CHR_FILE__GETATTR                         0x00000010UL
+#define CHR_FILE__SETATTR                         0x00000020UL
+#define CHR_FILE__LOCK                            0x00000040UL
+#define CHR_FILE__RELABELFROM                     0x00000080UL
+#define CHR_FILE__RELABELTO                       0x00000100UL
+#define CHR_FILE__APPEND                          0x00000200UL
+#define CHR_FILE__UNLINK                          0x00000400UL
+#define CHR_FILE__LINK                            0x00000800UL
+#define CHR_FILE__RENAME                          0x00001000UL
+#define CHR_FILE__EXECUTE                         0x00002000UL
+#define CHR_FILE__SWAPON                          0x00004000UL
+#define CHR_FILE__QUOTAON                         0x00008000UL
+#define CHR_FILE__MOUNTON                         0x00010000UL
+#define CHR_FILE__EXECUTE_NO_TRANS                0x00020000UL
+#define CHR_FILE__ENTRYPOINT                      0x00040000UL
+#define CHR_FILE__EXECMOD                         0x00080000UL
+#define CHR_FILE__OPEN                            0x00100000UL
+#define BLK_FILE__IOCTL                           0x00000001UL
+#define BLK_FILE__READ                            0x00000002UL
+#define BLK_FILE__WRITE                           0x00000004UL
+#define BLK_FILE__CREATE                          0x00000008UL
+#define BLK_FILE__GETATTR                         0x00000010UL
+#define BLK_FILE__SETATTR                         0x00000020UL
+#define BLK_FILE__LOCK                            0x00000040UL
+#define BLK_FILE__RELABELFROM                     0x00000080UL
+#define BLK_FILE__RELABELTO                       0x00000100UL
+#define BLK_FILE__APPEND                          0x00000200UL
+#define BLK_FILE__UNLINK                          0x00000400UL
+#define BLK_FILE__LINK                            0x00000800UL
+#define BLK_FILE__RENAME                          0x00001000UL
+#define BLK_FILE__EXECUTE                         0x00002000UL
+#define BLK_FILE__SWAPON                          0x00004000UL
+#define BLK_FILE__QUOTAON                         0x00008000UL
+#define BLK_FILE__MOUNTON                         0x00010000UL
+#define BLK_FILE__OPEN                            0x00020000UL
+#define SOCK_FILE__IOCTL                          0x00000001UL
+#define SOCK_FILE__READ                           0x00000002UL
+#define SOCK_FILE__WRITE                          0x00000004UL
+#define SOCK_FILE__CREATE                         0x00000008UL
+#define SOCK_FILE__GETATTR                        0x00000010UL
+#define SOCK_FILE__SETATTR                        0x00000020UL
+#define SOCK_FILE__LOCK                           0x00000040UL
+#define SOCK_FILE__RELABELFROM                    0x00000080UL
+#define SOCK_FILE__RELABELTO                      0x00000100UL
+#define SOCK_FILE__APPEND                         0x00000200UL
+#define SOCK_FILE__UNLINK                         0x00000400UL
+#define SOCK_FILE__LINK                           0x00000800UL
+#define SOCK_FILE__RENAME                         0x00001000UL
+#define SOCK_FILE__EXECUTE                        0x00002000UL
+#define SOCK_FILE__SWAPON                         0x00004000UL
+#define SOCK_FILE__QUOTAON                        0x00008000UL
+#define SOCK_FILE__MOUNTON                        0x00010000UL
+#define FIFO_FILE__IOCTL                          0x00000001UL
+#define FIFO_FILE__READ                           0x00000002UL
+#define FIFO_FILE__WRITE                          0x00000004UL
+#define FIFO_FILE__CREATE                         0x00000008UL
+#define FIFO_FILE__GETATTR                        0x00000010UL
+#define FIFO_FILE__SETATTR                        0x00000020UL
+#define FIFO_FILE__LOCK                           0x00000040UL
+#define FIFO_FILE__RELABELFROM                    0x00000080UL
+#define FIFO_FILE__RELABELTO                      0x00000100UL
+#define FIFO_FILE__APPEND                         0x00000200UL
+#define FIFO_FILE__UNLINK                         0x00000400UL
+#define FIFO_FILE__LINK                           0x00000800UL
+#define FIFO_FILE__RENAME                         0x00001000UL
+#define FIFO_FILE__EXECUTE                        0x00002000UL
+#define FIFO_FILE__SWAPON                         0x00004000UL
+#define FIFO_FILE__QUOTAON                        0x00008000UL
+#define FIFO_FILE__MOUNTON                        0x00010000UL
+#define FIFO_FILE__OPEN                           0x00020000UL
+#define FD__USE                                   0x00000001UL
+#define SOCKET__IOCTL                             0x00000001UL
+#define SOCKET__READ                              0x00000002UL
+#define SOCKET__WRITE                             0x00000004UL
+#define SOCKET__CREATE                            0x00000008UL
+#define SOCKET__GETATTR                           0x00000010UL
+#define SOCKET__SETATTR                           0x00000020UL
+#define SOCKET__LOCK                              0x00000040UL
+#define SOCKET__RELABELFROM                       0x00000080UL
+#define SOCKET__RELABELTO                         0x00000100UL
+#define SOCKET__APPEND                            0x00000200UL
+#define SOCKET__BIND                              0x00000400UL
+#define SOCKET__CONNECT                           0x00000800UL
+#define SOCKET__LISTEN                            0x00001000UL
+#define SOCKET__ACCEPT                            0x00002000UL
+#define SOCKET__GETOPT                            0x00004000UL
+#define SOCKET__SETOPT                            0x00008000UL
+#define SOCKET__SHUTDOWN                          0x00010000UL
+#define SOCKET__RECVFROM                          0x00020000UL
+#define SOCKET__SENDTO                            0x00040000UL
+#define SOCKET__RECV_MSG                          0x00080000UL
+#define SOCKET__SEND_MSG                          0x00100000UL
+#define SOCKET__NAME_BIND                         0x00200000UL
+#define TCP_SOCKET__IOCTL                         0x00000001UL
+#define TCP_SOCKET__READ                          0x00000002UL
+#define TCP_SOCKET__WRITE                         0x00000004UL
+#define TCP_SOCKET__CREATE                        0x00000008UL
+#define TCP_SOCKET__GETATTR                       0x00000010UL
+#define TCP_SOCKET__SETATTR                       0x00000020UL
+#define TCP_SOCKET__LOCK                          0x00000040UL
+#define TCP_SOCKET__RELABELFROM                   0x00000080UL
+#define TCP_SOCKET__RELABELTO                     0x00000100UL
+#define TCP_SOCKET__APPEND                        0x00000200UL
+#define TCP_SOCKET__BIND                          0x00000400UL
+#define TCP_SOCKET__CONNECT                       0x00000800UL
+#define TCP_SOCKET__LISTEN                        0x00001000UL
+#define TCP_SOCKET__ACCEPT                        0x00002000UL
+#define TCP_SOCKET__GETOPT                        0x00004000UL
+#define TCP_SOCKET__SETOPT                        0x00008000UL
+#define TCP_SOCKET__SHUTDOWN                      0x00010000UL
+#define TCP_SOCKET__RECVFROM                      0x00020000UL
+#define TCP_SOCKET__SENDTO                        0x00040000UL
+#define TCP_SOCKET__RECV_MSG                      0x00080000UL
+#define TCP_SOCKET__SEND_MSG                      0x00100000UL
+#define TCP_SOCKET__NAME_BIND                     0x00200000UL
+#define TCP_SOCKET__CONNECTTO                     0x00400000UL
+#define TCP_SOCKET__NEWCONN                       0x00800000UL
+#define TCP_SOCKET__ACCEPTFROM                    0x01000000UL
+#define TCP_SOCKET__NODE_BIND                     0x02000000UL
+#define TCP_SOCKET__NAME_CONNECT                  0x04000000UL
+#define UDP_SOCKET__IOCTL                         0x00000001UL
+#define UDP_SOCKET__READ                          0x00000002UL
+#define UDP_SOCKET__WRITE                         0x00000004UL
+#define UDP_SOCKET__CREATE                        0x00000008UL
+#define UDP_SOCKET__GETATTR                       0x00000010UL
+#define UDP_SOCKET__SETATTR                       0x00000020UL
+#define UDP_SOCKET__LOCK                          0x00000040UL
+#define UDP_SOCKET__RELABELFROM                   0x00000080UL
+#define UDP_SOCKET__RELABELTO                     0x00000100UL
+#define UDP_SOCKET__APPEND                        0x00000200UL
+#define UDP_SOCKET__BIND                          0x00000400UL
+#define UDP_SOCKET__CONNECT                       0x00000800UL
+#define UDP_SOCKET__LISTEN                        0x00001000UL
+#define UDP_SOCKET__ACCEPT                        0x00002000UL
+#define UDP_SOCKET__GETOPT                        0x00004000UL
+#define UDP_SOCKET__SETOPT                        0x00008000UL
+#define UDP_SOCKET__SHUTDOWN                      0x00010000UL
+#define UDP_SOCKET__RECVFROM                      0x00020000UL
+#define UDP_SOCKET__SENDTO                        0x00040000UL
+#define UDP_SOCKET__RECV_MSG                      0x00080000UL
+#define UDP_SOCKET__SEND_MSG                      0x00100000UL
+#define UDP_SOCKET__NAME_BIND                     0x00200000UL
+#define UDP_SOCKET__NODE_BIND                     0x00400000UL
+#define RAWIP_SOCKET__IOCTL                       0x00000001UL
+#define RAWIP_SOCKET__READ                        0x00000002UL
+#define RAWIP_SOCKET__WRITE                       0x00000004UL
+#define RAWIP_SOCKET__CREATE                      0x00000008UL
+#define RAWIP_SOCKET__GETATTR                     0x00000010UL
+#define RAWIP_SOCKET__SETATTR                     0x00000020UL
+#define RAWIP_SOCKET__LOCK                        0x00000040UL
+#define RAWIP_SOCKET__RELABELFROM                 0x00000080UL
+#define RAWIP_SOCKET__RELABELTO                   0x00000100UL
+#define RAWIP_SOCKET__APPEND                      0x00000200UL
+#define RAWIP_SOCKET__BIND                        0x00000400UL
+#define RAWIP_SOCKET__CONNECT                     0x00000800UL
+#define RAWIP_SOCKET__LISTEN                      0x00001000UL
+#define RAWIP_SOCKET__ACCEPT                      0x00002000UL
+#define RAWIP_SOCKET__GETOPT                      0x00004000UL
+#define RAWIP_SOCKET__SETOPT                      0x00008000UL
+#define RAWIP_SOCKET__SHUTDOWN                    0x00010000UL
+#define RAWIP_SOCKET__RECVFROM                    0x00020000UL
+#define RAWIP_SOCKET__SENDTO                      0x00040000UL
+#define RAWIP_SOCKET__RECV_MSG                    0x00080000UL
+#define RAWIP_SOCKET__SEND_MSG                    0x00100000UL
+#define RAWIP_SOCKET__NAME_BIND                   0x00200000UL
+#define RAWIP_SOCKET__NODE_BIND                   0x00400000UL
+#define NODE__TCP_RECV                            0x00000001UL
+#define NODE__TCP_SEND                            0x00000002UL
+#define NODE__UDP_RECV                            0x00000004UL
+#define NODE__UDP_SEND                            0x00000008UL
+#define NODE__RAWIP_RECV                          0x00000010UL
+#define NODE__RAWIP_SEND                          0x00000020UL
+#define NODE__ENFORCE_DEST                        0x00000040UL
+#define NODE__DCCP_RECV                           0x00000080UL
+#define NODE__DCCP_SEND                           0x00000100UL
+#define NODE__RECVFROM                            0x00000200UL
+#define NODE__SENDTO                              0x00000400UL
+#define NETIF__TCP_RECV                           0x00000001UL
+#define NETIF__TCP_SEND                           0x00000002UL
+#define NETIF__UDP_RECV                           0x00000004UL
+#define NETIF__UDP_SEND                           0x00000008UL
+#define NETIF__RAWIP_RECV                         0x00000010UL
+#define NETIF__RAWIP_SEND                         0x00000020UL
+#define NETIF__DCCP_RECV                          0x00000040UL
+#define NETIF__DCCP_SEND                          0x00000080UL
+#define NETIF__INGRESS                            0x00000100UL
+#define NETIF__EGRESS                             0x00000200UL
+#define NETLINK_SOCKET__IOCTL                     0x00000001UL
+#define NETLINK_SOCKET__READ                      0x00000002UL
+#define NETLINK_SOCKET__WRITE                     0x00000004UL
+#define NETLINK_SOCKET__CREATE                    0x00000008UL
+#define NETLINK_SOCKET__GETATTR                   0x00000010UL
+#define NETLINK_SOCKET__SETATTR                   0x00000020UL
+#define NETLINK_SOCKET__LOCK                      0x00000040UL
+#define NETLINK_SOCKET__RELABELFROM               0x00000080UL
+#define NETLINK_SOCKET__RELABELTO                 0x00000100UL
+#define NETLINK_SOCKET__APPEND                    0x00000200UL
+#define NETLINK_SOCKET__BIND                      0x00000400UL
+#define NETLINK_SOCKET__CONNECT                   0x00000800UL
+#define NETLINK_SOCKET__LISTEN                    0x00001000UL
+#define NETLINK_SOCKET__ACCEPT                    0x00002000UL
+#define NETLINK_SOCKET__GETOPT                    0x00004000UL
+#define NETLINK_SOCKET__SETOPT                    0x00008000UL
+#define NETLINK_SOCKET__SHUTDOWN                  0x00010000UL
+#define NETLINK_SOCKET__RECVFROM                  0x00020000UL
+#define NETLINK_SOCKET__SENDTO                    0x00040000UL
+#define NETLINK_SOCKET__RECV_MSG                  0x00080000UL
+#define NETLINK_SOCKET__SEND_MSG                  0x00100000UL
+#define NETLINK_SOCKET__NAME_BIND                 0x00200000UL
+#define PACKET_SOCKET__IOCTL                      0x00000001UL
+#define PACKET_SOCKET__READ                       0x00000002UL
+#define PACKET_SOCKET__WRITE                      0x00000004UL
+#define PACKET_SOCKET__CREATE                     0x00000008UL
+#define PACKET_SOCKET__GETATTR                    0x00000010UL
+#define PACKET_SOCKET__SETATTR                    0x00000020UL
+#define PACKET_SOCKET__LOCK                       0x00000040UL
+#define PACKET_SOCKET__RELABELFROM                0x00000080UL
+#define PACKET_SOCKET__RELABELTO                  0x00000100UL
+#define PACKET_SOCKET__APPEND                     0x00000200UL
+#define PACKET_SOCKET__BIND                       0x00000400UL
+#define PACKET_SOCKET__CONNECT                    0x00000800UL
+#define PACKET_SOCKET__LISTEN                     0x00001000UL
+#define PACKET_SOCKET__ACCEPT                     0x00002000UL
+#define PACKET_SOCKET__GETOPT                     0x00004000UL
+#define PACKET_SOCKET__SETOPT                     0x00008000UL
+#define PACKET_SOCKET__SHUTDOWN                   0x00010000UL
+#define PACKET_SOCKET__RECVFROM                   0x00020000UL
+#define PACKET_SOCKET__SENDTO                     0x00040000UL
+#define PACKET_SOCKET__RECV_MSG                   0x00080000UL
+#define PACKET_SOCKET__SEND_MSG                   0x00100000UL
+#define PACKET_SOCKET__NAME_BIND                  0x00200000UL
+#define KEY_SOCKET__IOCTL                         0x00000001UL
+#define KEY_SOCKET__READ                          0x00000002UL
+#define KEY_SOCKET__WRITE                         0x00000004UL
+#define KEY_SOCKET__CREATE                        0x00000008UL
+#define KEY_SOCKET__GETATTR                       0x00000010UL
+#define KEY_SOCKET__SETATTR                       0x00000020UL
+#define KEY_SOCKET__LOCK                          0x00000040UL
+#define KEY_SOCKET__RELABELFROM                   0x00000080UL
+#define KEY_SOCKET__RELABELTO                     0x00000100UL
+#define KEY_SOCKET__APPEND                        0x00000200UL
+#define KEY_SOCKET__BIND                          0x00000400UL
+#define KEY_SOCKET__CONNECT                       0x00000800UL
+#define KEY_SOCKET__LISTEN                        0x00001000UL
+#define KEY_SOCKET__ACCEPT                        0x00002000UL
+#define KEY_SOCKET__GETOPT                        0x00004000UL
+#define KEY_SOCKET__SETOPT                        0x00008000UL
+#define KEY_SOCKET__SHUTDOWN                      0x00010000UL
+#define KEY_SOCKET__RECVFROM                      0x00020000UL
+#define KEY_SOCKET__SENDTO                        0x00040000UL
+#define KEY_SOCKET__RECV_MSG                      0x00080000UL
+#define KEY_SOCKET__SEND_MSG                      0x00100000UL
+#define KEY_SOCKET__NAME_BIND                     0x00200000UL
+#define UNIX_STREAM_SOCKET__IOCTL                 0x00000001UL
+#define UNIX_STREAM_SOCKET__READ                  0x00000002UL
+#define UNIX_STREAM_SOCKET__WRITE                 0x00000004UL
+#define UNIX_STREAM_SOCKET__CREATE                0x00000008UL
+#define UNIX_STREAM_SOCKET__GETATTR               0x00000010UL
+#define UNIX_STREAM_SOCKET__SETATTR               0x00000020UL
+#define UNIX_STREAM_SOCKET__LOCK                  0x00000040UL
+#define UNIX_STREAM_SOCKET__RELABELFROM           0x00000080UL
+#define UNIX_STREAM_SOCKET__RELABELTO             0x00000100UL
+#define UNIX_STREAM_SOCKET__APPEND                0x00000200UL
+#define UNIX_STREAM_SOCKET__BIND                  0x00000400UL
+#define UNIX_STREAM_SOCKET__CONNECT               0x00000800UL
+#define UNIX_STREAM_SOCKET__LISTEN                0x00001000UL
+#define UNIX_STREAM_SOCKET__ACCEPT                0x00002000UL
+#define UNIX_STREAM_SOCKET__GETOPT                0x00004000UL
+#define UNIX_STREAM_SOCKET__SETOPT                0x00008000UL
+#define UNIX_STREAM_SOCKET__SHUTDOWN              0x00010000UL
+#define UNIX_STREAM_SOCKET__RECVFROM              0x00020000UL
+#define UNIX_STREAM_SOCKET__SENDTO                0x00040000UL
+#define UNIX_STREAM_SOCKET__RECV_MSG              0x00080000UL
+#define UNIX_STREAM_SOCKET__SEND_MSG              0x00100000UL
+#define UNIX_STREAM_SOCKET__NAME_BIND             0x00200000UL
+#define UNIX_STREAM_SOCKET__CONNECTTO             0x00400000UL
+#define UNIX_STREAM_SOCKET__NEWCONN               0x00800000UL
+#define UNIX_STREAM_SOCKET__ACCEPTFROM            0x01000000UL
+#define UNIX_DGRAM_SOCKET__IOCTL                  0x00000001UL
+#define UNIX_DGRAM_SOCKET__READ                   0x00000002UL
+#define UNIX_DGRAM_SOCKET__WRITE                  0x00000004UL
+#define UNIX_DGRAM_SOCKET__CREATE                 0x00000008UL
+#define UNIX_DGRAM_SOCKET__GETATTR                0x00000010UL
+#define UNIX_DGRAM_SOCKET__SETATTR                0x00000020UL
+#define UNIX_DGRAM_SOCKET__LOCK                   0x00000040UL
+#define UNIX_DGRAM_SOCKET__RELABELFROM            0x00000080UL
+#define UNIX_DGRAM_SOCKET__RELABELTO              0x00000100UL
+#define UNIX_DGRAM_SOCKET__APPEND                 0x00000200UL
+#define UNIX_DGRAM_SOCKET__BIND                   0x00000400UL
+#define UNIX_DGRAM_SOCKET__CONNECT                0x00000800UL
+#define UNIX_DGRAM_SOCKET__LISTEN                 0x00001000UL
+#define UNIX_DGRAM_SOCKET__ACCEPT                 0x00002000UL
+#define UNIX_DGRAM_SOCKET__GETOPT                 0x00004000UL
+#define UNIX_DGRAM_SOCKET__SETOPT                 0x00008000UL
+#define UNIX_DGRAM_SOCKET__SHUTDOWN               0x00010000UL
+#define UNIX_DGRAM_SOCKET__RECVFROM               0x00020000UL
+#define UNIX_DGRAM_SOCKET__SENDTO                 0x00040000UL
+#define UNIX_DGRAM_SOCKET__RECV_MSG               0x00080000UL
+#define UNIX_DGRAM_SOCKET__SEND_MSG               0x00100000UL
+#define UNIX_DGRAM_SOCKET__NAME_BIND              0x00200000UL
+#define PROCESS__FORK                             0x00000001UL
+#define PROCESS__TRANSITION                       0x00000002UL
+#define PROCESS__SIGCHLD                          0x00000004UL
+#define PROCESS__SIGKILL                          0x00000008UL
+#define PROCESS__SIGSTOP                          0x00000010UL
+#define PROCESS__SIGNULL                          0x00000020UL
+#define PROCESS__SIGNAL                           0x00000040UL
+#define PROCESS__PTRACE                           0x00000080UL
+#define PROCESS__GETSCHED                         0x00000100UL
+#define PROCESS__SETSCHED                         0x00000200UL
+#define PROCESS__GETSESSION                       0x00000400UL
+#define PROCESS__GETPGID                          0x00000800UL
+#define PROCESS__SETPGID                          0x00001000UL
+#define PROCESS__GETCAP                           0x00002000UL
+#define PROCESS__SETCAP                           0x00004000UL
+#define PROCESS__SHARE                            0x00008000UL
+#define PROCESS__GETATTR                          0x00010000UL
+#define PROCESS__SETEXEC                          0x00020000UL
+#define PROCESS__SETFSCREATE                      0x00040000UL
+#define PROCESS__NOATSECURE                       0x00080000UL
+#define PROCESS__SIGINH                           0x00100000UL
+#define PROCESS__SETRLIMIT                        0x00200000UL
+#define PROCESS__RLIMITINH                        0x00400000UL
+#define PROCESS__DYNTRANSITION                    0x00800000UL
+#define PROCESS__SETCURRENT                       0x01000000UL
+#define PROCESS__EXECMEM                          0x02000000UL
+#define PROCESS__EXECSTACK                        0x04000000UL
+#define PROCESS__EXECHEAP                         0x08000000UL
+#define PROCESS__SETKEYCREATE                     0x10000000UL
+#define PROCESS__SETSOCKCREATE                    0x20000000UL
+#define IPC__CREATE                               0x00000001UL
+#define IPC__DESTROY                              0x00000002UL
+#define IPC__GETATTR                              0x00000004UL
+#define IPC__SETATTR                              0x00000008UL
+#define IPC__READ                                 0x00000010UL
+#define IPC__WRITE                                0x00000020UL
+#define IPC__ASSOCIATE                            0x00000040UL
+#define IPC__UNIX_READ                            0x00000080UL
+#define IPC__UNIX_WRITE                           0x00000100UL
+#define SEM__CREATE                               0x00000001UL
+#define SEM__DESTROY                              0x00000002UL
+#define SEM__GETATTR                              0x00000004UL
+#define SEM__SETATTR                              0x00000008UL
+#define SEM__READ                                 0x00000010UL
+#define SEM__WRITE                                0x00000020UL
+#define SEM__ASSOCIATE                            0x00000040UL
+#define SEM__UNIX_READ                            0x00000080UL
+#define SEM__UNIX_WRITE                           0x00000100UL
+#define MSGQ__CREATE                              0x00000001UL
+#define MSGQ__DESTROY                             0x00000002UL
+#define MSGQ__GETATTR                             0x00000004UL
+#define MSGQ__SETATTR                             0x00000008UL
+#define MSGQ__READ                                0x00000010UL
+#define MSGQ__WRITE                               0x00000020UL
+#define MSGQ__ASSOCIATE                           0x00000040UL
+#define MSGQ__UNIX_READ                           0x00000080UL
+#define MSGQ__UNIX_WRITE                          0x00000100UL
+#define MSGQ__ENQUEUE                             0x00000200UL
+#define MSG__SEND                                 0x00000001UL
+#define MSG__RECEIVE                              0x00000002UL
+#define SHM__CREATE                               0x00000001UL
+#define SHM__DESTROY                              0x00000002UL
+#define SHM__GETATTR                              0x00000004UL
+#define SHM__SETATTR                              0x00000008UL
+#define SHM__READ                                 0x00000010UL
+#define SHM__WRITE                                0x00000020UL
+#define SHM__ASSOCIATE                            0x00000040UL
+#define SHM__UNIX_READ                            0x00000080UL
+#define SHM__UNIX_WRITE                           0x00000100UL
+#define SHM__LOCK                                 0x00000200UL
+#define SECURITY__COMPUTE_AV                      0x00000001UL
+#define SECURITY__COMPUTE_CREATE                  0x00000002UL
+#define SECURITY__COMPUTE_MEMBER                  0x00000004UL
+#define SECURITY__CHECK_CONTEXT                   0x00000008UL
+#define SECURITY__LOAD_POLICY                     0x00000010UL
+#define SECURITY__COMPUTE_RELABEL                 0x00000020UL
+#define SECURITY__COMPUTE_USER                    0x00000040UL
+#define SECURITY__SETENFORCE                      0x00000080UL
+#define SECURITY__SETBOOL                         0x00000100UL
+#define SECURITY__SETSECPARAM                     0x00000200UL
+#define SECURITY__SETCHECKREQPROT                 0x00000400UL
+#define SYSTEM__IPC_INFO                          0x00000001UL
+#define SYSTEM__SYSLOG_READ                       0x00000002UL
+#define SYSTEM__SYSLOG_MOD                        0x00000004UL
+#define SYSTEM__SYSLOG_CONSOLE                    0x00000008UL
+#define CAPABILITY__CHOWN                         0x00000001UL
+#define CAPABILITY__DAC_OVERRIDE                  0x00000002UL
+#define CAPABILITY__DAC_READ_SEARCH               0x00000004UL
+#define CAPABILITY__FOWNER                        0x00000008UL
+#define CAPABILITY__FSETID                        0x00000010UL
+#define CAPABILITY__KILL                          0x00000020UL
+#define CAPABILITY__SETGID                        0x00000040UL
+#define CAPABILITY__SETUID                        0x00000080UL
+#define CAPABILITY__SETPCAP                       0x00000100UL
+#define CAPABILITY__LINUX_IMMUTABLE               0x00000200UL
+#define CAPABILITY__NET_BIND_SERVICE              0x00000400UL
+#define CAPABILITY__NET_BROADCAST                 0x00000800UL
+#define CAPABILITY__NET_ADMIN                     0x00001000UL
+#define CAPABILITY__NET_RAW                       0x00002000UL
+#define CAPABILITY__IPC_LOCK                      0x00004000UL
+#define CAPABILITY__IPC_OWNER                     0x00008000UL
+#define CAPABILITY__SYS_MODULE                    0x00010000UL
+#define CAPABILITY__SYS_RAWIO                     0x00020000UL
+#define CAPABILITY__SYS_CHROOT                    0x00040000UL
+#define CAPABILITY__SYS_PTRACE                    0x00080000UL
+#define CAPABILITY__SYS_PACCT                     0x00100000UL
+#define CAPABILITY__SYS_ADMIN                     0x00200000UL
+#define CAPABILITY__SYS_BOOT                      0x00400000UL
+#define CAPABILITY__SYS_NICE                      0x00800000UL
+#define CAPABILITY__SYS_RESOURCE                  0x01000000UL
+#define CAPABILITY__SYS_TIME                      0x02000000UL
+#define CAPABILITY__SYS_TTY_CONFIG                0x04000000UL
+#define CAPABILITY__MKNOD                         0x08000000UL
+#define CAPABILITY__LEASE                         0x10000000UL
+#define CAPABILITY__AUDIT_WRITE                   0x20000000UL
+#define CAPABILITY__AUDIT_CONTROL                 0x40000000UL
+#define CAPABILITY__SETFCAP                       0x80000000UL
+#define CAPABILITY2__MAC_OVERRIDE                 0x00000001UL
+#define CAPABILITY2__MAC_ADMIN                    0x00000002UL
+#define PASSWD__PASSWD                            0x00000001UL
+#define PASSWD__CHFN                              0x00000002UL
+#define PASSWD__CHSH                              0x00000004UL
+#define PASSWD__ROOTOK                            0x00000008UL
+#define PASSWD__CRONTAB                           0x00000010UL
+#define X_DRAWABLE__CREATE                        0x00000001UL
+#define X_DRAWABLE__DESTROY                       0x00000002UL
+#define X_DRAWABLE__READ                          0x00000004UL
+#define X_DRAWABLE__WRITE                         0x00000008UL
+#define X_DRAWABLE__BLEND                         0x00000010UL
+#define X_DRAWABLE__GETATTR                       0x00000020UL
+#define X_DRAWABLE__SETATTR                       0x00000040UL
+#define X_DRAWABLE__LIST_CHILD                    0x00000080UL
+#define X_DRAWABLE__ADD_CHILD                     0x00000100UL
+#define X_DRAWABLE__REMOVE_CHILD                  0x00000200UL
+#define X_DRAWABLE__LIST_PROPERTY                 0x00000400UL
+#define X_DRAWABLE__GET_PROPERTY                  0x00000800UL
+#define X_DRAWABLE__SET_PROPERTY                  0x00001000UL
+#define X_DRAWABLE__MANAGE                        0x00002000UL
+#define X_DRAWABLE__OVERRIDE                      0x00004000UL
+#define X_DRAWABLE__SHOW                          0x00008000UL
+#define X_DRAWABLE__HIDE                          0x00010000UL
+#define X_DRAWABLE__SEND                          0x00020000UL
+#define X_DRAWABLE__RECEIVE                       0x00040000UL
+#define X_SCREEN__GETATTR                         0x00000001UL
+#define X_SCREEN__SETATTR                         0x00000002UL
+#define X_SCREEN__HIDE_CURSOR                     0x00000004UL
+#define X_SCREEN__SHOW_CURSOR                     0x00000008UL
+#define X_SCREEN__SAVER_GETATTR                   0x00000010UL
+#define X_SCREEN__SAVER_SETATTR                   0x00000020UL
+#define X_SCREEN__SAVER_HIDE                      0x00000040UL
+#define X_SCREEN__SAVER_SHOW                      0x00000080UL
+#define X_GC__CREATE                              0x00000001UL
+#define X_GC__DESTROY                             0x00000002UL
+#define X_GC__GETATTR                             0x00000004UL
+#define X_GC__SETATTR                             0x00000008UL
+#define X_GC__USE                                 0x00000010UL
+#define X_FONT__CREATE                            0x00000001UL
+#define X_FONT__DESTROY                           0x00000002UL
+#define X_FONT__GETATTR                           0x00000004UL
+#define X_FONT__ADD_GLYPH                         0x00000008UL
+#define X_FONT__REMOVE_GLYPH                      0x00000010UL
+#define X_FONT__USE                               0x00000020UL
+#define X_COLORMAP__CREATE                        0x00000001UL
+#define X_COLORMAP__DESTROY                       0x00000002UL
+#define X_COLORMAP__READ                          0x00000004UL
+#define X_COLORMAP__WRITE                         0x00000008UL
+#define X_COLORMAP__GETATTR                       0x00000010UL
+#define X_COLORMAP__ADD_COLOR                     0x00000020UL
+#define X_COLORMAP__REMOVE_COLOR                  0x00000040UL
+#define X_COLORMAP__INSTALL                       0x00000080UL
+#define X_COLORMAP__UNINSTALL                     0x00000100UL
+#define X_COLORMAP__USE                           0x00000200UL
+#define X_PROPERTY__CREATE                        0x00000001UL
+#define X_PROPERTY__DESTROY                       0x00000002UL
+#define X_PROPERTY__READ                          0x00000004UL
+#define X_PROPERTY__WRITE                         0x00000008UL
+#define X_PROPERTY__APPEND                        0x00000010UL
+#define X_PROPERTY__GETATTR                       0x00000020UL
+#define X_PROPERTY__SETATTR                       0x00000040UL
+#define X_SELECTION__READ                         0x00000001UL
+#define X_SELECTION__WRITE                        0x00000002UL
+#define X_SELECTION__GETATTR                      0x00000004UL
+#define X_SELECTION__SETATTR                      0x00000008UL
+#define X_CURSOR__CREATE                          0x00000001UL
+#define X_CURSOR__DESTROY                         0x00000002UL
+#define X_CURSOR__READ                            0x00000004UL
+#define X_CURSOR__WRITE                           0x00000008UL
+#define X_CURSOR__GETATTR                         0x00000010UL
+#define X_CURSOR__SETATTR                         0x00000020UL
+#define X_CURSOR__USE                             0x00000040UL
+#define X_CLIENT__DESTROY                         0x00000001UL
+#define X_CLIENT__GETATTR                         0x00000002UL
+#define X_CLIENT__SETATTR                         0x00000004UL
+#define X_CLIENT__MANAGE                          0x00000008UL
+#define X_DEVICE__GETATTR                         0x00000001UL
+#define X_DEVICE__SETATTR                         0x00000002UL
+#define X_DEVICE__USE                             0x00000004UL
+#define X_DEVICE__READ                            0x00000008UL
+#define X_DEVICE__WRITE                           0x00000010UL
+#define X_DEVICE__GETFOCUS                        0x00000020UL
+#define X_DEVICE__SETFOCUS                        0x00000040UL
+#define X_DEVICE__BELL                            0x00000080UL
+#define X_DEVICE__FORCE_CURSOR                    0x00000100UL
+#define X_DEVICE__FREEZE                          0x00000200UL
+#define X_DEVICE__GRAB                            0x00000400UL
+#define X_DEVICE__MANAGE                          0x00000800UL
+#define X_SERVER__GETATTR                         0x00000001UL
+#define X_SERVER__SETATTR                         0x00000002UL
+#define X_SERVER__RECORD                          0x00000004UL
+#define X_SERVER__DEBUG                           0x00000008UL
+#define X_SERVER__GRAB                            0x00000010UL
+#define X_SERVER__MANAGE                          0x00000020UL
+#define X_EXTENSION__QUERY                        0x00000001UL
+#define X_EXTENSION__USE                          0x00000002UL
+#define X_RESOURCE__READ                          0x00000001UL
+#define X_RESOURCE__WRITE                         0x00000002UL
+#define X_EVENT__SEND                             0x00000001UL
+#define X_EVENT__RECEIVE                          0x00000002UL
+#define X_SYNTHETIC_EVENT__SEND                   0x00000001UL
+#define X_SYNTHETIC_EVENT__RECEIVE                0x00000002UL
+#define NETLINK_ROUTE_SOCKET__IOCTL               0x00000001UL
+#define NETLINK_ROUTE_SOCKET__READ                0x00000002UL
+#define NETLINK_ROUTE_SOCKET__WRITE               0x00000004UL
+#define NETLINK_ROUTE_SOCKET__CREATE              0x00000008UL
+#define NETLINK_ROUTE_SOCKET__GETATTR             0x00000010UL
+#define NETLINK_ROUTE_SOCKET__SETATTR             0x00000020UL
+#define NETLINK_ROUTE_SOCKET__LOCK                0x00000040UL
+#define NETLINK_ROUTE_SOCKET__RELABELFROM         0x00000080UL
+#define NETLINK_ROUTE_SOCKET__RELABELTO           0x00000100UL
+#define NETLINK_ROUTE_SOCKET__APPEND              0x00000200UL
+#define NETLINK_ROUTE_SOCKET__BIND                0x00000400UL
+#define NETLINK_ROUTE_SOCKET__CONNECT             0x00000800UL
+#define NETLINK_ROUTE_SOCKET__LISTEN              0x00001000UL
+#define NETLINK_ROUTE_SOCKET__ACCEPT              0x00002000UL
+#define NETLINK_ROUTE_SOCKET__GETOPT              0x00004000UL
+#define NETLINK_ROUTE_SOCKET__SETOPT              0x00008000UL
+#define NETLINK_ROUTE_SOCKET__SHUTDOWN            0x00010000UL
+#define NETLINK_ROUTE_SOCKET__RECVFROM            0x00020000UL
+#define NETLINK_ROUTE_SOCKET__SENDTO              0x00040000UL
+#define NETLINK_ROUTE_SOCKET__RECV_MSG            0x00080000UL
+#define NETLINK_ROUTE_SOCKET__SEND_MSG            0x00100000UL
+#define NETLINK_ROUTE_SOCKET__NAME_BIND           0x00200000UL
+#define NETLINK_ROUTE_SOCKET__NLMSG_READ          0x00400000UL
+#define NETLINK_ROUTE_SOCKET__NLMSG_WRITE         0x00800000UL
+#define NETLINK_FIREWALL_SOCKET__IOCTL            0x00000001UL
+#define NETLINK_FIREWALL_SOCKET__READ             0x00000002UL
+#define NETLINK_FIREWALL_SOCKET__WRITE            0x00000004UL
+#define NETLINK_FIREWALL_SOCKET__CREATE           0x00000008UL
+#define NETLINK_FIREWALL_SOCKET__GETATTR          0x00000010UL
+#define NETLINK_FIREWALL_SOCKET__SETATTR          0x00000020UL
+#define NETLINK_FIREWALL_SOCKET__LOCK             0x00000040UL
+#define NETLINK_FIREWALL_SOCKET__RELABELFROM      0x00000080UL
+#define NETLINK_FIREWALL_SOCKET__RELABELTO        0x00000100UL
+#define NETLINK_FIREWALL_SOCKET__APPEND           0x00000200UL
+#define NETLINK_FIREWALL_SOCKET__BIND             0x00000400UL
+#define NETLINK_FIREWALL_SOCKET__CONNECT          0x00000800UL
+#define NETLINK_FIREWALL_SOCKET__LISTEN           0x00001000UL
+#define NETLINK_FIREWALL_SOCKET__ACCEPT           0x00002000UL
+#define NETLINK_FIREWALL_SOCKET__GETOPT           0x00004000UL
+#define NETLINK_FIREWALL_SOCKET__SETOPT           0x00008000UL
+#define NETLINK_FIREWALL_SOCKET__SHUTDOWN         0x00010000UL
+#define NETLINK_FIREWALL_SOCKET__RECVFROM         0x00020000UL
+#define NETLINK_FIREWALL_SOCKET__SENDTO           0x00040000UL
+#define NETLINK_FIREWALL_SOCKET__RECV_MSG         0x00080000UL
+#define NETLINK_FIREWALL_SOCKET__SEND_MSG         0x00100000UL
+#define NETLINK_FIREWALL_SOCKET__NAME_BIND        0x00200000UL
+#define NETLINK_FIREWALL_SOCKET__NLMSG_READ       0x00400000UL
+#define NETLINK_FIREWALL_SOCKET__NLMSG_WRITE      0x00800000UL
+#define NETLINK_TCPDIAG_SOCKET__IOCTL             0x00000001UL
+#define NETLINK_TCPDIAG_SOCKET__READ              0x00000002UL
+#define NETLINK_TCPDIAG_SOCKET__WRITE             0x00000004UL
+#define NETLINK_TCPDIAG_SOCKET__CREATE            0x00000008UL
+#define NETLINK_TCPDIAG_SOCKET__GETATTR           0x00000010UL
+#define NETLINK_TCPDIAG_SOCKET__SETATTR           0x00000020UL
+#define NETLINK_TCPDIAG_SOCKET__LOCK              0x00000040UL
+#define NETLINK_TCPDIAG_SOCKET__RELABELFROM       0x00000080UL
+#define NETLINK_TCPDIAG_SOCKET__RELABELTO         0x00000100UL
+#define NETLINK_TCPDIAG_SOCKET__APPEND            0x00000200UL
+#define NETLINK_TCPDIAG_SOCKET__BIND              0x00000400UL
+#define NETLINK_TCPDIAG_SOCKET__CONNECT           0x00000800UL
+#define NETLINK_TCPDIAG_SOCKET__LISTEN            0x00001000UL
+#define NETLINK_TCPDIAG_SOCKET__ACCEPT            0x00002000UL
+#define NETLINK_TCPDIAG_SOCKET__GETOPT            0x00004000UL
+#define NETLINK_TCPDIAG_SOCKET__SETOPT            0x00008000UL
+#define NETLINK_TCPDIAG_SOCKET__SHUTDOWN          0x00010000UL
+#define NETLINK_TCPDIAG_SOCKET__RECVFROM          0x00020000UL
+#define NETLINK_TCPDIAG_SOCKET__SENDTO            0x00040000UL
+#define NETLINK_TCPDIAG_SOCKET__RECV_MSG          0x00080000UL
+#define NETLINK_TCPDIAG_SOCKET__SEND_MSG          0x00100000UL
+#define NETLINK_TCPDIAG_SOCKET__NAME_BIND         0x00200000UL
+#define NETLINK_TCPDIAG_SOCKET__NLMSG_READ        0x00400000UL
+#define NETLINK_TCPDIAG_SOCKET__NLMSG_WRITE       0x00800000UL
+#define NETLINK_NFLOG_SOCKET__IOCTL               0x00000001UL
+#define NETLINK_NFLOG_SOCKET__READ                0x00000002UL
+#define NETLINK_NFLOG_SOCKET__WRITE               0x00000004UL
+#define NETLINK_NFLOG_SOCKET__CREATE              0x00000008UL
+#define NETLINK_NFLOG_SOCKET__GETATTR             0x00000010UL
+#define NETLINK_NFLOG_SOCKET__SETATTR             0x00000020UL
+#define NETLINK_NFLOG_SOCKET__LOCK                0x00000040UL
+#define NETLINK_NFLOG_SOCKET__RELABELFROM         0x00000080UL
+#define NETLINK_NFLOG_SOCKET__RELABELTO           0x00000100UL
+#define NETLINK_NFLOG_SOCKET__APPEND              0x00000200UL
+#define NETLINK_NFLOG_SOCKET__BIND                0x00000400UL
+#define NETLINK_NFLOG_SOCKET__CONNECT             0x00000800UL
+#define NETLINK_NFLOG_SOCKET__LISTEN              0x00001000UL
+#define NETLINK_NFLOG_SOCKET__ACCEPT              0x00002000UL
+#define NETLINK_NFLOG_SOCKET__GETOPT              0x00004000UL
+#define NETLINK_NFLOG_SOCKET__SETOPT              0x00008000UL
+#define NETLINK_NFLOG_SOCKET__SHUTDOWN            0x00010000UL
+#define NETLINK_NFLOG_SOCKET__RECVFROM            0x00020000UL
+#define NETLINK_NFLOG_SOCKET__SENDTO              0x00040000UL
+#define NETLINK_NFLOG_SOCKET__RECV_MSG            0x00080000UL
+#define NETLINK_NFLOG_SOCKET__SEND_MSG            0x00100000UL
+#define NETLINK_NFLOG_SOCKET__NAME_BIND           0x00200000UL
+#define NETLINK_XFRM_SOCKET__IOCTL                0x00000001UL
+#define NETLINK_XFRM_SOCKET__READ                 0x00000002UL
+#define NETLINK_XFRM_SOCKET__WRITE                0x00000004UL
+#define NETLINK_XFRM_SOCKET__CREATE               0x00000008UL
+#define NETLINK_XFRM_SOCKET__GETATTR              0x00000010UL
+#define NETLINK_XFRM_SOCKET__SETATTR              0x00000020UL
+#define NETLINK_XFRM_SOCKET__LOCK                 0x00000040UL
+#define NETLINK_XFRM_SOCKET__RELABELFROM          0x00000080UL
+#define NETLINK_XFRM_SOCKET__RELABELTO            0x00000100UL
+#define NETLINK_XFRM_SOCKET__APPEND               0x00000200UL
+#define NETLINK_XFRM_SOCKET__BIND                 0x00000400UL
+#define NETLINK_XFRM_SOCKET__CONNECT              0x00000800UL
+#define NETLINK_XFRM_SOCKET__LISTEN               0x00001000UL
+#define NETLINK_XFRM_SOCKET__ACCEPT               0x00002000UL
+#define NETLINK_XFRM_SOCKET__GETOPT               0x00004000UL
+#define NETLINK_XFRM_SOCKET__SETOPT               0x00008000UL
+#define NETLINK_XFRM_SOCKET__SHUTDOWN             0x00010000UL
+#define NETLINK_XFRM_SOCKET__RECVFROM             0x00020000UL
+#define NETLINK_XFRM_SOCKET__SENDTO               0x00040000UL
+#define NETLINK_XFRM_SOCKET__RECV_MSG             0x00080000UL
+#define NETLINK_XFRM_SOCKET__SEND_MSG             0x00100000UL
+#define NETLINK_XFRM_SOCKET__NAME_BIND            0x00200000UL
+#define NETLINK_XFRM_SOCKET__NLMSG_READ           0x00400000UL
+#define NETLINK_XFRM_SOCKET__NLMSG_WRITE          0x00800000UL
+#define NETLINK_SELINUX_SOCKET__IOCTL             0x00000001UL
+#define NETLINK_SELINUX_SOCKET__READ              0x00000002UL
+#define NETLINK_SELINUX_SOCKET__WRITE             0x00000004UL
+#define NETLINK_SELINUX_SOCKET__CREATE            0x00000008UL
+#define NETLINK_SELINUX_SOCKET__GETATTR           0x00000010UL
+#define NETLINK_SELINUX_SOCKET__SETATTR           0x00000020UL
+#define NETLINK_SELINUX_SOCKET__LOCK              0x00000040UL
+#define NETLINK_SELINUX_SOCKET__RELABELFROM       0x00000080UL
+#define NETLINK_SELINUX_SOCKET__RELABELTO         0x00000100UL
+#define NETLINK_SELINUX_SOCKET__APPEND            0x00000200UL
+#define NETLINK_SELINUX_SOCKET__BIND              0x00000400UL
+#define NETLINK_SELINUX_SOCKET__CONNECT           0x00000800UL
+#define NETLINK_SELINUX_SOCKET__LISTEN            0x00001000UL
+#define NETLINK_SELINUX_SOCKET__ACCEPT            0x00002000UL
+#define NETLINK_SELINUX_SOCKET__GETOPT            0x00004000UL
+#define NETLINK_SELINUX_SOCKET__SETOPT            0x00008000UL
+#define NETLINK_SELINUX_SOCKET__SHUTDOWN          0x00010000UL
+#define NETLINK_SELINUX_SOCKET__RECVFROM          0x00020000UL
+#define NETLINK_SELINUX_SOCKET__SENDTO            0x00040000UL
+#define NETLINK_SELINUX_SOCKET__RECV_MSG          0x00080000UL
+#define NETLINK_SELINUX_SOCKET__SEND_MSG          0x00100000UL
+#define NETLINK_SELINUX_SOCKET__NAME_BIND         0x00200000UL
+#define NETLINK_AUDIT_SOCKET__IOCTL               0x00000001UL
+#define NETLINK_AUDIT_SOCKET__READ                0x00000002UL
+#define NETLINK_AUDIT_SOCKET__WRITE               0x00000004UL
+#define NETLINK_AUDIT_SOCKET__CREATE              0x00000008UL
+#define NETLINK_AUDIT_SOCKET__GETATTR             0x00000010UL
+#define NETLINK_AUDIT_SOCKET__SETATTR             0x00000020UL
+#define NETLINK_AUDIT_SOCKET__LOCK                0x00000040UL
+#define NETLINK_AUDIT_SOCKET__RELABELFROM         0x00000080UL
+#define NETLINK_AUDIT_SOCKET__RELABELTO           0x00000100UL
+#define NETLINK_AUDIT_SOCKET__APPEND              0x00000200UL
+#define NETLINK_AUDIT_SOCKET__BIND                0x00000400UL
+#define NETLINK_AUDIT_SOCKET__CONNECT             0x00000800UL
+#define NETLINK_AUDIT_SOCKET__LISTEN              0x00001000UL
+#define NETLINK_AUDIT_SOCKET__ACCEPT              0x00002000UL
+#define NETLINK_AUDIT_SOCKET__GETOPT              0x00004000UL
+#define NETLINK_AUDIT_SOCKET__SETOPT              0x00008000UL
+#define NETLINK_AUDIT_SOCKET__SHUTDOWN            0x00010000UL
+#define NETLINK_AUDIT_SOCKET__RECVFROM            0x00020000UL
+#define NETLINK_AUDIT_SOCKET__SENDTO              0x00040000UL
+#define NETLINK_AUDIT_SOCKET__RECV_MSG            0x00080000UL
+#define NETLINK_AUDIT_SOCKET__SEND_MSG            0x00100000UL
+#define NETLINK_AUDIT_SOCKET__NAME_BIND           0x00200000UL
+#define NETLINK_AUDIT_SOCKET__NLMSG_READ          0x00400000UL
+#define NETLINK_AUDIT_SOCKET__NLMSG_WRITE         0x00800000UL
+#define NETLINK_AUDIT_SOCKET__NLMSG_RELAY         0x01000000UL
+#define NETLINK_AUDIT_SOCKET__NLMSG_READPRIV      0x02000000UL
+#define NETLINK_AUDIT_SOCKET__NLMSG_TTY_AUDIT     0x04000000UL
+#define NETLINK_IP6FW_SOCKET__IOCTL               0x00000001UL
+#define NETLINK_IP6FW_SOCKET__READ                0x00000002UL
+#define NETLINK_IP6FW_SOCKET__WRITE               0x00000004UL
+#define NETLINK_IP6FW_SOCKET__CREATE              0x00000008UL
+#define NETLINK_IP6FW_SOCKET__GETATTR             0x00000010UL
+#define NETLINK_IP6FW_SOCKET__SETATTR             0x00000020UL
+#define NETLINK_IP6FW_SOCKET__LOCK                0x00000040UL
+#define NETLINK_IP6FW_SOCKET__RELABELFROM         0x00000080UL
+#define NETLINK_IP6FW_SOCKET__RELABELTO           0x00000100UL
+#define NETLINK_IP6FW_SOCKET__APPEND              0x00000200UL
+#define NETLINK_IP6FW_SOCKET__BIND                0x00000400UL
+#define NETLINK_IP6FW_SOCKET__CONNECT             0x00000800UL
+#define NETLINK_IP6FW_SOCKET__LISTEN              0x00001000UL
+#define NETLINK_IP6FW_SOCKET__ACCEPT              0x00002000UL
+#define NETLINK_IP6FW_SOCKET__GETOPT              0x00004000UL
+#define NETLINK_IP6FW_SOCKET__SETOPT              0x00008000UL
+#define NETLINK_IP6FW_SOCKET__SHUTDOWN            0x00010000UL
+#define NETLINK_IP6FW_SOCKET__RECVFROM            0x00020000UL
+#define NETLINK_IP6FW_SOCKET__SENDTO              0x00040000UL
+#define NETLINK_IP6FW_SOCKET__RECV_MSG            0x00080000UL
+#define NETLINK_IP6FW_SOCKET__SEND_MSG            0x00100000UL
+#define NETLINK_IP6FW_SOCKET__NAME_BIND           0x00200000UL
+#define NETLINK_IP6FW_SOCKET__NLMSG_READ          0x00400000UL
+#define NETLINK_IP6FW_SOCKET__NLMSG_WRITE         0x00800000UL
+#define NETLINK_DNRT_SOCKET__IOCTL                0x00000001UL
+#define NETLINK_DNRT_SOCKET__READ                 0x00000002UL
+#define NETLINK_DNRT_SOCKET__WRITE                0x00000004UL
+#define NETLINK_DNRT_SOCKET__CREATE               0x00000008UL
+#define NETLINK_DNRT_SOCKET__GETATTR              0x00000010UL
+#define NETLINK_DNRT_SOCKET__SETATTR              0x00000020UL
+#define NETLINK_DNRT_SOCKET__LOCK                 0x00000040UL
+#define NETLINK_DNRT_SOCKET__RELABELFROM          0x00000080UL
+#define NETLINK_DNRT_SOCKET__RELABELTO            0x00000100UL
+#define NETLINK_DNRT_SOCKET__APPEND               0x00000200UL
+#define NETLINK_DNRT_SOCKET__BIND                 0x00000400UL
+#define NETLINK_DNRT_SOCKET__CONNECT              0x00000800UL
+#define NETLINK_DNRT_SOCKET__LISTEN               0x00001000UL
+#define NETLINK_DNRT_SOCKET__ACCEPT               0x00002000UL
+#define NETLINK_DNRT_SOCKET__GETOPT               0x00004000UL
+#define NETLINK_DNRT_SOCKET__SETOPT               0x00008000UL
+#define NETLINK_DNRT_SOCKET__SHUTDOWN             0x00010000UL
+#define NETLINK_DNRT_SOCKET__RECVFROM             0x00020000UL
+#define NETLINK_DNRT_SOCKET__SENDTO               0x00040000UL
+#define NETLINK_DNRT_SOCKET__RECV_MSG             0x00080000UL
+#define NETLINK_DNRT_SOCKET__SEND_MSG             0x00100000UL
+#define NETLINK_DNRT_SOCKET__NAME_BIND            0x00200000UL
+#define DBUS__ACQUIRE_SVC                         0x00000001UL
+#define DBUS__SEND_MSG                            0x00000002UL
+#define NSCD__GETPWD                              0x00000001UL
+#define NSCD__GETGRP                              0x00000002UL
+#define NSCD__GETHOST                             0x00000004UL
+#define NSCD__GETSTAT                             0x00000008UL
+#define NSCD__ADMIN                               0x00000010UL
+#define NSCD__SHMEMPWD                            0x00000020UL
+#define NSCD__SHMEMGRP                            0x00000040UL
+#define NSCD__SHMEMHOST                           0x00000080UL
+#define NSCD__GETSERV                             0x00000100UL
+#define NSCD__SHMEMSERV                           0x00000200UL
+#define ASSOCIATION__SENDTO                       0x00000001UL
+#define ASSOCIATION__RECVFROM                     0x00000002UL
+#define ASSOCIATION__SETCONTEXT                   0x00000004UL
+#define ASSOCIATION__POLMATCH                     0x00000008UL
+#define NETLINK_KOBJECT_UEVENT_SOCKET__IOCTL      0x00000001UL
+#define NETLINK_KOBJECT_UEVENT_SOCKET__READ       0x00000002UL
+#define NETLINK_KOBJECT_UEVENT_SOCKET__WRITE      0x00000004UL
+#define NETLINK_KOBJECT_UEVENT_SOCKET__CREATE     0x00000008UL
+#define NETLINK_KOBJECT_UEVENT_SOCKET__GETATTR    0x00000010UL
+#define NETLINK_KOBJECT_UEVENT_SOCKET__SETATTR    0x00000020UL
+#define NETLINK_KOBJECT_UEVENT_SOCKET__LOCK       0x00000040UL
+#define NETLINK_KOBJECT_UEVENT_SOCKET__RELABELFROM 0x00000080UL
+#define NETLINK_KOBJECT_UEVENT_SOCKET__RELABELTO  0x00000100UL
+#define NETLINK_KOBJECT_UEVENT_SOCKET__APPEND     0x00000200UL
+#define NETLINK_KOBJECT_UEVENT_SOCKET__BIND       0x00000400UL
+#define NETLINK_KOBJECT_UEVENT_SOCKET__CONNECT    0x00000800UL
+#define NETLINK_KOBJECT_UEVENT_SOCKET__LISTEN     0x00001000UL
+#define NETLINK_KOBJECT_UEVENT_SOCKET__ACCEPT     0x00002000UL
+#define NETLINK_KOBJECT_UEVENT_SOCKET__GETOPT     0x00004000UL
+#define NETLINK_KOBJECT_UEVENT_SOCKET__SETOPT     0x00008000UL
+#define NETLINK_KOBJECT_UEVENT_SOCKET__SHUTDOWN   0x00010000UL
+#define NETLINK_KOBJECT_UEVENT_SOCKET__RECVFROM   0x00020000UL
+#define NETLINK_KOBJECT_UEVENT_SOCKET__SENDTO     0x00040000UL
+#define NETLINK_KOBJECT_UEVENT_SOCKET__RECV_MSG   0x00080000UL
+#define NETLINK_KOBJECT_UEVENT_SOCKET__SEND_MSG   0x00100000UL
+#define NETLINK_KOBJECT_UEVENT_SOCKET__NAME_BIND  0x00200000UL
+#define APPLETALK_SOCKET__IOCTL                   0x00000001UL
+#define APPLETALK_SOCKET__READ                    0x00000002UL
+#define APPLETALK_SOCKET__WRITE                   0x00000004UL
+#define APPLETALK_SOCKET__CREATE                  0x00000008UL
+#define APPLETALK_SOCKET__GETATTR                 0x00000010UL
+#define APPLETALK_SOCKET__SETATTR                 0x00000020UL
+#define APPLETALK_SOCKET__LOCK                    0x00000040UL
+#define APPLETALK_SOCKET__RELABELFROM             0x00000080UL
+#define APPLETALK_SOCKET__RELABELTO               0x00000100UL
+#define APPLETALK_SOCKET__APPEND                  0x00000200UL
+#define APPLETALK_SOCKET__BIND                    0x00000400UL
+#define APPLETALK_SOCKET__CONNECT                 0x00000800UL
+#define APPLETALK_SOCKET__LISTEN                  0x00001000UL
+#define APPLETALK_SOCKET__ACCEPT                  0x00002000UL
+#define APPLETALK_SOCKET__GETOPT                  0x00004000UL
+#define APPLETALK_SOCKET__SETOPT                  0x00008000UL
+#define APPLETALK_SOCKET__SHUTDOWN                0x00010000UL
+#define APPLETALK_SOCKET__RECVFROM                0x00020000UL
+#define APPLETALK_SOCKET__SENDTO                  0x00040000UL
+#define APPLETALK_SOCKET__RECV_MSG                0x00080000UL
+#define APPLETALK_SOCKET__SEND_MSG                0x00100000UL
+#define APPLETALK_SOCKET__NAME_BIND               0x00200000UL
+#define PACKET__SEND                              0x00000001UL
+#define PACKET__RECV                              0x00000002UL
+#define PACKET__RELABELTO                         0x00000004UL
+#define PACKET__FLOW_IN                           0x00000008UL
+#define PACKET__FLOW_OUT                          0x00000010UL
+#define PACKET__FORWARD_IN                        0x00000020UL
+#define PACKET__FORWARD_OUT                       0x00000040UL
+#define KEY__VIEW                                 0x00000001UL
+#define KEY__READ                                 0x00000002UL
+#define KEY__WRITE                                0x00000004UL
+#define KEY__SEARCH                               0x00000008UL
+#define KEY__LINK                                 0x00000010UL
+#define KEY__SETATTR                              0x00000020UL
+#define KEY__CREATE                               0x00000040UL
+#define CONTEXT__TRANSLATE                        0x00000001UL
+#define CONTEXT__CONTAINS                         0x00000002UL
+#define DCCP_SOCKET__IOCTL                        0x00000001UL
+#define DCCP_SOCKET__READ                         0x00000002UL
+#define DCCP_SOCKET__WRITE                        0x00000004UL
+#define DCCP_SOCKET__CREATE                       0x00000008UL
+#define DCCP_SOCKET__GETATTR                      0x00000010UL
+#define DCCP_SOCKET__SETATTR                      0x00000020UL
+#define DCCP_SOCKET__LOCK                         0x00000040UL
+#define DCCP_SOCKET__RELABELFROM                  0x00000080UL
+#define DCCP_SOCKET__RELABELTO                    0x00000100UL
+#define DCCP_SOCKET__APPEND                       0x00000200UL
+#define DCCP_SOCKET__BIND                         0x00000400UL
+#define DCCP_SOCKET__CONNECT                      0x00000800UL
+#define DCCP_SOCKET__LISTEN                       0x00001000UL
+#define DCCP_SOCKET__ACCEPT                       0x00002000UL
+#define DCCP_SOCKET__GETOPT                       0x00004000UL
+#define DCCP_SOCKET__SETOPT                       0x00008000UL
+#define DCCP_SOCKET__SHUTDOWN                     0x00010000UL
+#define DCCP_SOCKET__RECVFROM                     0x00020000UL
+#define DCCP_SOCKET__SENDTO                       0x00040000UL
+#define DCCP_SOCKET__RECV_MSG                     0x00080000UL
+#define DCCP_SOCKET__SEND_MSG                     0x00100000UL
+#define DCCP_SOCKET__NAME_BIND                    0x00200000UL
+#define DCCP_SOCKET__NODE_BIND                    0x00400000UL
+#define DCCP_SOCKET__NAME_CONNECT                 0x00800000UL
+#define MEMPROTECT__MMAP_ZERO                     0x00000001UL
+#define DB_DATABASE__CREATE                       0x00000001UL
+#define DB_DATABASE__DROP                         0x00000002UL
+#define DB_DATABASE__GETATTR                      0x00000004UL
+#define DB_DATABASE__SETATTR                      0x00000008UL
+#define DB_DATABASE__RELABELFROM                  0x00000010UL
+#define DB_DATABASE__RELABELTO                    0x00000020UL
+#define DB_DATABASE__ACCESS                       0x00000040UL
+#define DB_DATABASE__INSTALL_MODULE               0x00000080UL
+#define DB_DATABASE__LOAD_MODULE                  0x00000100UL
+#define DB_DATABASE__GET_PARAM                    0x00000200UL
+#define DB_DATABASE__SET_PARAM                    0x00000400UL
+#define DB_TABLE__CREATE                          0x00000001UL
+#define DB_TABLE__DROP                            0x00000002UL
+#define DB_TABLE__GETATTR                         0x00000004UL
+#define DB_TABLE__SETATTR                         0x00000008UL
+#define DB_TABLE__RELABELFROM                     0x00000010UL
+#define DB_TABLE__RELABELTO                       0x00000020UL
+#define DB_TABLE__USE                             0x00000040UL
+#define DB_TABLE__SELECT                          0x00000080UL
+#define DB_TABLE__UPDATE                          0x00000100UL
+#define DB_TABLE__INSERT                          0x00000200UL
+#define DB_TABLE__DELETE                          0x00000400UL
+#define DB_TABLE__LOCK                            0x00000800UL
+#define DB_PROCEDURE__CREATE                      0x00000001UL
+#define DB_PROCEDURE__DROP                        0x00000002UL
+#define DB_PROCEDURE__GETATTR                     0x00000004UL
+#define DB_PROCEDURE__SETATTR                     0x00000008UL
+#define DB_PROCEDURE__RELABELFROM                 0x00000010UL
+#define DB_PROCEDURE__RELABELTO                   0x00000020UL
+#define DB_PROCEDURE__EXECUTE                     0x00000040UL
+#define DB_PROCEDURE__ENTRYPOINT                  0x00000080UL
+#define DB_COLUMN__CREATE                         0x00000001UL
+#define DB_COLUMN__DROP                           0x00000002UL
+#define DB_COLUMN__GETATTR                        0x00000004UL
+#define DB_COLUMN__SETATTR                        0x00000008UL
+#define DB_COLUMN__RELABELFROM                    0x00000010UL
+#define DB_COLUMN__RELABELTO                      0x00000020UL
+#define DB_COLUMN__USE                            0x00000040UL
+#define DB_COLUMN__SELECT                         0x00000080UL
+#define DB_COLUMN__UPDATE                         0x00000100UL
+#define DB_COLUMN__INSERT                         0x00000200UL
+#define DB_TUPLE__RELABELFROM                     0x00000001UL
+#define DB_TUPLE__RELABELTO                       0x00000002UL
+#define DB_TUPLE__USE                             0x00000004UL
+#define DB_TUPLE__SELECT                          0x00000008UL
+#define DB_TUPLE__UPDATE                          0x00000010UL
+#define DB_TUPLE__INSERT                          0x00000020UL
+#define DB_TUPLE__DELETE                          0x00000040UL
+#define DB_BLOB__CREATE                           0x00000001UL
+#define DB_BLOB__DROP                             0x00000002UL
+#define DB_BLOB__GETATTR                          0x00000004UL
+#define DB_BLOB__SETATTR                          0x00000008UL
+#define DB_BLOB__RELABELFROM                      0x00000010UL
+#define DB_BLOB__RELABELTO                        0x00000020UL
+#define DB_BLOB__READ                             0x00000040UL
+#define DB_BLOB__WRITE                            0x00000080UL
+#define DB_BLOB__IMPORT                           0x00000100UL
+#define DB_BLOB__EXPORT                           0x00000200UL
+#define PEER__RECV                                0x00000001UL
+#define X_APPLICATION_DATA__PASTE                 0x00000001UL
+#define X_APPLICATION_DATA__PASTE_AFTER_CONFIRM   0x00000002UL
+#define X_APPLICATION_DATA__COPY                  0x00000004UL
+
+static inline uint32_t file_mask_to_perms(int mode, int mask)
+{
+	uint32_t av = 0;
+
+	if (!S_ISDIR(mode)) {
+		if (mask & MAY_EXEC)
+			av |= FILE__EXECUTE;
+		if (mask & MAY_READ)
+			av |= FILE__READ;
+		if (mask & MAY_APPEND)
+			av |= FILE__APPEND;
+		else if (mask & MAY_WRITE)
+			av |= FILE__WRITE;
+	} else {
+		if (mask & MAY_EXEC)
+			av |= DIR__SEARCH;
+		if (mask & MAY_WRITE)
+			av |= DIR__WRITE;
+		if (mask & MAY_READ)
+			av |= DIR__READ;
+	}
+
+	return av;
+}
+
+#endif
diff -uprN -b -B ./pristine/linux-4.9.5/security/provenance/include/provenance_cgroup.h ./linux-4.9.5/security/provenance/include/provenance_cgroup.h
--- ./pristine/linux-4.9.5/security/provenance/include/provenance_cgroup.h	1970-01-01 01:00:00.000000000 +0100
+++ ./linux-4.9.5/security/provenance/include/provenance_cgroup.h	2017-01-23 19:44:14.819585136 +0100
@@ -0,0 +1,66 @@
+/*
+ *
+ * Author: Thomas Pasquier <tfjmp@seas.harvard.edu>
+ *
+ * Copyright (C) 2017 Harvard University
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2, as
+ * published by the Free Software Foundation; either version 2 of the License, or
+ *	(at your option) any later version.
+ *
+ */
+#ifndef CONFIG_SECURITY_PROVENANCE_CGROUP
+#define CONFIG_SECURITY_PROVENANCE_CGROUP
+
+struct cgroup_filters {
+	struct list_head list;
+	struct cgroupinfo filter;
+};
+
+extern struct cgroup_filters cgroup_filters;
+
+static inline uint8_t prov_cgroup_whichOP(struct cgroup_filters *filters, uint32_t cid)
+{
+	struct cgroup_filters *tmp;
+
+	list_for_each_entry(tmp, &(filters->list), list) {
+		if (tmp->filter.cid == cid)
+			return tmp->filter.op;
+	}
+	return 0; // do nothing
+}
+
+static inline uint8_t prov_cgroup_delete(struct cgroup_filters *filters, struct cgroup_filters *f)
+{
+	struct list_head *pos, *q;
+	struct cgroup_filters *tmp;
+
+	list_for_each_safe(pos, q, &(filters->list)) {
+		tmp = list_entry(pos, struct cgroup_filters, list);
+		if (tmp->filter.cid == f->filter.cid) {
+			list_del(pos);
+			kfree(tmp);
+			return 0; // you should only get one
+		}
+	}
+	return 0; // do nothing
+}
+
+static inline uint8_t prov_cgroup_add_or_update(struct cgroup_filters *filters, struct cgroup_filters *f)
+{
+	struct list_head *pos, *q;
+	struct cgroup_filters *tmp;
+
+	list_for_each_safe(pos, q, &(filters->list)) {
+		tmp = list_entry(pos, struct cgroup_filters, list);
+		if (tmp->filter.cid == f->filter.cid) {
+			tmp->filter.op = f->filter.op;
+			return 0; // you should only get one
+		}
+	}
+	list_add_tail(&(f->list), &(filters->list)); // not already on the list, we add it
+	return 0;
+}
+
+#endif
diff -uprN -b -B ./pristine/linux-4.9.5/security/provenance/include/provenance_filter.h ./linux-4.9.5/security/provenance/include/provenance_filter.h
--- ./pristine/linux-4.9.5/security/provenance/include/provenance_filter.h	1970-01-01 01:00:00.000000000 +0100
+++ ./linux-4.9.5/security/provenance/include/provenance_filter.h	2017-01-23 19:44:14.817585121 +0100
@@ -0,0 +1,90 @@
+/*
+ *
+ * Author: Thomas Pasquier <tfjmp@seas.harvard.edu>
+ *
+ * Copyright (C) 2016 Harvard University
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2, as
+ * published by the Free Software Foundation; either version 2 of the License, or
+ *	(at your option) any later version.
+ *
+ */
+#ifndef _LINUX_PROVENANCE_FILTER_H
+#define _LINUX_PROVENANCE_FILTER_H
+
+#include <uapi/linux/provenance.h>
+
+extern bool prov_enabled;
+extern bool prov_all;
+
+#define HIT_FILTER(filter, data) ((filter & data) != 0)
+
+extern uint64_t prov_node_filter;
+extern uint64_t prov_propagate_node_filter;
+
+#define filter_node(node) __filter_node(prov_node_filter, node)
+#define filter_propagate_node(node) __filter_node(prov_propagate_node_filter, node)
+
+/* return either or not the node should be filtered out */
+static inline bool __filter_node(uint64_t filter, const prov_msg_t *node)
+{
+	if (!prov_enabled)
+		return true;
+	if (provenance_is_opaque(node))
+		return true;
+	// we hit an element of the black list ignore
+	if (HIT_FILTER(filter, node_identifier(node).type))
+		return true;
+	return false;
+}
+
+#define UPDATE_FILTER (SUBTYPE(RL_VERSION_PROCESS) | SUBTYPE(RL_VERSION) | SUBTYPE(RL_NAMED))
+static inline bool filter_update_node(uint64_t relation_type, prov_msg_t *to)
+{
+	if (HIT_FILTER(relation_type, UPDATE_FILTER)) // not update if relation is of above type
+		return true;
+	return false;
+}
+
+extern uint64_t prov_relation_filter;
+extern uint64_t prov_propagate_relation_filter;
+
+/* return either or not the relation should be filtered out */
+static inline bool filter_relation(uint64_t type, uint8_t allowed)
+{
+	if (allowed == FLOW_DISALLOWED && HIT_FILTER(prov_relation_filter, RL_DISALLOWED))
+		return true;
+	if (allowed == FLOW_ALLOWED && HIT_FILTER(prov_relation_filter, RL_ALLOWED))
+		return true;
+	// we hit an element of the black list ignore
+	if (HIT_FILTER(prov_relation_filter, type))
+		return true;
+	return false;
+}
+
+/* return either or not tracking should propagate */
+static inline bool filter_propagate_relation(uint64_t type, uint8_t allowed)
+{
+	if (allowed == FLOW_DISALLOWED && HIT_FILTER(prov_propagate_relation_filter, RL_DISALLOWED))
+		return true;
+	if (allowed == FLOW_ALLOWED && HIT_FILTER(prov_propagate_relation_filter, RL_ALLOWED))
+		return true;
+	// the relation does not allow tracking propagation
+	if (HIT_FILTER(prov_propagate_relation_filter, type))
+		return true;
+	return false;
+}
+
+static inline bool should_record_relation(uint64_t type, prov_msg_t *from, prov_msg_t *to, uint8_t allowed)
+{
+	// one of the node should not appear in the record, ignore the relation
+	if (filter_node(from) || filter_node(to))
+		return false;
+	// should the relation appear
+	if (filter_relation(type, allowed))
+		return false;
+	return true;
+}
+
+#endif
diff -uprN -b -B ./pristine/linux-4.9.5/security/provenance/include/provenance.h ./linux-4.9.5/security/provenance/include/provenance.h
--- ./pristine/linux-4.9.5/security/provenance/include/provenance.h	1970-01-01 01:00:00.000000000 +0100
+++ ./linux-4.9.5/security/provenance/include/provenance.h	2017-01-23 19:44:14.817585121 +0100
@@ -0,0 +1,215 @@
+/*
+ *
+ * Author: Thomas Pasquier <thomas.pasquier@cl.cam.ac.uk>
+ *
+ * Copyright (C) 2015 University of Cambridge
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2, as
+ * published by the Free Software Foundation; either version 2 of the License, or
+ *	(at your option) any later version.
+ *
+ */
+#ifndef _LINUX_PROVENANCE_H
+#define _LINUX_PROVENANCE_H
+
+#ifdef CONFIG_SECURITY_PROVENANCE
+
+#include <linux/slab.h>
+#include <linux/types.h>
+#include <linux/bug.h>
+#include <linux/socket.h>
+#include <uapi/linux/mman.h>
+#include <uapi/linux/camflow.h>
+#include <uapi/linux/provenance.h>
+#include <uapi/linux/stat.h>
+#include <linux/fs.h>
+#include <linux/mm.h>
+
+#include "provenance_filter.h"
+#include "provenance_relay.h"
+
+#define prov_next_relation_id() ((uint64_t)atomic64_inc_return(&prov_relation_id))
+#define prov_next_node_id() ((uint64_t)atomic64_inc_return(&prov_node_id))
+
+extern atomic64_t prov_relation_id;
+extern atomic64_t prov_node_id;
+extern struct kmem_cache *provenance_cache;
+
+enum {
+	PROVENANCE_LOCK_TASK,
+	PROVENANCE_LOCK_DIR,
+	PROVENANCE_LOCK_INODE,
+	PROVENANCE_LOCK_MSG,
+	PROVENANCE_LOCK_SHM,
+};
+
+struct provenance {
+	prov_msg_t msg;
+	spinlock_t lock;
+	uint8_t updt_mmap;
+	uint8_t has_mmap;
+};
+
+#define prov_msg(provenance) (&(provenance->msg))
+#define prov_lock(provenance) (&(provenance->lock))
+
+#define ASSIGN_NODE_ID 0
+extern uint32_t prov_machine_id;
+extern uint32_t prov_boot_id;
+
+static inline struct provenance *alloc_provenance(uint64_t ntype, gfp_t gfp)
+{
+	struct provenance *prov =  kmem_cache_zalloc(provenance_cache, gfp);
+
+	if (!prov)
+		return NULL;
+	spin_lock_init(prov_lock(prov));
+	prov_type(prov_msg(prov)) = ntype;
+	node_identifier(prov_msg(prov)).id = prov_next_node_id();
+	node_identifier(prov_msg(prov)).boot_id = prov_boot_id;
+	node_identifier(prov_msg(prov)).machine_id = prov_machine_id;
+	return prov;
+}
+
+static inline void free_provenance(struct provenance *prov)
+{
+	kmem_cache_free(provenance_cache, prov);
+}
+
+static inline void copy_node_info(prov_identifier_t *dest, prov_identifier_t *src)
+{
+	memcpy(dest, src, sizeof(prov_identifier_t));
+}
+
+static inline void __record_node(prov_msg_t *node)
+{
+	if (filter_node(node) || provenance_is_recorded(node)) // filtered or already recorded
+		return;
+
+	set_recorded(node);
+	if (unlikely(node_identifier(node).machine_id != prov_machine_id))
+		node_identifier(node).machine_id = prov_machine_id;
+	prov_write(node);
+}
+
+static inline void __record_relation(uint64_t type,
+				     prov_identifier_t *from,
+				     prov_identifier_t *to,
+				     prov_msg_t *relation,
+				     uint8_t allowed,
+				     struct file *file)
+{
+	prov_type(relation) = type;
+	relation_identifier(relation).id = prov_next_relation_id();
+	relation_identifier(relation).boot_id = prov_boot_id;
+	relation_identifier(relation).machine_id = prov_machine_id;
+	relation->relation_info.allowed = allowed;
+	copy_node_info(&relation->relation_info.snd, from);
+	copy_node_info(&relation->relation_info.rcv, to);
+	if (file != NULL) {
+		relation->relation_info.set = FILE_INFO_SET;
+		relation->relation_info.offset = file->f_pos;
+	}
+	prov_write(relation);
+}
+
+static inline void __update_version(uint64_t type, prov_msg_t *prov)
+{
+	prov_msg_t old_prov;
+	prov_msg_t relation;
+
+	if (filter_update_node(type, prov))
+		return;
+	memset(&relation, 0, sizeof(prov_msg_t));
+	memcpy(&old_prov, prov, sizeof(prov_msg_t));
+	node_identifier(prov).version++;
+	clear_recorded(prov);
+	if (node_identifier(prov).type == ACT_TASK)
+		__record_relation(RL_VERSION_PROCESS, &(old_prov.msg_info.identifier), &(prov->msg_info.identifier), &relation, FLOW_ALLOWED, NULL);
+	else
+		__record_relation(RL_VERSION, &(old_prov.msg_info.identifier), &(prov->msg_info.identifier), &relation, FLOW_ALLOWED, NULL);
+}
+
+static inline void __propagate(uint64_t type,
+			       prov_msg_t *from,
+			       prov_msg_t *to,
+			       prov_msg_t *relation,
+			       uint8_t allowed)
+{
+
+	if (!provenance_does_propagate(from))
+		return;
+	if (filter_propagate_node(to))
+		return;
+	if (filter_propagate_relation(type, allowed))   // is it filtered
+		return;
+	set_tracked(to);                                // receiving node become tracked
+	set_propagate(to);                              // continue to propagate
+	if (!prov_bloom_empty(prov_taint(from))) {
+		prov_bloom_merge(prov_taint(to), prov_taint(from));
+		prov_bloom_merge(prov_taint(relation), prov_taint(from));
+	}
+}
+
+static inline void record_relation(uint64_t type,
+				   prov_msg_t *from,
+				   prov_msg_t *to,
+				   uint8_t allowed,
+				   struct file *file)
+{
+	prov_msg_t relation;
+
+	if (!provenance_is_tracked(from) && !provenance_is_tracked(to) && !prov_all)
+		return;
+	if (!should_record_relation(type, from, to, allowed))
+		return;
+	memset(&relation, 0, sizeof(prov_msg_t));
+	__record_node(from);
+	__propagate(type, from, to, &relation, allowed);
+	__record_node(to);
+	__update_version(type, to);
+	__record_node(to);
+	__record_relation(type, &(from->msg_info.identifier), &(to->msg_info.identifier), &relation, allowed, file);
+}
+
+static inline void flow_to_activity(uint64_t type,
+				    struct provenance *from,
+				    struct provenance *to,
+				    uint8_t allowed,
+				    struct file *file)
+{
+	record_relation(type, prov_msg(from), prov_msg(to), allowed, file);
+	if (should_record_relation(type, prov_msg(from), prov_msg(to), allowed))
+		to->updt_mmap = 1;
+}
+
+static inline void flow_from_activity(uint64_t type,
+				      struct provenance *from,
+				      struct provenance *to,
+				      uint8_t allowed,
+				      struct file *file)
+{
+	record_relation(type, prov_msg(from), prov_msg(to), allowed, file);
+}
+
+static inline void flow_between_entities(uint64_t type,
+					 struct provenance *from,
+					 struct provenance *to,
+					 uint8_t allowed,
+					 struct file *file)
+{
+	record_relation(type, prov_msg(from), prov_msg(to), allowed, file);
+}
+
+static inline void flow_between_activities(uint64_t type,
+					   struct provenance *from,
+					   struct provenance *to,
+					   uint8_t allowed,
+					   struct file *file)
+{
+	record_relation(type, prov_msg(from), prov_msg(to), allowed, file);
+}
+
+#endif
+#endif /* _LINUX_PROVENANCE_H */
diff -uprN -b -B ./pristine/linux-4.9.5/security/provenance/include/provenance_inode.h ./linux-4.9.5/security/provenance/include/provenance_inode.h
--- ./pristine/linux-4.9.5/security/provenance/include/provenance_inode.h	1970-01-01 01:00:00.000000000 +0100
+++ ./linux-4.9.5/security/provenance/include/provenance_inode.h	2017-01-23 19:44:14.818585129 +0100
@@ -0,0 +1,142 @@
+/*
+ *
+ * Author: Thomas Pasquier <tfjmp@seas.harvard.edu>
+ *
+ * Copyright (C) 2016 Harvard University
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2, as
+ * published by the Free Software Foundation; either version 2 of the License, or
+ *	(at your option) any later version.
+ *
+ */
+#ifndef CONFIG_SECURITY_PROVENANCE_INODE
+#define CONFIG_SECURITY_PROVENANCE_INODE
+#include <linux/file.h>
+#include <linux/fs.h>
+#include <linux/namei.h>
+
+#include "provenance_long.h"    // for record_inode_name
+#include "provenance_secctx.h"  // for record_inode_name
+
+#define is_inode_dir(inode) S_ISDIR(inode->i_mode)
+#define is_inode_socket(inode) S_ISSOCK(inode->i_mode)
+#define is_inode_file(inode) S_ISREG(inode->i_mode)
+
+static inline struct inode *file_name_to_inode(const char *name)
+{
+	struct path path;
+	struct inode *inode;
+
+	if (kern_path(name, LOOKUP_FOLLOW, &path)) {
+		printk(KERN_ERR "Provenance: Failed file look up (%s).", name);
+		return NULL;
+	}
+	inode = path.dentry->d_inode;
+	path_put(&path);
+	return inode;
+}
+
+static inline void record_inode_type(uint16_t mode, struct provenance *prov)
+{
+	uint64_t type = ENT_INODE_UNKNOWN;
+
+	if (S_ISBLK(mode))
+		type = ENT_INODE_BLOCK;
+	else if (S_ISCHR(mode))
+		type = ENT_INODE_CHAR;
+	else if (S_ISDIR(mode))
+		type = ENT_INODE_DIRECTORY;
+	else if (S_ISFIFO(mode))
+		type = ENT_INODE_FIFO;
+	else if (S_ISLNK(mode))
+		type = ENT_INODE_LINK;
+	else if (S_ISREG(mode))
+		type = ENT_INODE_FILE;
+	else if (S_ISSOCK(mode))
+		type = ENT_INODE_SOCKET;
+	spin_lock_nested(prov_lock(prov), PROVENANCE_LOCK_INODE);
+	prov_msg(prov)->inode_info.mode = mode;
+	prov_type(prov_msg(prov)) = type;
+	spin_unlock(prov_lock(prov));
+}
+
+static inline void provenance_mark_as_opaque(const char *name)
+{
+	struct inode *in;
+	prov_msg_t *prov;
+
+	in = file_name_to_inode(name);
+	if (!in)
+		printk(KERN_ERR "Provenance: could not find %s file.", name);
+	else{
+		prov = in->i_provenance;
+		if (prov)
+			set_opaque(prov);
+	}
+}
+
+static inline struct provenance *inode_provenance(struct inode *inode)
+{
+	struct provenance *prov = inode->i_provenance;
+	uint8_t op;
+
+	record_inode_name(inode, prov);
+	record_inode_type(inode->i_mode, prov);
+	prov_msg(prov)->inode_info.uid = __kuid_val(inode->i_uid);
+	prov_msg(prov)->inode_info.gid = __kgid_val(inode->i_gid);
+	security_inode_getsecid(inode, &(prov_msg(prov)->inode_info.secid));
+	op = prov_secctx_whichOP(&secctx_filters, prov_msg(prov)->inode_info.secid);
+	if (unlikely(op != 0)) {
+		if ((op & PROV_SEC_TRACKED) != 0)
+			set_tracked(prov_msg(prov));
+		if ((op & PROV_SEC_PROPAGATE) != 0)
+			set_propagate(prov_msg(prov));
+	}
+	return prov;
+}
+
+static inline struct provenance *dentry_provenance(struct dentry *dentry)
+{
+	struct inode *inode = d_backing_inode(dentry);
+
+	if (inode == NULL)
+		return NULL;
+	return inode_provenance(inode);
+}
+
+static inline struct provenance *file_provenance(struct file *file)
+{
+	struct inode *inode = file_inode(file);
+
+	if (inode == NULL)
+		return NULL;
+	return inode_provenance(inode);
+}
+
+static inline struct provenance *branch_mmap(prov_msg_t *iprov, prov_msg_t *cprov)
+{
+	//used for private MMAP
+	struct provenance *prov;
+	prov_msg_t relation;
+
+	if (unlikely(iprov == NULL || cprov == NULL)) // should not occur
+		return NULL;
+	if (!provenance_is_tracked(iprov) && !provenance_is_tracked(cprov) && !prov_all)
+		return NULL;
+	if (!should_record_relation(RL_MMAP, cprov, iprov, FLOW_ALLOWED))
+		return NULL;
+	prov = alloc_provenance(ENT_INODE_MMAP, GFP_KERNEL);
+
+	prov_msg(prov)->inode_info.uid = iprov->inode_info.uid;
+	prov_msg(prov)->inode_info.gid = iprov->inode_info.gid;
+	memcpy(prov_msg(prov)->inode_info.sb_uuid, iprov->inode_info.sb_uuid, 16 * sizeof(uint8_t));
+	prov_msg(prov)->inode_info.mode = iprov->inode_info.mode;
+	__record_node(iprov);
+	memset(&relation, 0, sizeof(prov_msg_t));
+	__propagate(RL_MMAP, iprov, prov_msg(prov), &relation, FLOW_ALLOWED);
+	__record_node(prov_msg(prov));
+	__record_relation(RL_MMAP, &(iprov->msg_info.identifier), &(prov_msg(prov)->msg_info.identifier), &relation, FLOW_ALLOWED, NULL);
+	return prov;
+}
+#endif
diff -uprN -b -B ./pristine/linux-4.9.5/security/provenance/include/provenance_long.h ./linux-4.9.5/security/provenance/include/provenance_long.h
--- ./pristine/linux-4.9.5/security/provenance/include/provenance_long.h	1970-01-01 01:00:00.000000000 +0100
+++ ./linux-4.9.5/security/provenance/include/provenance_long.h	2017-01-23 19:44:14.819585136 +0100
@@ -0,0 +1,247 @@
+/*
+ *
+ * Author: Thomas Pasquier <tfjmp@seas.harvard.edu>
+ *
+ * Copyright (C) 2016 Harvard University
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2, as
+ * published by the Free Software Foundation; either version 2 of the License, or
+ *	(at your option) any later version.
+ *
+ */
+#ifndef _LINUX_PROVENANCE_LONG_H
+#define _LINUX_PROVENANCE_LONG_H
+
+#include <linux/file.h>
+#include <uapi/linux/provenance.h>
+
+#include "provenance_net.h"
+
+extern uint32_t prov_machine_id;
+extern uint32_t prov_boot_id;
+
+static long_prov_msg_t *alloc_long_provenance(uint64_t ntype)
+{
+	long_prov_msg_t *tmp = kzalloc(sizeof(long_prov_msg_t), GFP_ATOMIC);
+	if(!tmp)
+		return NULL;
+
+	prov_type(tmp) = ntype;
+	node_identifier(tmp).id = prov_next_node_id();
+	node_identifier(tmp).boot_id = prov_boot_id;
+	node_identifier(tmp).machine_id = prov_machine_id;
+	return tmp;
+}
+
+static inline void __long_record_node(long_prov_msg_t *node)
+{
+	if (provenance_is_recorded(node))
+		return;
+	set_recorded(node);
+	long_prov_write(node);
+}
+
+static inline void __long_record_relation(uint64_t type, long_prov_msg_t *from, prov_msg_t *to, uint8_t allowed)
+{
+	prov_msg_t relation;
+
+	if (unlikely(!prov_enabled)) // capture is not enabled, ignore
+		return;
+	// don't record if to or from are opaque
+	if (unlikely(provenance_is_opaque(to)))
+		return;
+	__long_record_node(from);
+	__record_node(to);
+	memset(&relation, 0, sizeof(prov_msg_t));
+	__record_relation(type, &(from->msg_info.identifier), &(to->msg_info.identifier), &relation, allowed, NULL);
+}
+
+static inline int prov_print(const char *fmt, ...)
+{
+	long_prov_msg_t *msg = alloc_long_provenance(ENT_STR); // revert back to cache if causes performance issue
+	int length;
+	va_list args;
+
+	if(!msg)
+		return 0;
+	va_start(args, fmt);
+	msg->str_info.length = vscnprintf(msg->str_info.str, 4096, fmt, args);
+	long_prov_write(msg);
+	va_end(args);
+	length = msg->str_info.length;
+	kfree(msg);
+	return length;
+}
+
+static inline void __record_node_name(struct provenance *node, char *name)
+{
+	long_prov_msg_t *fname_prov;
+
+	fname_prov = alloc_long_provenance(ENT_FILE_NAME);
+	if(!fname_prov){
+		printk(KERN_ERR "Provenance: recod name failed to allocate memory\n");
+		return;
+	}
+	strlcpy(fname_prov->file_name_info.name, name, PATH_MAX);
+	fname_prov->file_name_info.length = strlen(fname_prov->file_name_info.name);
+	if (prov_type(prov_msg(node)) == ACT_TASK) {
+		spin_lock_nested(prov_lock(node), PROVENANCE_LOCK_TASK);
+		__long_record_relation(RL_NAMED_PROCESS, fname_prov, prov_msg(node), FLOW_ALLOWED);
+		set_name_recorded(prov_msg(node));
+		spin_unlock(prov_lock(node));
+	} else{
+		spin_lock_nested(prov_lock(node), PROVENANCE_LOCK_INODE);
+		__long_record_relation(RL_NAMED, fname_prov, prov_msg(node), FLOW_ALLOWED);
+		set_name_recorded(prov_msg(node));
+		spin_unlock(prov_lock(node));
+	}
+	kfree(fname_prov);
+}
+
+static inline void record_inode_name_from_dentry(struct dentry *dentry, struct provenance *prov)
+{
+	char *buffer;
+	char *ptr;
+
+	if (provenance_is_name_recorded(prov_msg(prov)) || !provenance_is_recorded(prov_msg(prov)))
+		return;
+	// should not sleep
+	buffer = kmalloc_array(PATH_MAX, sizeof(char), GFP_ATOMIC);
+	if(!buffer){
+		printk(KERN_ERR "Provenance: could not allocate memory\n");
+		return;
+	}
+	ptr = dentry_path_raw(dentry, buffer, PATH_MAX);
+	__record_node_name(prov, ptr);
+	kfree(buffer);
+}
+
+static inline void record_inode_name(struct inode *inode, struct provenance *prov)
+{
+	struct dentry *dentry;
+
+	if (provenance_is_name_recorded(prov_msg(prov)) || !provenance_is_recorded(prov_msg(prov)))
+		return;
+	dentry = d_find_alias(inode);
+	if (!dentry) // we did not find a dentry, not sure if it should ever happen
+		return;
+	record_inode_name_from_dentry(dentry, prov);
+	dput(dentry);
+}
+
+static inline void record_task_name(struct task_struct *task, struct provenance *prov)
+{
+	const struct cred *cred;
+	struct mm_struct *mm;
+	struct file *exe_file;
+	char *buffer;
+	char *ptr;
+
+	if (provenance_is_name_recorded(prov_msg(prov)) || !provenance_is_recorded(prov_msg(prov)))
+		return;
+	cred = get_task_cred(task);
+	if (!cred)
+		return;
+	mm = get_task_mm(task);
+	if (!mm)
+		goto out;
+	exe_file = get_mm_exe_file(mm);
+	mmput_async(mm);
+	if (exe_file) {
+		// should not sleep
+		buffer = kmalloc_array(PATH_MAX, sizeof(char), GFP_ATOMIC);
+		if(!buffer){
+			printk(KERN_ERR "Provenance: could not allocate memory\n");
+			fput(exe_file);
+			goto out;
+		}
+		ptr = file_path(exe_file, buffer, PATH_MAX);
+		fput(exe_file);
+		__record_node_name(prov, ptr);
+		kfree(buffer);
+	}
+out:
+	put_cred(cred);
+}
+
+static inline void provenance_record_address(struct sockaddr *address, int addrlen, struct provenance *prov)
+{
+	long_prov_msg_t *addr_info;
+
+	if (provenance_is_name_recorded(prov_msg(prov)) || !provenance_is_recorded(prov_msg(prov)))
+		return;
+	addr_info = alloc_long_provenance(ENT_ADDR);
+	if(!addr_info)
+		return;
+	addr_info->address_info.length = addrlen;
+	memcpy(&(addr_info->address_info.addr), address, addrlen);
+	__long_record_relation(RL_NAMED, addr_info, prov_msg(prov), FLOW_ALLOWED);
+	kfree(addr_info);
+	set_name_recorded(prov_msg(prov));
+}
+
+static inline void record_write_xattr(uint64_t type,
+				      prov_msg_t *iprov,
+				      prov_msg_t *cprov,
+				      const char *name,
+				      const void *value,
+				      size_t size,
+				      int flags,
+				      uint8_t allowed)
+{
+	long_prov_msg_t *xattr = alloc_long_provenance(ENT_XATTR);
+	prov_msg_t relation;
+
+	if(!xattr)
+		return;
+	memset(&relation, 0, sizeof(prov_msg_t));
+	memcpy(xattr->xattr_info.name, name, PROV_XATTR_NAME_SIZE - 1);
+	xattr->xattr_info.name[PROV_XATTR_NAME_SIZE - 1] = '\0';
+	if (value != NULL) {
+		if (size < PROV_XATTR_VALUE_SIZE) {
+			xattr->xattr_info.size = size;
+			memcpy(xattr->xattr_info.value, value, size);
+		} else{
+			xattr->xattr_info.size = PROV_XATTR_VALUE_SIZE;
+			memcpy(xattr->xattr_info.value, value, PROV_XATTR_VALUE_SIZE);
+		}
+		xattr->xattr_info.flags = flags;
+	}
+	__record_node(cprov);
+	__record_relation(type, &(cprov->msg_info.identifier), &(xattr->msg_info.identifier), &relation, allowed, NULL);
+	__update_version(type, iprov);
+	__long_record_relation(type, xattr, iprov, allowed);
+	kfree(xattr);
+}
+
+static inline void record_read_xattr(uint64_t type, prov_msg_t *cprov, prov_msg_t *iprov, const char *name, uint8_t allowed)
+{
+	long_prov_msg_t *xattr = alloc_long_provenance(ENT_XATTR);
+	prov_msg_t relation;
+
+	if(xattr)
+		return;
+	memset(&relation, 0, sizeof(prov_msg_t));
+	memcpy(xattr->xattr_info.name, name, PROV_XATTR_NAME_SIZE - 1);
+	xattr->xattr_info.name[PROV_XATTR_NAME_SIZE - 1] = '\0';
+	__record_node(iprov);
+	__record_relation(type, &(iprov->msg_info.identifier), &(xattr->msg_info.identifier), &relation, allowed, NULL);
+	__update_version(type, cprov);
+	__long_record_relation(type, xattr, cprov, allowed);
+	kfree(xattr);
+}
+
+static inline void record_packet_content(prov_msg_t *pck, const struct sk_buff *skb)
+{
+	long_prov_msg_t *cnt = alloc_long_provenance(ENT_PCKCNT);
+	cnt->pckcnt_info.length=skb_end_offset(skb);
+	if(cnt->pckcnt_info.length > PATH_MAX){
+		cnt->pckcnt_info.truncated=PROV_TRUNCATED;
+		memcpy(cnt->pckcnt_info.content, skb->head, PATH_MAX);
+	}else
+		memcpy(cnt->pckcnt_info.content, skb->head, cnt->pckcnt_info.length);
+	__long_record_node(cnt);
+	__long_record_relation(RL_READ, cnt, pck, FLOW_ALLOWED);
+}
+#endif
diff -uprN -b -B ./pristine/linux-4.9.5/security/provenance/include/provenance_net.h ./linux-4.9.5/security/provenance/include/provenance_net.h
--- ./pristine/linux-4.9.5/security/provenance/include/provenance_net.h	1970-01-01 01:00:00.000000000 +0100
+++ ./linux-4.9.5/security/provenance/include/provenance_net.h	2017-01-23 19:44:14.818585129 +0100
@@ -0,0 +1,200 @@
+/*
+ *
+ * Author: Thomas Pasquier <tfjmp@seas.harvard.edu>
+ *
+ * Copyright (C) 2016 Harvard University
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2, as
+ * published by the Free Software Foundation; either version 2 of the License, or
+ *	(at your option) any later version.
+ *
+ */
+#ifndef CONFIG_SECURITY_PROVENANCE_NET
+#define CONFIG_SECURITY_PROVENANCE_NET
+
+#include <net/sock.h>
+#include <net/ip.h>
+#include <linux/netfilter_ipv4.h>
+#include <linux/netfilter_ipv6.h>
+#include <linux/ip.h>
+#include <linux/tcp.h>
+#include <linux/udp.h>
+#include <linux/skbuff.h>
+
+#include "provenance.h"
+
+static inline struct provenance *socket_inode_provenance(struct socket *sock)
+{
+	struct provenance *iprov = SOCK_INODE(sock)->i_provenance;
+
+	return iprov;
+}
+
+static inline struct provenance *sk_inode_provenance(struct sock *sk)
+{
+	struct socket *sock = sk->sk_socket;
+
+	if (sock == NULL)
+		return NULL;
+	return socket_inode_provenance(sock);
+}
+
+static inline struct provenance *sk_provenance(struct sock *sk)
+{
+	struct provenance *prov = sk->sk_provenance;
+
+	return prov;
+}
+
+static inline unsigned int provenance_parse_skb_ipv4(struct sk_buff *skb, prov_msg_t *prov)
+{
+	struct packet_identifier *id;
+	int offset, ihlen;
+	struct iphdr _iph, *ih;
+	struct tcphdr _tcph, *th;
+	struct udphdr _udph, *uh;
+
+	offset = skb_network_offset(skb);
+	ih = skb_header_pointer(skb, offset, sizeof(_iph), &_iph); // we obtain the ip header
+	if (ih == NULL)
+		return -EINVAL;
+
+	ihlen = ih->ihl * 4; // header size
+	if (ihlen < sizeof(_iph))
+		return -EINVAL;
+
+	memset(prov, 0, sizeof(prov_msg_t));
+	id = &packet_identifier(prov); // we are going fo fill this
+
+	id->type = ENT_PACKET;
+	// collect IP element of prov identifier
+	id->id = ih->id;
+	id->snd_ip = ih->saddr;
+	id->rcv_ip = ih->daddr;
+	id->protocol = ih->protocol;
+	prov->pck_info.length = ih->tot_len;
+
+	// now we collect
+	switch (ih->protocol) {
+	case IPPROTO_TCP:
+		if (ntohs(ih->frag_off) & IP_OFFSET)
+			break;
+		offset += ihlen; //point to tcp packet
+		th = skb_header_pointer(skb, offset, sizeof(_tcph), &_tcph);
+		if (th == NULL)
+			break;
+		id->snd_port = th->source;
+		id->rcv_port = th->dest;
+		id->seq = th->seq;
+		break;
+	case IPPROTO_UDP:
+		if (ntohs(ih->frag_off) & IP_OFFSET)
+			break;
+		offset += ihlen; //point to tcp packet
+		uh = skb_header_pointer(skb, offset, sizeof(_udph), &_udph);
+		if (uh == NULL)
+			break;
+		id->snd_port = uh->source;
+		id->rcv_port = uh->dest;
+		break;
+	default:
+		break;
+	}
+	return 0;
+}
+
+struct ipv4_filters {
+	struct list_head list;
+	struct prov_ipv4_filter filter;
+};
+
+extern struct ipv4_filters ingress_ipv4filters;
+extern struct ipv4_filters egress_ipv4filters;
+
+#define prov_ipv4_ingressOP(ip, port) prov_ipv4_whichOP(&ingress_ipv4filters, ip, port)
+#define prov_ipv4_egressOP(ip, port) prov_ipv4_whichOP(&egress_ipv4filters, ip, port)
+
+static inline uint8_t prov_ipv4_whichOP(struct ipv4_filters *filters, uint32_t ip, uint32_t port)
+{
+	struct ipv4_filters *tmp;
+
+	list_for_each_entry(tmp, &(filters->list), list) {
+		if ((tmp->filter.mask & ip) == (tmp->filter.mask & tmp->filter.ip))     // ip match filter
+			if (tmp->filter.port == 0 || tmp->filter.port == port)          // any port or match
+				return tmp->filter.op;
+	}
+	return 0; // do nothing
+}
+
+static inline uint8_t prov_ipv4_delete(struct ipv4_filters *filters, struct ipv4_filters *f)
+{
+	struct list_head *pos, *q;
+	struct ipv4_filters *tmp;
+
+	list_for_each_safe(pos, q, &(filters->list)) {
+		tmp = list_entry(pos, struct ipv4_filters, list);
+		if (tmp->filter.mask == f->filter.mask &&
+		    tmp->filter.ip == f->filter.ip &&
+		    tmp->filter.port == f->filter.port) {
+			list_del(pos);
+			kfree(tmp);
+			return 0; // you should only get one
+		}
+	}
+	return 0; // do nothing
+}
+
+static inline uint8_t prov_ipv4_add_or_update(struct ipv4_filters *filters, struct ipv4_filters *f)
+{
+	struct list_head *pos, *q;
+	struct ipv4_filters *tmp;
+
+	list_for_each_safe(pos, q, &(filters->list)) {
+		tmp = list_entry(pos, struct ipv4_filters, list);
+		if (tmp->filter.mask == f->filter.mask &&
+		    tmp->filter.ip == f->filter.ip &&
+		    tmp->filter.port == f->filter.port) {
+			tmp->filter.op |= f->filter.op;
+			return 0; // you should only get one
+		}
+	}
+	list_add_tail(&(f->list), &filters->list); // not already on the list, we add it
+	return 0;
+}
+
+// incoming packet
+static inline void record_pck_to_inode(prov_msg_t *pck, prov_msg_t *inode)
+{
+	prov_msg_t relation;
+	if (unlikely(pck == NULL || inode == NULL)) // should not occur
+		return;
+	if (!provenance_is_tracked(inode) && !prov_all)
+		return;
+	if (!should_record_relation(RL_RCV_PACKET, pck, inode, FLOW_ALLOWED))
+		return;
+	memset(&relation, 0, sizeof(prov_msg_t));
+	prov_write(pck);
+	__record_node(inode);
+	__update_version(RL_RCV_PACKET, inode);
+	__record_node(inode);
+	__record_relation(RL_RCV_PACKET, &(pck->msg_info.identifier), &(inode->msg_info.identifier), &relation, FLOW_ALLOWED, NULL);
+}
+
+// outgoing packet
+static inline void record_inode_to_pck(prov_msg_t *inode, prov_msg_t *pck)
+{
+	prov_msg_t relation;
+
+	if (unlikely(pck == NULL || inode == NULL)) // should not occur
+		return;
+	if (!provenance_is_tracked(inode) && !prov_all)
+		return;
+	if (!should_record_relation(RL_SND_PACKET, inode, pck, FLOW_ALLOWED))
+		return;
+	memset(&relation, 0, sizeof(prov_msg_t));
+	__record_node(inode);
+	prov_write(pck);
+	__record_relation(RL_SND_PACKET, &(inode->msg_info.identifier), &(pck->msg_info.identifier), &relation, FLOW_ALLOWED, NULL);
+}
+#endif
diff -uprN -b -B ./pristine/linux-4.9.5/security/provenance/include/provenance_relay.h ./linux-4.9.5/security/provenance/include/provenance_relay.h
--- ./pristine/linux-4.9.5/security/provenance/include/provenance_relay.h	1970-01-01 01:00:00.000000000 +0100
+++ ./linux-4.9.5/security/provenance/include/provenance_relay.h	2017-01-23 19:44:14.818585129 +0100
@@ -0,0 +1,95 @@
+/*
+ *
+ * Author: Thomas Pasquier <tfjmp@seas.harvard.edu>
+ *
+ * Copyright (C) 2016 Harvard University
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2, as
+ * published by the Free Software Foundation; either version 2 of the License, or
+ *	(at your option) any later version.
+ *
+ */
+#ifndef _LINUX_PROVENANCE_RELAY_H
+#define _LINUX_PROVENANCE_RELAY_H
+
+#include <linux/relay.h>
+#include <linux/spinlock.h>
+#include <linux/jiffies.h>
+
+#include "provenance_filter.h"
+
+#define PROV_RELAY_BUFF_EXP         22 // 4MB
+#define PROV_RELAY_BUFF_SIZE        ((1 << PROV_RELAY_BUFF_EXP) * sizeof(uint8_t))
+#define PROV_NB_SUBBUF              32
+#define PROV_INITIAL_BUFF_SIZE      (1024 * 4)
+#define PROV_INITIAL_LONG_BUFF_SIZE 256
+
+extern bool relay_ready;
+
+struct prov_boot_buffer {
+	prov_msg_t buffer[PROV_INITIAL_BUFF_SIZE];
+	uint32_t nb_entry;
+};
+
+struct prov_long_boot_buffer {
+	long_prov_msg_t buffer[PROV_INITIAL_LONG_BUFF_SIZE];
+	uint32_t nb_entry;
+};
+
+extern struct prov_boot_buffer *boot_buffer;
+extern struct rchan *prov_chan;
+extern spinlock_t prov_chan_lock;
+
+static inline void prov_write(prov_msg_t *msg)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&prov_chan_lock, flags);
+	prov_jiffies(msg) = get_jiffies_64();
+	if (unlikely(!relay_ready)) {
+		if (likely(boot_buffer->nb_entry < PROV_INITIAL_BUFF_SIZE)) {
+			memcpy(&(boot_buffer->buffer[boot_buffer->nb_entry]), msg, sizeof(prov_msg_t));
+			boot_buffer->nb_entry++;
+		} else
+			printk(KERN_ERR "Provenance: boot buffer is full.\n");
+	} else
+		relay_write(prov_chan, msg, sizeof(prov_msg_t));
+	spin_unlock_irqrestore(&prov_chan_lock, flags);
+}
+
+
+extern struct prov_long_boot_buffer *long_boot_buffer;
+extern struct rchan *long_prov_chan;
+extern spinlock_t long_prov_chan_lock;
+
+static inline void long_prov_write(long_prov_msg_t *msg)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&long_prov_chan_lock, flags);
+	prov_jiffies(msg) = get_jiffies_64();
+	if (unlikely(!relay_ready)) {
+		if (likely(long_boot_buffer->nb_entry < PROV_INITIAL_LONG_BUFF_SIZE))
+			memcpy(&long_boot_buffer->buffer[long_boot_buffer->nb_entry++], msg, sizeof(long_prov_msg_t));
+		else
+			printk(KERN_ERR "Provenance: long boot buffer is full.\n");
+	} else
+		relay_write(long_prov_chan, msg, sizeof(long_prov_msg_t));
+	spin_unlock_irqrestore(&long_prov_chan_lock, flags);
+}
+
+/* force sub-buffer switch */
+static inline void prov_flush(void)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&prov_chan_lock, flags);
+	relay_flush(prov_chan);
+	spin_unlock_irqrestore(&prov_chan_lock, flags);
+	spin_lock_irqsave(&long_prov_chan_lock, flags);
+	relay_flush(long_prov_chan);
+	spin_unlock_irqrestore(&long_prov_chan_lock, flags);
+}
+
+#endif
diff -uprN -b -B ./pristine/linux-4.9.5/security/provenance/include/provenance_secctx.h ./linux-4.9.5/security/provenance/include/provenance_secctx.h
--- ./pristine/linux-4.9.5/security/provenance/include/provenance_secctx.h	1970-01-01 01:00:00.000000000 +0100
+++ ./linux-4.9.5/security/provenance/include/provenance_secctx.h	2017-01-23 19:44:14.820585144 +0100
@@ -0,0 +1,66 @@
+/*
+ *
+ * Author: Thomas Pasquier <tfjmp@seas.harvard.edu>
+ *
+ * Copyright (C) 2016 Harvard University
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2, as
+ * published by the Free Software Foundation; either version 2 of the License, or
+ *	(at your option) any later version.
+ *
+ */
+#ifndef CONFIG_SECURITY_PROVENANCE_SECCTX
+#define CONFIG_SECURITY_PROVENANCE_SECCTX
+
+struct secctx_filters {
+	struct list_head list;
+	struct secinfo filter;
+};
+
+extern struct secctx_filters secctx_filters;
+
+static inline uint8_t prov_secctx_whichOP(struct secctx_filters *filters, uint32_t secid)
+{
+	struct secctx_filters *tmp;
+
+	list_for_each_entry(tmp, &(filters->list), list) {
+		if (tmp->filter.secid == secid)
+			return tmp->filter.op;
+	}
+	return 0; // do nothing
+}
+
+static inline uint8_t prov_secctx_delete(struct secctx_filters *filters, struct secctx_filters  *f)
+{
+	struct list_head *pos, *q;
+	struct secctx_filters *tmp;
+
+	list_for_each_safe(pos, q, &(filters->list)) {
+		tmp = list_entry(pos, struct secctx_filters, list);
+		if (tmp->filter.secid == f->filter.secid) {
+			list_del(pos);
+			kfree(tmp);
+			return 0; // you should only get one
+		}
+	}
+	return 0; // do nothing
+}
+
+static inline uint8_t prov_secctx_add_or_update(struct secctx_filters *filters, struct secctx_filters   *f)
+{
+	struct list_head *pos, *q;
+	struct secctx_filters *tmp;
+
+	list_for_each_safe(pos, q, &(filters->list)) {
+		tmp = list_entry(pos, struct secctx_filters, list);
+		if (tmp->filter.secid == f->filter.secid) {
+			tmp->filter.op = f->filter.op;
+			return 0; // you should only get one
+		}
+	}
+	list_add_tail(&(f->list), &(filters->list)); // not already on the list, we add it
+	return 0;
+}
+
+#endif
diff -uprN -b -B ./pristine/linux-4.9.5/security/provenance/include/provenance_task.h ./linux-4.9.5/security/provenance/include/provenance_task.h
--- ./pristine/linux-4.9.5/security/provenance/include/provenance_task.h	1970-01-01 01:00:00.000000000 +0100
+++ ./linux-4.9.5/security/provenance/include/provenance_task.h	2017-01-23 19:44:14.817585121 +0100
@@ -0,0 +1,179 @@
+/*
+ *
+ * Author: Thomas Pasquier <tfjmp@seas.harvard.edu>
+ *
+ * Copyright (C) 2016 Harvard University
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2, as
+ * published by the Free Software Foundation; either version 2 of the License, or
+ *	(at your option) any later version.
+ *
+ */
+#ifndef CONFIG_SECURITY_PROVENANCE_TASK
+#define CONFIG_SECURITY_PROVENANCE_TASK
+
+#include <linux/cred.h>
+#include <linux/binfmts.h>
+#include <linux/sched.h>
+
+#include "provenance_long.h"
+#include "provenance_secctx.h"
+#include "provenance_cgroup.h"
+#include "provenance_inode.h"
+
+#define current_pid() (current->pid)
+static inline uint32_t current_cid(void)
+{
+	uint32_t cid = 0;
+	struct cgroup_namespace *cns;
+
+	task_lock(current);
+	if (current->nsproxy != NULL) {
+		cns = current->nsproxy->cgroup_ns;
+		if (cns != NULL) {
+			get_cgroup_ns(cns);
+			cid = cns->ns.inum;
+			put_cgroup_ns(cns);
+		}
+	}
+	task_unlock(current);
+	return cid;
+}
+
+#define vm_write(flags)   ((flags & VM_WRITE) == VM_WRITE)
+#define vm_read(flags)    ((flags & VM_READ) == VM_READ)
+#define vm_exec(flags)    ((flags & VM_EXEC) == VM_EXEC)
+#define vm_mayshare(flags) ((flags & (VM_SHARED | VM_MAYSHARE)) != 0)
+#define vm_write_mayshare(flags) (vm_write(flags) && vm_mayshare(flags))
+#define vm_read_exec_mayshare(flags) ((vm_write(flags) || vm_exec(flags)) && vm_mayshare(flags))
+
+
+static inline void current_update_shst(struct provenance *cprov)
+{
+	struct mm_struct *mm = get_task_mm(current);
+	struct vm_area_struct *vma;
+	struct file *mmapf;
+	vm_flags_t flags;
+	struct provenance *mmprov;
+
+	if (!mm)
+		return;
+	cprov->has_mmap = 0;
+	vma = mm->mmap;
+	while (vma) { // we go through mmaped files
+		mmapf = vma->vm_file;
+		if (mmapf) {
+			flags = vma->vm_flags;
+			mmprov = file_inode(mmapf)->i_provenance;
+			if (mmprov) {
+				cprov->has_mmap = 1;
+				spin_lock_nested(prov_lock(mmprov), PROVENANCE_LOCK_INODE);
+				if (vm_read_exec_mayshare(flags))
+					record_relation(RL_SH_READ, prov_msg(mmprov), prov_msg(cprov), FLOW_ALLOWED, NULL);
+				if (vm_write_mayshare(flags))
+					record_relation(RL_SH_WRITE, prov_msg(cprov), prov_msg(mmprov), FLOW_ALLOWED, NULL);
+				spin_unlock(prov_lock(mmprov));
+			}
+		}
+		vma = vma->vm_next;
+	}
+	mmput_async(mm);
+}
+
+
+static inline void refresh_current_provenance(void)
+{
+	struct provenance *prov = current_provenance();
+	uint32_t cid = current_cid();
+	uint8_t op;
+
+	spin_lock_nested(prov_lock(prov), PROVENANCE_LOCK_TASK);
+	if (unlikely(prov_msg(prov)->task_info.pid == 0))
+		prov_msg(prov)->task_info.pid = task_pid_nr(current);
+	if (unlikely(prov_msg(prov)->task_info.vpid == 0))
+		prov_msg(prov)->task_info.vpid = task_pid_vnr(current);
+	if (unlikely(prov_msg(prov)->task_info.cid != cid))
+		prov_msg(prov)->task_info.cid = cid;
+	security_task_getsecid(current, &(prov_msg(prov)->task_info.secid));
+	op = prov_secctx_whichOP(&secctx_filters, prov_msg(prov)->task_info.secid);
+	if (unlikely(op != 0)) {
+		if ((op & PROV_SEC_TRACKED) != 0)
+			set_tracked(prov_msg(prov));
+		if ((op & PROV_SEC_PROPAGATE) != 0)
+			set_propagate(prov_msg(prov));
+	}
+	op = prov_cgroup_whichOP(&cgroup_filters, prov_msg(prov)->task_info.cid);
+	if (unlikely(op != 0)) {
+		if ((op & PROV_CGROUP_TRACKED) != 0)
+			set_tracked(prov_msg(prov));
+		if ((op & PROV_CGROUP_PROPAGATE) != 0)
+			set_propagate(prov_msg(prov));
+	}
+	if (prov->updt_mmap && prov->has_mmap) {
+		current_update_shst(prov);
+		prov->updt_mmap = 0;
+	}
+	spin_unlock(prov_lock(prov));
+	record_task_name(current, prov);
+}
+
+static inline struct provenance *prov_from_vpid(pid_t pid)
+{
+	struct provenance *tprov;
+	struct task_struct *dest = find_task_by_vpid(pid);
+
+	if (!dest)
+		return NULL;
+
+	tprov = __task_cred(dest)->provenance;
+	if (!tprov)
+		return NULL;
+	return tprov;
+}
+
+static inline struct provenance *get_current_provenance(void)
+{
+	refresh_current_provenance();
+	return current_provenance();
+}
+
+/*
+   static inline void current_config_from_file(struct task_struct *task){
+        const struct cred *cred = get_task_cred(task);
+        struct mm_struct *mm;
+        struct file *exe_file;
+        struct inode *inode;
+        prov_msg_t* tprov;
+        prov_msg_t* iprov;
+
+        if(!cred)
+                return;
+
+        tprov = cred->provenance;
+
+        mm = get_task_mm(task);
+        if (!mm)
+                goto finished;
+        exe_file = get_mm_exe_file(mm);
+        mmput(mm);
+
+        if(exe_file){
+                inode = file_inode(exe_file);
+                iprov = inode_provenance(inode);
+                if(provenance_is_tracked(iprov)){
+                        set_tracked(tprov);
+                }
+                if(provenance_is_opaque(iprov)){
+                        set_opaque(tprov);
+                }
+                if(provenance_does_propagate(iprov)){
+                        set_propagate(tprov);
+                }
+        }
+
+   finished:
+        put_cred(cred);
+   }
+ */
+#endif
diff -uprN -b -B ./pristine/linux-4.9.5/security/provenance/Kconfig ./linux-4.9.5/security/provenance/Kconfig
--- ./pristine/linux-4.9.5/security/provenance/Kconfig	1970-01-01 01:00:00.000000000 +0100
+++ ./linux-4.9.5/security/provenance/Kconfig	2017-01-23 19:44:14.814585098 +0100
@@ -0,0 +1,18 @@
+config SECURITY_PROVENANCE
+         bool "CamFlow - Provenance"
+         depends on SECURITY
+         select RELAY
+         select SECURITYFS
+         default y
+         help
+          This selects CamFlow provenance modules. It captures provenance through
+          a Linux Security Module.
+
+config SECURITY_PROVENANCE_WHOLE_SYSTEM
+	bool "CamFlow - Whole system provenance"
+	depends on SECURITY_PROVENANCE
+	default n
+	help
+	  This option activate whole system provenance capture from boot.
+
+	  If you are unsure how to answer this question, answer N.
diff -uprN -b -B ./pristine/linux-4.9.5/security/provenance/Makefile ./linux-4.9.5/security/provenance/Makefile
--- ./pristine/linux-4.9.5/security/provenance/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ ./linux-4.9.5/security/provenance/Makefile	2017-01-23 19:44:14.814585098 +0100
@@ -0,0 +1,8 @@
+#
+# Makefile for Provenance LSM
+#
+obj-$(CONFIG_SECURITY_PROVENANCE) := provenance.o
+
+provenance-y := relay.o hooks.o fs.o netfilter.o
+
+ccflags-y := -I$(srctree)/security/provenance/include
diff -uprN -b -B ./pristine/linux-4.9.5/security/provenance/netfilter.c ./linux-4.9.5/security/provenance/netfilter.c
--- ./pristine/linux-4.9.5/security/provenance/netfilter.c	1970-01-01 01:00:00.000000000 +0100
+++ ./linux-4.9.5/security/provenance/netfilter.c	2017-01-23 19:44:14.815585106 +0100
@@ -0,0 +1,71 @@
+/*
+ *
+ * Author: Thomas Pasquier <tfjmp@seas.harvard.edu>
+ *
+ * Copyright (C) 2016 Havard University
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2, as
+ * published by the Free Software Foundation; either version 2 of the License, or
+ *	(at your option) any later version.
+ *
+ */
+
+#if defined(CONFIG_NETFILTER)
+
+#include "provenance.h"
+#include "provenance_net.h"
+#include "provenance_task.h"
+
+static inline unsigned int __ipv4_out(struct sk_buff *skb)
+{
+	struct provenance *cprov = current_provenance();
+	struct provenance *iprov = NULL;
+	prov_msg_t pckprov;
+
+	if (cprov == NULL)
+		return NF_ACCEPT;
+
+	if (provenance_is_tracked(prov_msg(cprov))) {
+		iprov = sk_inode_provenance(skb->sk);
+		if (iprov == NULL)
+			return NF_ACCEPT;
+		provenance_parse_skb_ipv4(skb, &pckprov);
+		record_inode_to_pck(prov_msg(iprov), &pckprov);
+		if(provenance_records_packet(prov_msg(iprov)))
+			record_packet_content(&pckprov, skb);
+	}
+	return NF_ACCEPT;
+}
+
+static unsigned int provenance_ipv4_out(void *priv,
+					struct sk_buff *skb,
+					const struct nf_hook_state *state)
+{
+	return __ipv4_out(skb);
+}
+
+static struct nf_hook_ops provenance_nf_ops[] = {
+	{
+		.hook = provenance_ipv4_out,
+		.pf = NFPROTO_IPV4,
+		.hooknum = NF_INET_LOCAL_OUT,
+		.priority = NF_IP_PRI_LAST,
+	},
+};
+
+// will initialise the hooks
+static int __init provenance_nf_init(void)
+{
+	int err;
+
+	err = nf_register_hooks(provenance_nf_ops, ARRAY_SIZE(provenance_nf_ops));
+	if (err)
+		panic("Provenance: nf_register_hooks: error %d\n", err);
+
+	printk(KERN_INFO "Provenance netfilter ready.\n");
+
+	return 0;
+}
+module_init(provenance_nf_init);
+#endif
diff -uprN -b -B ./pristine/linux-4.9.5/security/provenance/relay.c ./linux-4.9.5/security/provenance/relay.c
--- ./pristine/linux-4.9.5/security/provenance/relay.c	1970-01-01 01:00:00.000000000 +0100
+++ ./linux-4.9.5/security/provenance/relay.c	2017-01-23 19:44:14.816585113 +0100
@@ -0,0 +1,95 @@
+/*
+ *
+ * Author: Thomas Pasquier <thomas.pasquier@cl.cam.ac.uk>
+ *
+ * Copyright (C) 2015 University of Cambridge
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2, as
+ * published by the Free Software Foundation; either version 2 of the License, or
+ *	(at your option) any later version.
+ *
+ */
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/debugfs.h>
+
+#include "provenance.h"
+
+#define PROV_BASE_NAME "provenance"
+#define LONG_PROV_BASE_NAME "long_provenance"
+
+/* global variable, extern in provenance.h */
+struct rchan *prov_chan = NULL;
+struct rchan *long_prov_chan = NULL;
+atomic64_t prov_relation_id = ATOMIC64_INIT(0);
+atomic64_t prov_node_id = ATOMIC64_INIT(0);
+
+/*
+ * create_buf_file() callback.  Creates relay file in debugfs.
+ */
+static struct dentry *create_buf_file_handler(const char *filename,
+					      struct dentry *parent,
+					      umode_t mode,
+					      struct rchan_buf *buf,
+					      int *is_global)
+{
+	return debugfs_create_file(filename, mode, parent, buf,
+				   &relay_file_operations);
+}
+
+/*
+ * remove_buf_file() callback.  Removes relay file from debugfs.
+ */
+static int remove_buf_file_handler(struct dentry *dentry)
+{
+	debugfs_remove(dentry);
+	return 0;
+}
+
+/*
+ * relay interface callbacks
+ */
+static struct rchan_callbacks relay_callbacks = {
+
+	.create_buf_file	= create_buf_file_handler,
+	.remove_buf_file	= remove_buf_file_handler,
+};
+
+DEFINE_SPINLOCK(prov_chan_lock);
+DEFINE_SPINLOCK(long_prov_chan_lock);
+
+static void write_boot_buffer(void)
+{
+	if (boot_buffer->nb_entry > 0)
+		relay_write(prov_chan, boot_buffer->buffer, boot_buffer->nb_entry * sizeof(prov_msg_t));
+	kfree(boot_buffer);
+	boot_buffer = NULL;
+
+	if (long_boot_buffer->nb_entry > 0)
+		relay_write(long_prov_chan, long_boot_buffer->buffer, long_boot_buffer->nb_entry * sizeof(long_prov_msg_t));
+	kfree(long_boot_buffer);
+	long_boot_buffer = NULL;
+}
+
+bool relay_ready;
+
+static int __init relay_prov_init(void)
+{
+	prov_chan = relay_open(PROV_BASE_NAME, NULL, PROV_RELAY_BUFF_SIZE, PROV_NB_SUBBUF, &relay_callbacks, NULL);
+	if (prov_chan == NULL)
+		panic("Provenance: relay_open failure\n");
+
+	long_prov_chan = relay_open(LONG_PROV_BASE_NAME, NULL, PROV_RELAY_BUFF_SIZE, PROV_NB_SUBBUF, &relay_callbacks, NULL);
+	if (long_prov_chan == NULL)
+		panic("Provenance: relay_open failure\n");
+	relay_ready=true;
+	// relay buffer are ready, we can write down the boot buffer
+	write_boot_buffer();
+
+	printk(KERN_INFO "Provenance relay ready.\n");
+	return 0;
+}
+
+core_initcall(relay_prov_init);
diff -uprN -b -B ./pristine/linux-4.9.5/security/security.c ./linux-4.9.5/security/security.c
--- ./pristine/linux-4.9.5/security/security.c	2017-01-20 10:56:02.000000000 +0100
+++ ./linux-4.9.5/security/security.c	2017-01-23 19:44:14.824585174 +0100
@@ -20,6 +20,7 @@
 #include <linux/integrity.h>
 #include <linux/ima.h>
 #include <linux/evm.h>
+#include <linux/camflow.h>
 #include <linux/fsnotify.h>
 #include <linux/mman.h>
 #include <linux/mount.h>
@@ -67,6 +68,10 @@ int __init security_init(void)
 	 */
 	do_security_initcalls();

+	/*
+	* Provenance is the last module to be loaded
+	*/
+	provenance_add_hooks();
 	return 0;
 }
