diff -uprN ./pristine/linux-4.4.6/include/linux/camflow.h ./linux-4.4.6/include/linux/camflow.h
--- ./pristine/linux-4.4.6/include/linux/camflow.h	1970-01-01 01:00:00.000000000 +0100
+++ ./linux-4.4.6/include/linux/camflow.h	2016-05-26 17:22:39.818013999 +0200
@@ -0,0 +1,88 @@
+/*
+*
+* /linux/include/linux/ifc.h
+*
+* Author: Thomas Pasquier <tfjmp2@cam.ac.uk>
+*
+* Copyright (C) 2016 University of Cambridge
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License version 2, as
+* published by the Free Software Foundation.
+*
+*/
+
+#ifndef _LINUX_CAMFLOW_HEAD_H
+#define _LINUX_CAMFLOW_HEAD_H
+
+#include <linux/fs.h>
+#include <linux/namei.h>
+
+// cause softlockup if both pointer directly added to inode
+// no time to figure out why, work around
+struct camflow_i_ptr{
+  void* provenance;
+  void* ifc;
+};
+
+extern struct kmem_cache *camflow_cache;
+
+static inline void alloc_camflow(struct inode *inode, gfp_t gfp)
+{
+  if(!inode->i_camflow)
+    inode->i_camflow = kmem_cache_zalloc(camflow_cache, gfp);
+}
+
+// free only if both ptr have been freed
+static inline void free_camflow(struct inode *inode){
+  struct camflow_i_ptr* camflow;
+  if(!inode->i_camflow){
+    camflow = inode->i_camflow;
+    if(camflow->provenance==NULL&&camflow->ifc==NULL){ // nothing left in the structure
+      kmem_cache_free(camflow_cache, camflow);
+      inode->i_camflow = NULL;
+    }
+  }
+}
+
+static inline void* inode_get_provenance(const struct inode *inode){
+  struct camflow_i_ptr* camflow = inode->i_camflow;
+  return camflow->provenance;
+}
+
+static inline void inode_set_provenance(const struct inode *inode, void** provenance){
+  struct camflow_i_ptr* camflow = inode->i_camflow;
+  if(provenance==NULL){
+    camflow->provenance=NULL;
+  }else{
+    camflow->provenance=(*provenance);
+  }
+}
+
+static inline void* inode_get_ifc(const struct inode *inode){
+  struct camflow_i_ptr* camflow = inode->i_camflow;
+  return camflow->ifc;
+}
+
+static inline void inode_set_ifc(const struct inode *inode, void** ifc){
+  struct camflow_i_ptr* camflow = inode->i_camflow;
+  if(ifc==NULL){
+    camflow->ifc=NULL;
+  }else{
+    camflow->ifc=(*ifc);
+  }
+}
+
+static inline struct inode* file_name_to_inode(const char* name){
+  struct path path;
+  struct inode* inode;
+  if(kern_path(name, LOOKUP_FOLLOW, &path)){
+    printk(KERN_ERR "CamFlow: Failed file look up (%s).", name);
+    return NULL;
+  }
+  inode = path.dentry->d_inode;
+  path_put(&path);
+  return inode;
+}
+
+#endif
diff -uprN ./pristine/linux-4.4.6/include/linux/cred.h ./linux-4.4.6/include/linux/cred.h
--- ./pristine/linux-4.4.6/include/linux/cred.h	2016-03-16 16:43:17.000000000 +0100
+++ ./linux-4.4.6/include/linux/cred.h	2016-05-26 17:22:39.818013999 +0200
@@ -149,6 +149,12 @@ struct cred {
 #ifdef CONFIG_SECURITY
 	void		*security;	/* subjective LSM security */
 #endif
+#ifdef CONFIG_SECURITY_PROVENANCE
+	void 		*provenance; /* subjective LSM provenance */
+#endif
+#ifdef CONFIG_SECURITY_IFC
+	void 		*ifc; /* subjective LSM ifc */
+#endif
 	struct user_struct *user;	/* real user ID subscription */
 	struct user_namespace *user_ns; /* user_ns the caps and keyrings are relative to. */
 	struct group_info *group_info;	/* supplementary groups for euid/fsgid */
@@ -372,6 +378,8 @@ static inline void put_cred(const struct
 #define current_cap()		(current_cred_xxx(cap_effective))
 #define current_user()		(current_cred_xxx(user))
 #define current_security()	(current_cred_xxx(security))
+#define current_provenance()	(current_cred_xxx(provenance))
+#define current_ifc()	(current_cred_xxx(ifc))
 
 extern struct user_namespace init_user_ns;
 #ifdef CONFIG_USER_NS
diff -uprN ./pristine/linux-4.4.6/include/linux/fs.h ./linux-4.4.6/include/linux/fs.h
--- ./pristine/linux-4.4.6/include/linux/fs.h	2016-03-16 16:43:17.000000000 +0100
+++ ./linux-4.4.6/include/linux/fs.h	2016-05-26 17:22:39.820013999 +0200
@@ -272,7 +272,7 @@ struct iattr {
  */
 #define FILESYSTEM_MAX_STACK_DEPTH 2
 
-/** 
+/**
  * enum positive_aop_returns - aop return codes with specific semantics
  *
  * @AOP_WRITEPAGE_ACTIVATE: Informs the caller that page writeback has
@@ -282,7 +282,7 @@ struct iattr {
  * 			    be a candidate for writeback again in the near
  * 			    future.  Other callers must be careful to unlock
  * 			    the page if they get this return.  Returned by
- * 			    writepage(); 
+ * 			    writepage();
  *
  * @AOP_TRUNCATED_PAGE: The AOP method that was handed a locked page has
  *  			unlocked it and the page might have been truncated.
@@ -599,6 +599,7 @@ struct inode {
 
 #ifdef CONFIG_SECURITY
 	void			*i_security;
+	void 			*i_camflow;
 #endif
 
 	/* Stat data, not accessed from path walking */
@@ -892,10 +893,10 @@ static inline struct file *get_file(stru
 
 #define	MAX_NON_LFS	((1UL<<31) - 1)
 
-/* Page cache limit. The filesystems should put that into their s_maxbytes 
-   limits, otherwise bad things can happen in VM. */ 
+/* Page cache limit. The filesystems should put that into their s_maxbytes
+   limits, otherwise bad things can happen in VM. */
 #if BITS_PER_LONG==32
-#define MAX_LFS_FILESIZE	(((loff_t)PAGE_CACHE_SIZE << (BITS_PER_LONG-1))-1) 
+#define MAX_LFS_FILESIZE	(((loff_t)PAGE_CACHE_SIZE << (BITS_PER_LONG-1))-1)
 #elif BITS_PER_LONG==64
 #define MAX_LFS_FILESIZE 	((loff_t)0x7fffffffffffffffLL)
 #endif
@@ -1294,6 +1295,9 @@ struct super_block {
 #ifdef CONFIG_SECURITY
 	void                    *s_security;
 #endif
+#ifdef CONFIG_SECURITY_PROVENANCE
+	void										*s_provenance;
+#endif
 	const struct xattr_handler **s_xattr;
 
 	struct hlist_bl_head	s_anon;		/* anonymous dentries for (nfs) exporting */
@@ -1922,7 +1926,7 @@ int sync_inode_metadata(struct inode *in
 struct file_system_type {
 	const char *name;
 	int fs_flags;
-#define FS_REQUIRES_DEV		1 
+#define FS_REQUIRES_DEV		1
 #define FS_BINARY_MOUNTDATA	2
 #define FS_HAS_SUBTYPE		4
 #define FS_USERNS_MOUNT		8	/* Can be mounted by userns root */
@@ -2530,7 +2534,7 @@ extern int kernel_read(struct file *, lo
 extern ssize_t kernel_write(struct file *, const char *, size_t, loff_t);
 extern ssize_t __kernel_write(struct file *, const char *, size_t, loff_t *);
 extern struct file * open_exec(const char *);
- 
+
 /* fs/dcache.c -- generic fs support functions */
 extern int is_subdir(struct dentry *, struct dentry *);
 extern int path_is_under(struct path *, struct path *);
diff -uprN ./pristine/linux-4.4.6/include/linux/ifc.h ./linux-4.4.6/include/linux/ifc.h
--- ./pristine/linux-4.4.6/include/linux/ifc.h	1970-01-01 01:00:00.000000000 +0100
+++ ./linux-4.4.6/include/linux/ifc.h	2016-05-26 17:22:39.820013999 +0200
@@ -0,0 +1,390 @@
+/*
+*
+* /linux/include/linux/ifc.h
+*
+* Author: Thomas Pasquier <tfjmp2@cam.ac.uk>
+*
+* Copyright (C) 2015 University of Cambridge
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License version 2, as
+* published by the Free Software Foundation.
+*
+*/
+#ifndef _LINUX_IFC_H
+#define _LINUX_IFC_H
+
+#ifdef CONFIG_SECURITY_IFC
+
+#include <linux/slab.h>
+#include <linux/sort.h>
+#include <linux/bsearch.h>
+#include <uapi/linux/ifc.h>
+#include <uapi/linux/camflow.h>
+#include <linux/crypto.h>
+
+struct ifc_bridge{
+  bool spawner;
+  bool bridge;
+  pid_t remote_pid;
+};
+
+struct ifc_struct{
+  struct ifc_context context;
+  struct ifc_bridge bridge;
+};
+
+int ifc_create_bridge(pid_t parent_pid, char **argv[]);
+int ifc_bridge_send_message(void* data, size_t size);
+int ifc_bridge_init(void);
+
+extern atomic64_t ifc_tag_count;
+extern struct crypto_cipher *ifc_tfm;
+
+static inline void ifc_save_counter(tag_t counter){
+  // TODO
+}
+
+static inline uint64_t ifc_next_tag_count( void ){
+  uint64_t tag = (uint64_t)atomic64_inc_return(&ifc_tag_count);
+  ifc_save_counter(tag);
+  return tag;
+}
+
+static inline void ifc_set_tag_count(uint64_t count){
+  atomic64_set(&ifc_tag_count, count);
+}
+
+static inline tag_t ifc_create_tag(void){
+  uint64_t in = ifc_next_tag_count();
+  uint64_t out = 0;
+  crypto_cipher_encrypt_one(ifc_tfm, (u8*)&out, (u8*)&in);
+  return out;
+}
+
+static inline bool ifc_tag_valid(tag_t tag){
+  tag_t out;
+  tag_t counter = atomic64_read(&ifc_tag_count);
+  crypto_cipher_decrypt_one(ifc_tfm, (u8*)&out, (u8*)&tag);
+  if(out>counter)
+    return false;
+  return true;
+}
+
+static int ifc_compare(const void *lhs, const void *rhs) {
+    uint64_t lhs_integer = *(const uint64_t *)(lhs);
+    uint64_t rhs_integer = *(const uint64_t *)(rhs);
+
+    if (lhs_integer < rhs_integer) return -1;
+    if (lhs_integer > rhs_integer) return 1;
+    return 0;
+}
+
+static inline void ifc_sort_label(struct ifc_label* label){
+  sort(label->array, label->size, sizeof(uint64_t), &ifc_compare, NULL);
+}
+
+static inline bool ifc_is_subset(struct ifc_label* sub, struct ifc_label* set){
+  int i=0, j=0;
+
+  if(sub->size == 0) // empty set is subset of everything
+    return true;
+
+  if(set->size < sub->size)
+    return false;
+
+  while( i < sub->size && j < set->size)
+  {
+    if( set->array[j] < sub->array[i] ){
+      j++;
+    }else if( set->array[j] == sub->array[i] ){
+      j++;
+      i++;
+    }else if( set->array[j] > sub->array[i] ){
+      return false;
+    }
+  }
+
+  if(i < sub->size)
+    return false;
+  return true;
+}
+
+static inline bool ifc_can_flow(struct ifc_context *from, struct ifc_context* to){
+  if(from->trusted==IFC_TRUSTED || to->trusted==IFC_TRUSTED){
+    return true;
+  }
+  if(!ifc_is_subset(&from->secrecy, &to->secrecy)){
+    return false;
+  }
+  if(!ifc_is_subset(&to->integrity, &from->integrity)){
+    return false;
+  }
+  return true;
+}
+
+static inline bool ifc_contains_value(struct ifc_label* label, tag_t value){
+  if(bsearch(&value, label->array, label->size, sizeof(uint64_t), &ifc_compare)==NULL){
+    return false;
+  }
+  return true;
+}
+
+static inline bool ifc_is_labelled(struct ifc_context* context){
+  if(context->secrecy.size > 0 || context->integrity.size > 0)
+    return true;
+  return false;
+}
+
+static inline int ifc_add_privilege(struct ifc_context* context, uint8_t type, tag_t tag){
+  struct ifc_label* privilege=NULL;
+
+  switch(type){
+    case IFC_SECRECY_P:
+      privilege = &context->secrecy_p;
+      break;
+    case IFC_INTEGRITY_P:
+      privilege = &context->integrity_p;
+      break;
+    case IFC_SECRECY_N:
+      privilege = &context->secrecy_n;
+      break;
+    case IFC_INTEGRITY_N:
+      privilege = &context->integrity_n;
+      break;
+  }
+
+  if(privilege==NULL)
+    return -EINVAL;
+
+  if(privilege->size +1 >= IFC_LABEL_MAX_SIZE) // label is full
+    return -ENOMEM;
+
+  if(ifc_contains_value(privilege, tag)) // aleady contains tag
+    return -EINVAL;
+
+  privilege->array[privilege->size] = tag;
+  privilege->size++;
+  ifc_sort_label(privilege);
+  return 0;
+}
+
+static inline int ifc_remove_privilege(struct ifc_context* context, uint8_t type, tag_t tag){
+  struct ifc_label* privilege=NULL;
+  int i = 0;
+
+  switch(type){
+    case IFC_SECRECY_P:
+      privilege = &context->secrecy_p;
+      break;
+    case IFC_INTEGRITY_P:
+      privilege = &context->integrity_p;
+      break;
+    case IFC_SECRECY_N:
+      privilege = &context->secrecy_n;
+      break;
+    case IFC_INTEGRITY_N:
+      privilege = &context->integrity_n;
+      break;
+  }
+
+  if(privilege==NULL)
+    return -EINVAL;
+
+  if(privilege->size <= 0) // label is empty
+    return -EINVAL;
+
+  if(!ifc_contains_value(privilege, tag)) // does not contains the privilege to be removed
+    return -EINVAL;
+
+  /* remove the tag */
+  for(i=0; i < privilege->size; i++){
+    if(privilege->array[i]==tag)
+      break;
+  }
+  for(;i < privilege->size-1; i++){
+    privilege->array[i]=privilege->array[i+1];
+  }
+  privilege->size--;
+  return 0;
+}
+
+static inline int ifc_add_tag(struct ifc_context* context, uint8_t type, tag_t tag){
+  struct ifc_label* label=NULL;
+  struct ifc_label* privilege=NULL;
+
+  switch(type){
+    case IFC_SECRECY:
+      label = &context->secrecy;
+      privilege = &context->secrecy_p;
+      break;
+    case IFC_INTEGRITY:
+      label = &context->integrity;
+      privilege = &context->integrity_p;
+      break;
+  }
+
+  if(privilege==NULL || label==NULL)
+    return -EINVAL;
+
+  if(label->size + 1 >= IFC_LABEL_MAX_SIZE) // label is full
+    return -ENOMEM;
+
+  if(ifc_contains_value(label, tag)) // aleady contains tag
+    return -EINVAL;
+
+  if(!ifc_contains_value(privilege, tag)) // not appropriate privilege
+    return -EPERM;
+
+  label->array[label->size]=tag;
+  label->size++;
+  ifc_sort_label(label);
+  return 0;
+}
+
+static inline int ifc_add_tag_no_check(struct ifc_context* context, uint8_t type, tag_t tag){
+  struct ifc_label* label=NULL;
+
+  switch(type){
+    case IFC_SECRECY:
+      label = &context->secrecy;
+      break;
+    case IFC_INTEGRITY:
+      label = &context->integrity;
+      break;
+  }
+
+  if(label==NULL)
+    return -EINVAL;
+
+  if(label->size >= IFC_LABEL_MAX_SIZE) // label is full
+    return -ENOMEM;
+
+  if(ifc_contains_value(label, tag)) // aleady contains tag
+    return -EINVAL;
+
+  label->array[label->size]=tag;
+  label->size++;
+  ifc_sort_label(label);
+  return 0;
+}
+
+static inline int ifc_remove_tag(struct ifc_context* context, uint8_t type, tag_t tag){
+  struct ifc_label* label=NULL;
+  struct ifc_label* privilege=NULL;
+  int i = 0;
+
+  switch(type){
+    case IFC_SECRECY:
+      label = &context->secrecy;
+      privilege = &context->secrecy_n;
+      break;
+    case IFC_INTEGRITY:
+      label = &context->integrity;
+      privilege = &context->integrity_n;
+      break;
+  }
+
+  if(privilege==NULL || label==NULL)
+    return -EINVAL;
+
+  if(label->size <= 0) // label is empty
+    return -EINVAL;
+
+  if(!ifc_contains_value(label, tag)) // the tag is not there to removed
+    return -EINVAL;
+
+  if(!ifc_contains_value(privilege, tag)) // does not have the proper privileges
+    return -EPERM;
+
+  /* remove the tag */
+  for(i=0; i < label->size; i++){
+    if(label->array[i]==tag)
+      break;
+  }
+  for(;i < label->size-1; i++){
+    label->array[i]=label->array[i+1];
+  }
+  label->size--;
+  return 0;
+}
+
+static inline int ifc_remove_tag_no_check(struct ifc_context* context, uint8_t type, tag_t tag){
+  struct ifc_label* label=NULL;
+  int i = 0;
+
+  switch(type){
+    case IFC_SECRECY:
+      label = &context->secrecy;
+      break;
+    case IFC_INTEGRITY:
+      label = &context->integrity;
+      break;
+  }
+
+  if(label==NULL)
+    return -EINVAL;
+
+  if(label->size <= 0) // label is empty
+    return -EINVAL;
+
+  if(!ifc_contains_value(label, tag)) // the tag is not there to removed
+    return -EINVAL;
+
+  /* remove the tag */
+  for(i=0; i < label->size; i++){
+    if(label->array[i]==tag)
+      break;
+  }
+  for(;i < label->size-1; i++){
+    label->array[i]=label->array[i+1];
+  }
+  label->size--;
+  return 0;
+}
+
+static inline void print_label(struct ifc_label* label){
+  int i;
+  for(i=0; i < label->size; i++){
+    printk(KERN_INFO "IFC: %llu", label->array[i]);
+  }
+}
+
+static inline int ifc_merge_context(struct ifc_context* main, struct ifc_context* to_add){
+  int i;
+
+  // too conservative TODO change this
+  if(main->secrecy.size + to_add->secrecy.size > IFC_LABEL_MAX_SIZE)
+      return -ENOMEM;
+  if(main->integrity.size + to_add->integrity.size > IFC_LABEL_MAX_SIZE)
+      return -ENOMEM;
+
+  for(i=0; i<to_add->secrecy.size; i++){
+    ifc_add_tag_no_check(main, IFC_SECRECY, to_add->secrecy.array[i]);
+  }
+
+  for(i=0; i<to_add->integrity.size; i++){
+    ifc_add_tag_no_check(main, IFC_INTEGRITY, to_add->integrity.array[i]);
+  }
+  return 0;
+}
+
+static inline void print_context(struct ifc_context* context){
+  if(context->trusted==IFC_TRUSTED){
+    printk(KERN_INFO "TRUSTED");
+  }
+  printk(KERN_INFO "IFC SECRECY (%d)", context->secrecy.size);
+  print_label(&context->secrecy);
+  printk(KERN_INFO "IFC INTEGRITY (%d)", context->integrity.size);
+  print_label(&context->integrity);
+}
+
+static inline struct ifc_struct* ifc_from_pid(pid_t pid){
+  struct task_struct *dest = find_task_by_vpid(pid);
+  if(!dest)
+    return NULL;
+  return __task_cred(dest)->ifc;
+}
+
+#endif
+#endif
diff -uprN ./pristine/linux-4.4.6/include/linux/ipc.h ./linux-4.4.6/include/linux/ipc.h
--- ./pristine/linux-4.4.6/include/linux/ipc.h	2016-03-16 16:43:17.000000000 +0100
+++ ./linux-4.4.6/include/linux/ipc.h	2016-05-26 17:22:39.820013999 +0200
@@ -18,9 +18,15 @@ struct kern_ipc_perm
 	kgid_t		gid;
 	kuid_t		cuid;
 	kgid_t		cgid;
-	umode_t		mode; 
+	umode_t		mode;
 	unsigned long	seq;
 	void		*security;
+#ifdef CONFIG_SECURITY_PROVENANCE
+	void		*provenance;
+#endif
+#ifdef CONFIG_SECURITY_IFC
+	void		*ifc;
+#endif
 };
 
 #endif /* _LINUX_IPC_H */
diff -uprN ./pristine/linux-4.4.6/include/linux/lsm_hooks.h ./linux-4.4.6/include/linux/lsm_hooks.h
--- ./pristine/linux-4.4.6/include/linux/lsm_hooks.h	2016-03-16 16:43:17.000000000 +0100
+++ ./linux-4.4.6/include/linux/lsm_hooks.h	2016-05-26 17:22:39.820013999 +0200
@@ -1887,4 +1887,16 @@ extern void __init yama_add_hooks(void);
 static inline void __init yama_add_hooks(void) { }
 #endif
 
+#ifdef CONFIG_SECURITY_PROVENANCE
+extern void __init provenance_add_hooks(void);
+#else
+static inline void __init provenance_add_hooks(void) { }
+#endif
+
+#ifdef CONFIG_SECURITY_IFC
+extern void __init ifc_add_hooks(void);
+#else
+static inline void __init ifc_add_hooks(void) { }
+#endif
+
 #endif /* ! __LINUX_LSM_HOOKS_H */
diff -uprN ./pristine/linux-4.4.6/include/linux/msg.h ./linux-4.4.6/include/linux/msg.h
--- ./pristine/linux-4.4.6/include/linux/msg.h	2016-03-16 16:43:17.000000000 +0100
+++ ./linux-4.4.6/include/linux/msg.h	2016-05-26 17:22:39.820013999 +0200
@@ -11,6 +11,12 @@ struct msg_msg {
 	size_t m_ts;		/* message text size */
 	struct msg_msgseg *next;
 	void *security;
+#ifdef CONFIG_SECURITY_PROVENANCE
+	void *provenance;
+#endif
+#ifdef CONFIG_SECURITY_IFC
+	void *ifc;
+#endif
 	/* the actual message follows immediately */
 };
 
diff -uprN ./pristine/linux-4.4.6/include/linux/provenance.h ./linux-4.4.6/include/linux/provenance.h
--- ./pristine/linux-4.4.6/include/linux/provenance.h	1970-01-01 01:00:00.000000000 +0100
+++ ./linux-4.4.6/include/linux/provenance.h	2016-05-26 17:22:39.820013999 +0200
@@ -0,0 +1,218 @@
+/*
+*
+* /linux/include/linux/provenance.h
+*
+* Author: Thomas Pasquier <tfjmp2@cam.ac.uk>
+*
+* Copyright (C) 2015 University of Cambridge
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License version 2, as
+* published by the Free Software Foundation.
+*
+*/
+#ifndef _LINUX_PROVENANCE_H
+#define _LINUX_PROVENANCE_H
+
+#ifdef CONFIG_SECURITY_PROVENANCE
+
+#include <linux/slab.h>
+#include <linux/types.h>
+#include <linux/bug.h>
+#include <linux/relay.h>
+#include <linux/socket.h>
+#include <uapi/linux/ifc.h>
+#include <uapi/linux/mman.h>
+#include <uapi/linux/provenance.h>
+#include <uapi/linux/camflow.h>
+
+#define ASSIGN_NODE_ID 0
+
+extern atomic64_t prov_evt_count;
+
+static inline struct prov_msg_t* prov_from_pid(pid_t pid){
+  struct task_struct *dest = find_task_by_vpid(pid);
+  if(!dest)
+    return NULL;
+  return __task_cred(dest)->provenance;
+}
+
+static inline uint64_t prov_next_evtid( void ){
+  return (uint64_t)atomic64_inc_return(&prov_evt_count);
+}
+
+extern atomic64_t prov_node_id;
+
+static inline uint64_t prov_next_nodeid( void )
+{
+  return (uint64_t)atomic64_inc_return(&prov_node_id);
+}
+
+extern struct rchan *prov_chan;
+extern struct rchan *long_prov_chan;
+extern bool prov_enabled;
+extern bool prov_all;
+extern struct kmem_cache *provenance_cache;
+extern struct kmem_cache *long_provenance_cache;
+
+static inline prov_msg_t* alloc_provenance(uint8_t ntype, gfp_t gfp)
+{
+  prov_msg_t* prov =  kmem_cache_zalloc(provenance_cache, gfp);
+  if(!prov){
+    return NULL;
+  }
+
+  prov->msg_info.msg_info.type=ntype;
+  return prov;
+}
+
+extern uint32_t prov_machine_id;
+extern uint32_t prov_boot_id;
+
+static inline void set_node_id(prov_msg_t* node, uint64_t nid){
+  if(nid==ASSIGN_NODE_ID){
+    node->node_info.node_info.id=prov_next_nodeid();
+  }else{
+    node->node_info.node_info.id=nid;
+  }
+  node->node_info.node_info.boot_id=prov_boot_id;
+  node->node_info.node_info.machine_id=prov_machine_id;
+}
+
+static inline long_prov_msg_t* alloc_long_provenance(uint8_t ntype, gfp_t gfp)
+{
+  long_prov_msg_t* prov =  kmem_cache_zalloc(long_provenance_cache, gfp);
+  if(!prov){
+    return NULL;
+  }
+  prov->msg_info.msg_info.type=ntype;
+  return prov;
+}
+
+static inline void free_provenance(prov_msg_t* prov){
+  kmem_cache_free(provenance_cache, prov);
+}
+
+static inline void free_long_provenance(long_prov_msg_t* prov){
+  kmem_cache_free(long_provenance_cache, prov);
+}
+
+static inline void prov_write(prov_msg_t* msg)
+{
+  if(prov_chan==NULL) // not set yet
+  {
+    printk(KERN_ERR "Provenance: trying to write before nchan ready\n");
+    return;
+  }
+  msg->msg_info.msg_info.id=prov_next_evtid(); /* assign an event id */
+  msg->msg_info.msg_info.boot_id=prov_boot_id;
+  msg->msg_info.msg_info.machine_id=prov_machine_id;
+  relay_write(prov_chan, msg, sizeof(prov_msg_t));
+}
+
+static inline void long_prov_write(long_prov_msg_t* msg){
+  if(long_prov_chan==NULL) // not set yet
+  {
+    printk(KERN_ERR "Provenance: trying to write before nchan ready\n");
+    return;
+  }
+  msg->msg_info.msg_info.id=prov_next_evtid(); /* assign an event id */
+  msg->msg_info.msg_info.boot_id=prov_boot_id;
+  msg->msg_info.msg_info.machine_id=prov_machine_id;
+  relay_write(long_prov_chan, msg, sizeof(long_prov_msg_t));
+}
+
+static inline int prov_print(const char *fmt, ...)
+{
+  long_prov_msg_t* msg;
+  int length;
+  va_list args;
+  va_start(args, fmt);
+
+  msg = (long_prov_msg_t*)kzalloc(sizeof(long_prov_msg_t), GFP_KERNEL);
+
+  /* set message type */
+  msg->str_info.msg_info.type=MSG_STR;
+  msg->str_info.length = vscnprintf(msg->str_info.str, 4096, fmt, args);
+  long_prov_write(msg);
+  va_end(args);
+  length = msg->str_info.length;
+  kfree(msg);
+  return length;
+}
+
+static inline void record_node(prov_msg_t* prov){
+  if(!prov_enabled) // capture is not enabled, ignore
+    return;
+
+  prov->node_info.node_kern.recorded=NODE_RECORDED;
+  prov_write(prov);
+}
+
+static inline bool provenance_is_tracked(prov_msg_t* node){
+  if(prov_all)
+    return true; // log everything but opaque
+  if(node->node_info.node_kern.tracked == NODE_TRACKED)
+    return true; // log tracked node, except if opaque
+  return false;
+}
+
+static inline bool provenance_is_name_recorded(prov_msg_t* node){
+  if(node->node_info.node_kern.name_recorded == NAME_RECORDED)
+    return true;
+  return false;
+}
+
+static inline void copy_node_info(struct basic_node_info* dest, struct basic_node_info* src){
+  memcpy(dest, src, sizeof(struct basic_node_info));
+}
+
+static inline void record_edge(uint8_t type, prov_msg_t* from, prov_msg_t* to, uint8_t allowed){
+  prov_msg_t edge;
+
+  if(unlikely(!prov_enabled)) // capture is not enabled, ignore
+    return;
+  // don't record if to or from are opaque
+  if(unlikely(from->node_info.node_kern.opaque == NODE_OPAQUE || to->node_info.node_kern.opaque == NODE_OPAQUE))
+    return;
+
+  // ignore if not tracked
+  if(!provenance_is_tracked(from) && !provenance_is_tracked(to))
+    return;
+
+  if(!(from->node_info.node_kern.recorded == NODE_RECORDED) )
+    record_node(from);
+
+  if(!(to->node_info.node_kern.recorded == NODE_RECORDED) )
+    record_node(to);
+
+  edge.edge_info.msg_info.type=MSG_EDGE;
+  copy_node_info(&edge.edge_info.snd, &from->node_info.node_info);
+  copy_node_info(&edge.edge_info.rcv, &to->node_info.node_info);
+  edge.edge_info.allowed=allowed;
+  edge.edge_info.type=type;
+  prov_write(&edge);
+}
+
+static inline void prov_update_version(prov_msg_t* prov){
+  prov_msg_t old_prov;
+  memcpy(&old_prov, prov, sizeof(prov_msg_t));
+  prov->node_info.node_info.version++;
+  prov->node_info.node_kern.recorded = NODE_UNRECORDED;
+  record_edge(ED_VERSION, &old_prov, prov, FLOW_ALLOWED);
+}
+
+#ifdef CONFIG_SECURITY_IFC
+static inline void prov_record_ifc(prov_msg_t* prov, struct ifc_context *context){
+	long_prov_msg_t* ifc_prov = NULL;
+
+  ifc_prov = alloc_long_provenance(MSG_IFC, GFP_KERNEL);
+  copy_node_info(&ifc_prov->ifc_info.node_info, &prov->node_info.node_info);
+  memcpy(&(ifc_prov->ifc_info.context), context, sizeof(struct ifc_context));
+  long_prov_write(ifc_prov);
+  free_long_provenance(ifc_prov);
+}
+#endif
+
+#endif
+#endif /* _LINUX_PROVENANCE_H */
diff -uprN ./pristine/linux-4.4.6/include/net/sock.h ./linux-4.4.6/include/net/sock.h
--- ./pristine/linux-4.4.6/include/net/sock.h	2016-03-16 16:43:17.000000000 +0100
+++ ./linux-4.4.6/include/net/sock.h	2016-05-26 17:22:39.820013999 +0200
@@ -307,6 +307,8 @@ struct cg_proto;
   *	@sk_peek_off: current peek_offset value
   *	@sk_send_head: front of stuff to transmit
   *	@sk_security: used by security modules
+	*	@sk_provenance: used by provenance modules
+	*	@sk_ifc: used by ifc modules
   *	@sk_mark: generic packet mark
   *	@sk_classid: this socket's cgroup classid
   *	@sk_cgrp: this socket's cgroup-specific proto data
@@ -445,6 +447,12 @@ struct sock {
 #ifdef CONFIG_SECURITY
 	void			*sk_security;
 #endif
+#ifdef CONFIG_SECURITY_PROVENANCE
+	void			*sk_provenance;
+#endif
+#ifdef CONFIG_SECURITY_IFC
+	void			*sk_ifc;
+#endif
 	__u32			sk_mark;
 #ifdef CONFIG_CGROUP_NET_CLASSID
 	u32			sk_classid;
diff -uprN ./pristine/linux-4.4.6/include/uapi/linux/camflow.h ./linux-4.4.6/include/uapi/linux/camflow.h
--- ./pristine/linux-4.4.6/include/uapi/linux/camflow.h	1970-01-01 01:00:00.000000000 +0100
+++ ./linux-4.4.6/include/uapi/linux/camflow.h	2016-05-26 17:22:39.821013999 +0200
@@ -0,0 +1,26 @@
+/*
+*
+* /linux/ifc.h
+*
+* Author: Thomas Pasquier <tfjmp2@cam.ac.uk>
+*
+* Copyright (C) 2016 University of Cambridge
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License version 2, as
+* published by the Free Software Foundation.
+*
+*/
+#ifndef _UAPI_LINUX_CAMFLOW_H
+#define _UAPI_LINUX_CAMFLOW_H
+
+#define xstr(s) str(s)
+#define str(s) #s
+
+#define CAMFLOW_VERSION_MAJOR     0
+#define CAMFLOW_VERSION_MINOR     1
+#define CAMFLOW_VERSION_PATCH     2
+#define CAMFLOW_VERSION_STR       "v"xstr(CAMFLOW_VERSION_MAJOR)"."xstr(CAMFLOW_VERSION_MINOR)"."xstr(CAMFLOW_VERSION_PATCH)
+
+
+#endif
diff -uprN ./pristine/linux-4.4.6/include/uapi/linux/ifc.h ./linux-4.4.6/include/uapi/linux/ifc.h
--- ./pristine/linux-4.4.6/include/uapi/linux/ifc.h	1970-01-01 01:00:00.000000000 +0100
+++ ./linux-4.4.6/include/uapi/linux/ifc.h	2016-05-26 17:22:39.821013999 +0200
@@ -0,0 +1,100 @@
+/*
+*
+* /linux/ifc.h
+*
+* Author: Thomas Pasquier <tfjmp2@cam.ac.uk>
+*
+* Copyright (C) 2015 University of Cambridge
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License version 2, as
+* published by the Free Software Foundation.
+*
+*/
+#ifndef _UAPI_LINUX_IFC_H
+#define _UAPI_LINUX_IFC_H
+
+#ifndef __KERNEL__
+#include <linux/limits.h>
+#else
+#include <uapi/linux/limits.h>
+#endif
+
+#define IFC_LABEL_MAX_SIZE  32
+
+#define IFC_SECRECY         1
+#define IFC_INTEGRITY       2
+#define IFC_SECRECY_P       3
+#define IFC_INTEGRITY_P     4
+#define IFC_SECRECY_N       5
+#define IFC_INTEGRITY_N     6
+
+#define IFC_ADD_TAG         1
+#define IFC_REMOVE_TAG      2
+#define IFC_ADD_BRIDGE      3
+#define IFC_START_BRIDGE    4
+
+#define IFC_TRUSTED         1
+#define IFC_UNTRUSTED       0
+
+#define IFC_SELF_FILE             "/sys/kernel/security/ifc/self"
+#define IFC_TAG_FILE              "/sys/kernel/security/ifc/tag"
+#define IFC_PROCESS_FILE          "/sys/kernel/security/ifc/process"
+#define IFC_BRIDGE_FILE           "/sys/kernel/security/ifc/bridge"
+#define IFC_FILE_FILE             "/sys/kernel/security/ifc/file"
+
+typedef uint64_t tag_t;
+
+struct ifc_label{
+  tag_t array[IFC_LABEL_MAX_SIZE];
+  uint8_t size;
+};
+
+struct ifc_context{
+  struct ifc_label secrecy;
+  struct ifc_label integrity;
+  struct ifc_label secrecy_p;
+  struct ifc_label integrity_p;
+  struct ifc_label secrecy_n;
+  struct ifc_label integrity_n;
+  uint8_t trusted;
+};
+
+struct ifc_tag_msg{
+  tag_t tag;
+  uint8_t tag_type;
+  uint8_t op;
+  uint32_t pid;
+};
+
+struct ifc_context_msg{
+  struct ifc_context context;
+  uint32_t pid;
+};
+
+struct ifc_bridge_msg{
+  uint32_t remote_pid;
+  uint64_t msg_id; /* contain provenance id if active */
+};
+
+
+#define PARAM_MAX 256
+struct ifc_bridge_config{
+  char path[PATH_MAX];
+  char param[PARAM_MAX];
+  uint8_t op;
+};
+
+struct ifc_file_config{
+  char name[PATH_MAX];
+  struct ifc_context context;
+};
+
+struct ifc_file_change{
+  char name[PATH_MAX];
+  tag_t tag;
+  uint8_t tag_type;
+  uint8_t op;
+};
+
+#endif
diff -uprN ./pristine/linux-4.4.6/include/uapi/linux/Kbuild ./linux-4.4.6/include/uapi/linux/Kbuild
--- ./pristine/linux-4.4.6/include/uapi/linux/Kbuild	2016-03-16 16:43:17.000000000 +0100
+++ ./linux-4.4.6/include/uapi/linux/Kbuild	2016-05-26 17:22:39.820013999 +0200
@@ -75,6 +75,7 @@ header-y += bpf.h
 header-y += bpqether.h
 header-y += bsg.h
 header-y += btrfs.h
+header-y += camflow.h
 header-y += can.h
 header-y += capability.h
 header-y += capi.h
@@ -185,6 +186,7 @@ header-y += if_tun.h
 header-y += if_tunnel.h
 header-y += if_vlan.h
 header-y += if_x25.h
+header-y += ifc.h
 header-y += igmp.h
 header-y += ila.h
 header-y += in6.h
@@ -337,6 +339,7 @@ header-y += ppp_defs.h
 header-y += ppp-ioctl.h
 header-y += pps.h
 header-y += prctl.h
+header-y += provenance.h
 header-y += psci.h
 header-y += ptp_clock.h
 header-y += ptrace.h
diff -uprN ./pristine/linux-4.4.6/include/uapi/linux/netlink.h ./linux-4.4.6/include/uapi/linux/netlink.h
--- ./pristine/linux-4.4.6/include/uapi/linux/netlink.h	2016-03-16 16:43:17.000000000 +0100
+++ ./linux-4.4.6/include/uapi/linux/netlink.h	2016-05-26 17:22:39.821013999 +0200
@@ -15,7 +15,7 @@
 #define NETLINK_SELINUX		7	/* SELinux event notifications */
 #define NETLINK_ISCSI		8	/* Open-iSCSI */
 #define NETLINK_AUDIT		9	/* auditing */
-#define NETLINK_FIB_LOOKUP	10	
+#define NETLINK_FIB_LOOKUP	10
 #define NETLINK_CONNECTOR	11
 #define NETLINK_NETFILTER	12	/* netfilter subsystem */
 #define NETLINK_IP6_FW		13
@@ -27,10 +27,11 @@
 #define NETLINK_ECRYPTFS	19
 #define NETLINK_RDMA		20
 #define NETLINK_CRYPTO		21	/* Crypto layer */
+#define NETLINK_CAMFLOW_IFC_BRIDGE 25 /* CAMFLOW IFC BRIDGE */
 
 #define NETLINK_INET_DIAG	NETLINK_SOCK_DIAG
 
-#define MAX_LINKS 32		
+#define MAX_LINKS 32
 
 struct sockaddr_nl {
 	__kernel_sa_family_t	nl_family;	/* AF_NETLINK	*/
diff -uprN ./pristine/linux-4.4.6/include/uapi/linux/provenance.h ./linux-4.4.6/include/uapi/linux/provenance.h
--- ./pristine/linux-4.4.6/include/uapi/linux/provenance.h	1970-01-01 01:00:00.000000000 +0100
+++ ./linux-4.4.6/include/uapi/linux/provenance.h	2016-05-26 17:22:39.821013999 +0200
@@ -0,0 +1,242 @@
+/*
+*
+* /linux/provenance.h
+*
+* Author: Thomas Pasquier <tfjmp2@cam.ac.uk>
+*
+* Copyright (C) 2015 University of Cambridge
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License version 2, as
+* published by the Free Software Foundation.
+*
+*/
+#ifndef _UAPI_LINUX_PROVENANCE_H
+#define _UAPI_LINUX_PROVENANCE_H
+
+#ifndef __KERNEL__
+#include <linux/limits.h>
+#include <linux/ifc.h>
+#else
+#include <uapi/linux/ifc.h>
+#include <uapi/linux/limits.h>
+#endif
+
+#define PROV_ENABLE_FILE           "/sys/kernel/security/provenance/enable"
+#define PROV_ALL_FILE              "/sys/kernel/security/provenance/all"
+#define PROV_OPAQUE_FILE           "/sys/kernel/security/provenance/opaque"
+#define PROV_NODE_FILE             "/sys/kernel/security/provenance/node"
+#define PROV_EDGE_FILE             "/sys/kernel/security/provenance/edge"
+#define PROV_SELF_FILE             "/sys/kernel/security/provenance/self"
+#define PROV_MACHINE_ID_FILE       "/sys/kernel/security/provenance/machine_id"
+
+#define MSG_STR           0
+#define MSG_EDGE          1
+#define MSG_TASK          2
+#define MSG_INODE         3
+#define MSG_LINK          4
+#define MSG_UNLINK        5
+#define MSG_DISC_NODE     6
+#define MSG_MSG           7
+#define MSG_SHM           8
+#define MSG_SOCK          9
+#define MSG_ADDR          10
+#define MSG_SB            11
+#define MSG_FILE_NAME     12
+#define MSG_IFC           13
+
+#define ED_DATA           0
+#define ED_CREATE         1
+#define ED_PASS           2
+#define ED_CHANGE         3
+#define ED_MMAP           4
+#define ED_ATTACH         5
+#define ED_ASSOCIATE      6
+#define ED_BIND           7
+#define ED_CONNECT        8
+#define ED_LISTEN         9
+#define ED_ACCEPT         10
+#define ED_OPEN           11
+#define ED_PARENT         12
+#define ED_VERSION        13
+
+#define FLOW_DISALLOWED   0
+#define FLOW_ALLOWED      1
+
+#define NODE_TRACKED      1
+#define NODE_NOT_TRACKED  0
+
+#define NODE_RECORDED     1
+#define NODE_UNRECORDED   0
+
+#define NAME_RECORDED     1
+#define NAME_UNRECORDED   0
+
+#define NODE_OPAQUE       1
+#define NODE_NOT_OPAQUE   0
+
+#define INODE_LINKED      1
+#define INODE_UNLINKED    0
+
+#define STR_MAX_SIZE      128
+
+struct basic_msg_info{
+  uint8_t type;
+  uint32_t machine_id;
+  uint32_t boot_id;
+  uint64_t id;
+};
+
+struct basic_node_info{
+  uint64_t id;
+  uint32_t boot_id;
+  uint32_t machine_id;
+  uint32_t version;
+};
+
+struct node_kern{
+  uint8_t recorded;
+  uint8_t name_recorded;
+  uint8_t tracked;
+  uint8_t opaque;
+};
+
+struct msg_struct{
+  struct basic_msg_info msg_info;
+};
+
+struct edge_struct{
+  struct basic_msg_info msg_info;
+  uint8_t type;
+  uint8_t allowed;
+  struct basic_node_info snd;
+  struct basic_node_info rcv;
+};
+
+struct node_struct{
+  struct basic_msg_info msg_info;
+  struct basic_node_info node_info;
+  struct node_kern node_kern;
+};
+
+struct disc_node_struct{
+  struct basic_msg_info msg_info;
+  struct basic_node_info node_info;
+  struct node_kern node_kern;
+};
+
+struct task_prov_struct{
+  struct basic_msg_info msg_info;
+  struct basic_node_info node_info;
+  struct node_kern node_kern;
+  uint32_t uid;
+  uint32_t gid;
+};
+
+struct inode_prov_struct{
+  struct basic_msg_info msg_info;
+  struct basic_node_info node_info;
+  struct node_kern node_kern;
+  uint32_t uid;
+  uint32_t gid;
+  uint16_t mode;
+  uint8_t sb_uuid[16];
+};
+
+struct sb_struct{
+  struct basic_msg_info msg_info;
+  struct basic_node_info node_info;
+  uint8_t uuid[16];
+};
+
+struct msg_msg_struct{
+  struct basic_msg_info msg_info;
+  struct basic_node_info node_info;
+  struct node_kern node_kern;
+  long type;
+};
+
+struct shm_struct{
+  struct basic_msg_info msg_info;
+  struct basic_node_info node_info;
+  struct node_kern node_kern;
+  uint16_t mode;
+};
+
+struct sock_struct{
+  struct basic_msg_info msg_info;
+  struct basic_node_info node_info;
+  struct node_kern node_kern;
+  uint16_t type;
+  uint16_t family;
+  uint8_t protocol;
+};
+
+typedef union prov_msg{
+  struct msg_struct           msg_info;
+  struct node_struct          node_info;
+  struct disc_node_struct     disc_node_info;
+  struct task_prov_struct     task_info;
+  struct inode_prov_struct    inode_info;
+  struct edge_struct          edge_info;
+  struct msg_msg_struct       msg_msg_info;
+  struct shm_struct           shm_info;
+  struct sock_struct          sock_info;
+  struct sb_struct            sb_info;
+} prov_msg_t;
+
+struct str_struct{
+  struct basic_msg_info msg_info;
+  size_t length;
+  char str[PATH_MAX];
+};
+
+struct link_struct{
+  struct basic_msg_info msg_info;
+  size_t length;
+  char name[PATH_MAX];
+  struct basic_node_info dir;
+  struct basic_node_info task;
+  struct basic_node_info inode;
+};
+
+struct unlink_struct{
+  struct basic_msg_info msg_info;
+  size_t length;
+  char name[PATH_MAX];
+  struct basic_node_info dir;
+  struct basic_node_info task;
+  struct basic_node_info inode;
+};
+
+struct file_name_struct{
+  struct basic_msg_info msg_info;
+  size_t length;
+  char name[PATH_MAX];
+  struct basic_node_info inode;
+};
+
+struct address_struct{
+  struct basic_msg_info msg_info;
+  struct basic_node_info sock_info;
+  struct sockaddr addr;
+  size_t length;
+};
+
+struct ifc_context_struct{
+  struct basic_msg_info msg_info;
+  struct basic_node_info node_info;
+  struct ifc_context context;
+};
+
+typedef union long_msg{
+  struct msg_struct           msg_info;
+  struct str_struct           str_info;
+  struct link_struct          link_info;
+  struct unlink_struct        unlink_info;
+  struct file_name_struct     file_name_info;
+  struct address_struct       address_info;
+  struct ifc_context_struct   ifc_info;
+} long_prov_msg_t;
+
+#endif
diff -uprN ./pristine/linux-4.4.6/include/uapi/linux/xattr.h ./linux-4.4.6/include/uapi/linux/xattr.h
--- ./pristine/linux-4.4.6/include/uapi/linux/xattr.h	2016-03-16 16:43:17.000000000 +0100
+++ ./linux-4.4.6/include/uapi/linux/xattr.h	2016-05-26 17:22:39.821013999 +0200
@@ -52,6 +52,11 @@
 #define XATTR_SELINUX_SUFFIX "selinux"
 #define XATTR_NAME_SELINUX XATTR_SECURITY_PREFIX XATTR_SELINUX_SUFFIX
 
+#define XATTR_PROVENANCE_SUFFIX "provenance"
+#define XATTR_NAME_PROVENANCE XATTR_SECURITY_PREFIX XATTR_PROVENANCE_SUFFIX
+#define XATTR_IFC_SUFFIX "ifc"
+#define XATTR_NAME_IFC XATTR_SECURITY_PREFIX XATTR_IFC_SUFFIX
+
 #define XATTR_SMACK_SUFFIX "SMACK64"
 #define XATTR_SMACK_IPIN "SMACK64IPIN"
 #define XATTR_SMACK_IPOUT "SMACK64IPOUT"
diff -uprN ./pristine/linux-4.4.6/security/ifc/bridge.c ./linux-4.4.6/security/ifc/bridge.c
--- ./pristine/linux-4.4.6/security/ifc/bridge.c	1970-01-01 01:00:00.000000000 +0100
+++ ./linux-4.4.6/security/ifc/bridge.c	2016-05-26 17:22:39.811013999 +0200
@@ -0,0 +1,157 @@
+/*
+*
+* /linux/security/ifc/hooks.c
+*
+* Author: Thomas Pasquier <tfjmp2@cam.ac.uk>
+*
+* Copyright (C) 2016 University of Cambridge
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License version 2, as
+* published by the Free Software Foundation.
+*
+*/
+
+#include <linux/kmod.h>
+#include <linux/ifc.h>
+#include <linux/sched.h>
+#include <net/net_namespace.h>
+#include <net/netlink.h>
+
+int prepare_bridge_usher(struct subprocess_info *info, struct cred *new){
+  pid_t parent_pid = (*((pid_t*)info->data));
+  struct task_struct* dest;
+  const struct cred* old;
+  struct ifc_struct *new_ifc = new->ifc;
+
+  if(new_ifc==NULL){
+    return -EFAULT;
+  }
+
+  dest = find_task_by_vpid(parent_pid);
+  if(dest==NULL){
+    return -EFAULT;
+  }
+  old = __task_cred(dest);
+
+  new_ifc->bridge.remote_pid = parent_pid;
+  new_ifc->bridge.spawner=true;
+  /* set process to run with proper uid/gid */
+  new->uid = old->uid;
+  new->gid = old->gid;
+  new->euid = old->euid;
+  new->egid = old->egid;
+  new->suid = old->suid;
+  new->sgid = old->sgid;
+  new->fsuid = old->fsuid;
+  new->fsgid = old->fsgid;
+  return 0;
+}
+
+int ifc_create_bridge(pid_t parent_pid, char **argv[]){
+  struct subprocess_info *sub_info;
+  static char *envp[] = {
+        "HOME=/",
+        "TERM=linux",
+        "PATH=/sbin:/bin:/usr/sbin:/usr/bin", NULL };
+
+  sub_info = call_usermodehelper_setup((*argv)[0], *argv, envp, GFP_KERNEL,
+    prepare_bridge_usher, NULL, &parent_pid);
+
+  if (sub_info == NULL){
+    printk(KERN_INFO "IFC: Creating bridge failed setup.");
+    return -ENOMEM;
+  }
+  return call_usermodehelper_exec(sub_info, UMH_WAIT_EXEC);
+}
+
+static struct sock *nl_sk = NULL;
+
+static inline int send_to(struct sock* sk, const pid_t target, void* data, const size_t size){
+  struct nlmsghdr *nlh;
+  struct sk_buff *skb_out = nlmsg_new(size,0);
+  if(!skb_out){
+    return -ENOMEM;
+  }
+  if(target==0){
+    return -EFAULT;
+  }
+
+  nlh=nlmsg_put(skb_out,0,0,NLMSG_DONE,size,0);
+  if(nlh==NULL){
+    printk(KERN_INFO "IFC: tailroom of the skb is insufficient to store the message header and payload.");
+    return -ENOMEM;
+  }
+  NETLINK_CB(skb_out).dst_group = 0;
+  memcpy(nlmsg_data(nlh), data, size);
+  return nlmsg_unicast(sk,skb_out,target);
+}
+
+static inline bool _bridge_can_send(pid_t remote_pid){
+  pid_t cpid;
+  struct ifc_struct *cifc = current_ifc(), *rifc;
+  struct task_struct* dest;
+  const struct cred* rcred;
+
+  /* checking permission */
+  if(cifc->bridge.bridge==true){
+    if(cifc->bridge.remote_pid!=remote_pid){
+      printk(KERN_ALERT "IFC: bridge perm refused %u-%u.", cifc->bridge.remote_pid, remote_pid);
+      return false;
+    }
+  }else{
+    cpid = task_pid_vnr(current);
+    dest = find_task_by_vpid(remote_pid);
+    if(dest==NULL){
+      return false;
+    }
+    rcred = __task_cred(dest);
+    rifc = rcred->ifc;
+    if(rifc->bridge.remote_pid!=cpid){
+      printk(KERN_ALERT "IFC: not bridge perm refused %u-%u.", rifc->bridge.remote_pid, cpid);
+      return false;
+    }
+  }
+
+  return true;
+}
+
+static void _bridge_rcv(struct sk_buff *skb)
+{
+  int rc=0;
+  struct nlmsghdr *nlh=(struct nlmsghdr*)skb->data;
+  if(_bridge_can_send(nlh->nlmsg_pid)){
+    rc = send_to(nl_sk, nlh->nlmsg_pid, nlmsg_data(nlh), nlmsg_len(nlh));
+    if(rc){
+      printk(KERN_ALERT "IFC: problem while forwarding message %d.", rc);
+    }
+  }else{
+    printk(KERN_INFO "IFC: bridge invalid target");
+  }
+}
+
+enum selinux_nlgroups {
+	CAMNLGRP_NONE,
+#define CAMNLGRP_NONE	CAMNLGRP_NONE
+	CAMNLGRP_AVC,
+#define CAMNLGRP_AVC	CAMNLGRP_AVC
+	__CAMNLGRP_MAX
+};
+#define CAMNLGRP_MAX	(__CAMNLGRP_MAX - 1)
+
+int __init ifc_bridge_init(void)
+{
+  struct netlink_kernel_cfg cfg = {
+    .input  = _bridge_rcv,
+    .groups = CAMNLGRP_MAX,
+  };
+  nl_sk = netlink_kernel_create(&init_net, NETLINK_CAMFLOW_IFC_BRIDGE, &cfg);
+  if(nl_sk==NULL){
+    printk(KERN_ERR "IFC: Cannot create bridge netlink socket.");
+    return -ENOMEM;
+  }
+  printk(KERN_INFO "IFC: bridge ready.");
+  return 0;
+}
+
+__initcall(ifc_bridge_init);
diff -uprN ./pristine/linux-4.4.6/security/ifc/fs.c ./linux-4.4.6/security/ifc/fs.c
--- ./pristine/linux-4.4.6/security/ifc/fs.c	1970-01-01 01:00:00.000000000 +0100
+++ ./linux-4.4.6/security/ifc/fs.c	2016-05-26 17:22:39.811013999 +0200
@@ -0,0 +1,563 @@
+/*
+*
+* /linux/security/ifc/fs.c
+*
+* Author: Thomas Pasquier <tfjmp2@cam.ac.uk>
+*
+* Copyright (C) 2015 University of Cambridge
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License version 2, as
+* published by the Free Software Foundation.
+*
+*/
+
+#include <linux/security.h>
+#include <linux/fs.h>
+#include <linux/ifc.h>
+#include <linux/delay.h>
+#include <linux/camflow.h>
+#include <linux/provenance.h>
+#include <linux/list.h>
+
+static void mark_as_trusted(const char* name){
+  struct inode* in;
+  struct ifc_struct* ifc;
+#ifdef CONFIG_SECURITY_PROVENANCE
+  prov_msg_t* provenance;
+#endif
+
+  in = file_name_to_inode(name);
+  if(!in){
+    printk(KERN_ERR "IFC: could not find %s file.", name);
+  }else{
+    ifc = inode_get_ifc(in);
+    ifc->context.trusted=IFC_TRUSTED;
+#ifdef CONFIG_SECURITY_PROVENANCE
+    // opaque NODES are not recorded in audit data
+    provenance = inode_get_provenance(in);
+    provenance->node_info.node_kern.opaque=NODE_OPAQUE;
+#endif
+  }
+}
+
+static bool ifc_fs_is_initialised=false;
+
+static inline void initialize(void){
+  if(ifc_fs_is_initialised)
+    return;
+  printk(KERN_INFO "IFC: marking API files as trusted...");
+  mark_as_trusted(IFC_SELF_FILE);
+  mark_as_trusted(IFC_TAG_FILE);
+  mark_as_trusted(IFC_PROCESS_FILE);
+  mark_as_trusted(IFC_BRIDGE_FILE);
+  mark_as_trusted(IFC_FILE_FILE);
+  ifc_fs_is_initialised=true;
+}
+
+static ssize_t ifc_write_self(struct file *file, const char __user *buf,
+				 size_t count, loff_t *ppos)
+
+{
+  struct ifc_struct *cifc = current_ifc();
+  struct ifc_tag_msg *msg;
+  int rv=-EINVAL;
+#ifdef CONFIG_SECURITY_PROVENANCE
+  prov_msg_t* cprov=NULL;
+#endif
+
+  initialize();
+
+  if(count < sizeof(struct ifc_tag_msg)){
+    return -ENOMEM;
+  }
+
+  msg = (struct ifc_tag_msg*)buf;
+
+  if(!ifc_tag_valid(msg->tag)){
+    return -EINVAL;
+  }
+
+  if(msg->op==IFC_ADD_TAG){
+    switch(msg->tag_type){
+      case IFC_SECRECY:
+        rv=ifc_add_tag(&cifc->context, IFC_SECRECY, msg->tag);
+        break;
+      case IFC_INTEGRITY:
+        rv=ifc_add_tag(&cifc->context, IFC_INTEGRITY, msg->tag);
+        break;
+      case IFC_SECRECY_P:
+        if(__kuid_val(current_euid())!=0)
+          return -EPERM;
+        rv=ifc_add_privilege(&cifc->context, IFC_SECRECY_P, msg->tag);
+        break;
+      case IFC_INTEGRITY_P:
+        if(__kuid_val(current_euid())!=0)
+          return -EPERM;
+        rv=ifc_add_privilege(&cifc->context, IFC_INTEGRITY_P, msg->tag);
+        break;
+      case IFC_SECRECY_N:
+        if(__kuid_val(current_euid())!=0)
+          return -EPERM;
+        rv=ifc_add_privilege(&cifc->context, IFC_SECRECY_N, msg->tag);
+        break;
+      case IFC_INTEGRITY_N:
+        if(__kuid_val(current_euid())!=0)
+          return -EPERM;
+        rv=ifc_add_privilege(&cifc->context, IFC_INTEGRITY_N, msg->tag);
+        break;
+    }
+  }else{
+    switch(msg->tag_type){
+      case IFC_SECRECY:
+        rv=ifc_remove_tag(&cifc->context, IFC_SECRECY, msg->tag);
+        break;
+      case IFC_INTEGRITY:
+        rv=ifc_remove_tag(&cifc->context, IFC_INTEGRITY, msg->tag);
+        break;
+      case IFC_SECRECY_P:
+        rv=ifc_remove_privilege(&cifc->context, IFC_SECRECY_P, msg->tag);
+        break;
+      case IFC_INTEGRITY_P:
+        rv=ifc_remove_privilege(&cifc->context, IFC_INTEGRITY_P, msg->tag);
+        break;
+      case IFC_SECRECY_N:
+        rv=ifc_remove_privilege(&cifc->context, IFC_SECRECY_N, msg->tag);
+        break;
+      case IFC_INTEGRITY_N:
+        rv=ifc_remove_privilege(&cifc->context, IFC_INTEGRITY_N, msg->tag);
+        break;
+    }
+  }
+  if(!rv){
+
+#ifdef CONFIG_SECURITY_PROVENANCE
+    // mark as tracked depending of the label state
+    cprov = current_provenance();
+    prov_update_version(cprov);
+    prov_record_ifc(cprov, &cifc->context);
+    if(ifc_is_labelled(&cifc->context)){
+      cprov->node_info.node_kern.tracked=NODE_TRACKED;
+    }else{
+      cprov->node_info.node_kern.tracked=NODE_NOT_TRACKED;
+    }
+#endif
+
+    return sizeof(struct ifc_tag_msg);
+  }
+  return rv; // return error
+}
+
+static ssize_t ifc_read_self(struct file *filp, char __user *buf,
+				size_t count, loff_t *ppos)
+{
+  struct ifc_struct *cifc = current_ifc();
+
+  initialize();
+
+	if(count < sizeof(struct ifc_context)){
+    return -ENOMEM;
+  }
+  if(copy_to_user(buf, &cifc->context, sizeof(struct ifc_context))){
+    return -EAGAIN;
+  }
+  return sizeof(struct ifc_context);
+}
+
+static const struct file_operations ifc_self_ops = {
+	.write		= ifc_write_self,
+  .read     = ifc_read_self,
+	.llseek		= generic_file_llseek,
+};
+
+static ssize_t ifc_write_tag(struct file *file, const char __user *buf,
+				 size_t count, loff_t *ppos)
+
+{
+	return -EPERM; // does nothing for now
+}
+
+static ssize_t ifc_read_tag(struct file *filp, char __user *buf,
+				size_t count, loff_t *ppos)
+{
+	struct ifc_struct *cifc = current_ifc();
+	tag_t tag;
+	int rv=0;
+
+	if(count<sizeof(tag_t))
+		return -ENOMEM;
+
+	tag = ifc_create_tag();
+
+	rv |= ifc_add_privilege(&cifc->context, IFC_SECRECY_P, tag);
+	rv |= ifc_add_privilege(&cifc->context, IFC_INTEGRITY_P, tag);
+	rv |= ifc_add_privilege(&cifc->context, IFC_SECRECY_N, tag);
+	rv |= ifc_add_privilege(&cifc->context, IFC_INTEGRITY_N, tag);
+
+	if(rv<0){
+		return rv;
+	}
+
+	if(copy_to_user(buf, &tag, sizeof(tag_t))){
+    return -EAGAIN;
+  }
+
+	return sizeof(tag_t);
+}
+
+static const struct file_operations ifc_tag_ops = {
+	.write		= ifc_write_tag,
+  .read     = ifc_read_tag,
+	.llseek		= generic_file_llseek,
+};
+
+static ssize_t ifc_write_process(struct file *file, const char __user *buf,
+				 size_t count, loff_t *ppos)
+
+{
+	struct ifc_struct *cifc = current_ifc();
+	struct ifc_struct *oifc = NULL;
+  struct ifc_tag_msg *msg;
+  int rv=-EINVAL;
+
+  if(count < sizeof(struct ifc_tag_msg)){
+    return -ENOMEM;
+  }
+
+  msg = (struct ifc_tag_msg*)buf;
+
+  if(!ifc_tag_valid(msg->tag)){
+    return -EINVAL;
+  }
+
+	oifc = ifc_from_pid(msg->pid);
+	if(!oifc){ // did not find anything
+		return -EINVAL;
+	}
+
+  if(msg->op==IFC_ADD_TAG){
+    switch(msg->tag_type){
+      case IFC_SECRECY_P:
+				if(!ifc_contains_value(&cifc->context.secrecy_p, msg->tag))
+					return -EPERM;
+        rv=ifc_add_privilege(&oifc->context, IFC_SECRECY_P, msg->tag);
+        break;
+      case IFC_INTEGRITY_P:
+				if(!ifc_contains_value(&cifc->context.integrity_p, msg->tag))
+					return -EPERM;
+        rv=ifc_add_privilege(&oifc->context, IFC_INTEGRITY_P, msg->tag);
+        break;
+      case IFC_SECRECY_N:
+				if(!ifc_contains_value(&cifc->context.secrecy_n, msg->tag))
+					return -EPERM;
+        rv=ifc_add_privilege(&oifc->context, IFC_SECRECY_N, msg->tag);
+        break;
+      case IFC_INTEGRITY_N:
+				if(!ifc_contains_value(&cifc->context.integrity_n, msg->tag))
+					return -EPERM;
+        rv=ifc_add_privilege(&oifc->context, IFC_INTEGRITY_N, msg->tag);
+        break;
+    }
+  }
+
+  if(!rv){
+    return sizeof(struct ifc_tag_msg);
+  }
+
+  return rv; // return error
+}
+
+static ssize_t ifc_read_process(struct file *filp, char __user *buf,
+				size_t count, loff_t *ppos)
+{
+	struct ifc_struct *oifc = NULL;
+  struct ifc_context_msg *msg;
+
+  if(__kuid_val(current_euid())!=0)
+    return -EPERM;
+
+  if(count < sizeof(struct ifc_context_msg)){
+    return -ENOMEM;
+  }
+
+  msg = (struct ifc_context_msg*)buf;
+
+  oifc = ifc_from_pid(msg->pid);
+	if(!oifc){ // did not find anything
+		return -EINVAL;
+	}
+
+  if(copy_to_user(&msg->context, &oifc->context, sizeof(struct ifc_context))){
+    return -EAGAIN;
+  }
+  return sizeof(struct ifc_context_msg);
+}
+
+static const struct file_operations ifc_process_ops = {
+	.write		= ifc_write_process,
+  .read     = ifc_read_process,
+	.llseek		= generic_file_llseek,
+};
+
+struct bridge_struct {
+    struct list_head list;
+    char name[PATH_MAX];
+};
+
+static LIST_HEAD(bridge_list);
+
+static bool list_contains(const char* name){
+  struct list_head *ptr;
+  struct bridge_struct *entry;
+
+  if(list_empty(&bridge_list)!=0)
+    return false;
+
+  list_for_each(ptr, &bridge_list) {
+        entry = list_entry(ptr, struct bridge_struct, list);
+        if(strcmp(name, entry->name)==0){
+          return true;
+        }
+    }
+    return false;
+}
+
+static int add_name_to_list(const char* name){
+  struct bridge_struct *entry;
+  if(list_contains(name)) // already in the list
+    return 0;
+
+  entry = (struct bridge_struct*)kzalloc(sizeof(struct bridge_struct), GFP_KERNEL);
+  if(copy_from_user(entry->name, name, PATH_MAX)!=0){
+    return -ENOMEM;
+  }
+  list_add(&entry->list, &bridge_list);
+  return 0;
+}
+
+static ssize_t ifc_write_bridge(struct file *file, const char __user *buf,
+				 size_t count, loff_t *ppos)
+
+{
+  pid_t pid = task_pid_vnr(current);
+  struct ifc_bridge_config *config;
+  char **argv;
+  int rc = 0;
+
+  if(count < sizeof(struct ifc_bridge_config))
+    return -ENOMEM;
+
+  config = (struct ifc_bridge_config*)buf;
+
+  switch(config->op){
+    case IFC_ADD_BRIDGE:
+      if(__kuid_val(current_euid())!=0)
+        return -EPERM;
+      rc = add_name_to_list(config->path);
+      break;
+    case IFC_START_BRIDGE:
+      argv=kzalloc(3*sizeof(char*), GFP_KERNEL);
+      argv[0]=kzalloc(PATH_MAX, GFP_KERNEL);
+      if(copy_from_user (argv[0], config->path, PATH_MAX)!=0){
+        return -ENOMEM;
+      }
+      if(!list_contains(argv[0])){
+        return -EPERM;
+      }
+      argv[1]=kzalloc(PARAM_MAX, GFP_KERNEL);
+      if(copy_from_user (argv[1], config->param, PARAM_MAX)!=0){
+        return -ENOMEM;
+      }
+      argv[2] = NULL;
+      ifc_create_bridge(pid, &argv);
+      kfree(argv[0]);
+      kfree(argv[1]);
+      kfree(argv);
+      break;
+    default:
+      return -EINVAL;
+  }
+	return rc;
+}
+
+static ssize_t ifc_read_bridge(struct file *filp, char __user *buf,
+				size_t count, loff_t *ppos)
+{
+  struct ifc_struct *cifc = current_ifc();
+  uint32_t pid=0;
+  int i=0;
+
+  if(count<sizeof(uint32_t))
+    return -EINVAL;
+
+  if(cifc->bridge.bridge==true){
+    pid = cifc->bridge.remote_pid;
+  }else{
+    /* we try to read the pid of the started bridge usher */
+    while(i<100){
+      i++;
+      if(cifc->bridge.remote_pid!=0){
+        pid = cifc->bridge.remote_pid;
+        cifc->bridge.remote_pid = 0;
+        break;
+      }
+      msleep(10);
+    }
+    if(i>=100){
+      return -EAGAIN; // could not get the remote_pid
+    }
+  }
+
+  if(copy_to_user(buf, &pid, sizeof(uint32_t))){
+    return -EAGAIN;
+  }
+	return sizeof(uint32_t);
+}
+
+static const struct file_operations ifc_bridge_ops = {
+	.write		= ifc_write_bridge,
+  .read     = ifc_read_bridge,
+	.llseek		= generic_file_llseek,
+};
+
+static ssize_t ifc_write_file(struct file *file, const char __user *buf,
+				 size_t count, loff_t *ppos)
+
+{
+  struct ifc_file_change* change;
+  struct inode* in;
+  struct ifc_struct* ifc;
+  int rv = -EINVAL;
+#ifdef CONFIG_SECURITY_PROVENANCE
+  prov_msg_t* prov=NULL;
+#endif
+
+  if(__kuid_val(current_euid())!=0)
+    return -EPERM;
+
+  if(count < sizeof(struct ifc_file_change)){
+    printk(KERN_INFO "IFC: Too short.");
+    return -EINVAL;
+  }
+
+  change = (struct ifc_file_change*)buf;
+
+  if(!ifc_tag_valid(change->tag)){
+    return -EINVAL;
+  }
+
+  in = file_name_to_inode(change->name);
+  if(!in){
+    printk(KERN_ERR "IFC: could not find %s file.", change->name);
+    return -EINVAL;
+  }
+  ifc = inode_get_ifc(in);
+
+
+  if(change->op==IFC_ADD_TAG){
+    switch(change->tag_type){
+      case IFC_SECRECY:
+        rv=ifc_add_tag_no_check(&ifc->context, IFC_SECRECY, change->tag);
+        break;
+      case IFC_INTEGRITY:
+        rv=ifc_add_tag_no_check(&ifc->context, IFC_INTEGRITY, change->tag);
+        break;
+    }
+  }else{
+    switch(change->tag_type){
+      case IFC_SECRECY:
+        rv=ifc_remove_tag_no_check(&ifc->context, IFC_SECRECY, change->tag);
+        break;
+      case IFC_INTEGRITY:
+        rv=ifc_remove_tag_no_check(&ifc->context, IFC_INTEGRITY, change->tag);
+        break;
+    }
+  }
+
+#ifdef CONFIG_SECURITY_PROVENANCE
+  // mark as tracked depending of the label state
+  prov = inode_get_provenance(in);
+  prov_update_version(prov);
+  prov_record_ifc(prov, &ifc->context);
+  if(ifc_is_labelled(&ifc->context)){
+    prov->node_info.node_kern.tracked=NODE_TRACKED;
+  }else{
+    prov->node_info.node_kern.tracked=NODE_NOT_TRACKED;
+  }
+#endif
+
+  return rv;
+}
+
+static ssize_t ifc_read_file(struct file *filp, char __user *buf,
+				size_t count, loff_t *ppos)
+{
+  struct ifc_file_config *msg;
+  struct inode* in;
+  struct ifc_struct* ifc;
+
+  if(__kuid_val(current_euid())!=0)
+    return -EPERM;
+
+  if(count < sizeof(struct ifc_file_config)){
+    printk(KERN_INFO "IFC: Too short.");
+    return -EINVAL;
+  }
+
+  msg = (struct ifc_file_config*)buf;
+  in = file_name_to_inode(msg->name);
+  if(!in){
+    printk(KERN_ERR "IFC: could not find %s file.", msg->name);
+    return -EINVAL;
+  }else{
+    ifc = inode_get_ifc(in);
+    if(copy_to_user(&msg->context, &ifc->context, sizeof(struct ifc_context))){
+      printk(KERN_INFO "IFC: error copying.");
+      return -ENOMEM;
+    }
+  }
+  return sizeof(struct ifc_file_config);
+}
+
+static const struct file_operations ifc_file_ops = {
+	.write		= ifc_write_file,
+  .read     = ifc_read_file,
+	.llseek		= generic_file_llseek,
+};
+
+#define CRYPTO_DRIVER_NAME "blowfish"
+struct crypto_cipher *ifc_tfm = NULL;
+static const uint64_t ifc_key=0xAEF; // not safe
+
+int ifc_crypto_init(void){
+  ifc_tfm = crypto_alloc_cipher(CRYPTO_DRIVER_NAME, 0, 0);
+  if(IS_ERR((void *)ifc_tfm)){
+    printk(KERN_ERR "IFC: Failed to load transform for %s: %ld\n", CRYPTO_DRIVER_NAME, PTR_ERR(ifc_tfm));
+    ifc_tfm = NULL;
+    return PTR_ERR((void *)ifc_tfm);
+  }
+  return crypto_cipher_setkey(ifc_tfm, (const u8*)&ifc_key, sizeof(uint64_t));
+}
+
+static int __init init_ifc_fs(void)
+{
+  int rc;
+  struct dentry *ifc_dir= securityfs_create_dir("ifc", NULL);
+
+  securityfs_create_file("self", 0666, ifc_dir, NULL, &ifc_self_ops);
+  securityfs_create_file("tag", 0644, ifc_dir, NULL, &ifc_tag_ops);
+  securityfs_create_file("process", 0666, ifc_dir, NULL, &ifc_process_ops);
+  securityfs_create_file("bridge", 0666, ifc_dir, NULL, &ifc_bridge_ops);
+  securityfs_create_file("file", 0600, ifc_dir, NULL, &ifc_file_ops);
+  rc = ifc_crypto_init();
+  if(rc){
+    printk(KERN_ERR "IFC: cannot alloc crypto cipher. Error: %d.\n", rc);
+  }
+#ifdef CONFIG_SECURITY_PROVENANCE
+  printk(KERN_INFO "IFC: activivating provenance capture.");
+  prov_enabled = true;
+#endif
+  return 0;
+}
+
+__initcall(init_ifc_fs);
diff -uprN ./pristine/linux-4.4.6/security/ifc/hooks.c ./linux-4.4.6/security/ifc/hooks.c
--- ./pristine/linux-4.4.6/security/ifc/hooks.c	1970-01-01 01:00:00.000000000 +0100
+++ ./linux-4.4.6/security/ifc/hooks.c	2016-05-26 17:22:39.811013999 +0200
@@ -0,0 +1,781 @@
+/*
+*
+* /linux/security/ifc/hooks.c
+*
+* Author: Thomas Pasquier <tfjmp2@cam.ac.uk>
+*
+* Copyright (C) 2015 University of Cambridge
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License version 2, as
+* published by the Free Software Foundation.
+*
+*/
+
+#include <linux/provenance.h>
+#include <linux/camflow.h>
+#include <linux/ifc.h>
+#include <linux/slab.h>
+#include <linux/lsm_hooks.h>
+#include <linux/msg.h>
+#include <net/sock.h>
+#include <linux/binfmts.h>
+#include <linux/random.h>
+#include <linux/xattr.h>
+
+struct kmem_cache *ifc_cache=NULL;
+
+static inline struct ifc_struct* alloc_ifc(gfp_t gfp)
+{
+  struct ifc_struct* ifc =  kmem_cache_zalloc(ifc_cache, gfp);
+  if(!ifc){
+    return NULL;
+  }
+  return ifc;
+}
+
+static inline struct ifc_struct* inherit_ifc(struct ifc_struct* old, gfp_t gfp)
+{
+  struct ifc_struct* ifc =  kmem_cache_zalloc(ifc_cache, gfp);
+  if(!ifc)
+    return NULL;
+
+  if(!old)
+    return ifc;
+  /* copy tags */
+  memcpy(&ifc->context.secrecy, &old->context.secrecy, sizeof(struct ifc_label));
+  memcpy(&ifc->context.integrity, &old->context.integrity, sizeof(struct ifc_label));
+  return ifc;
+}
+
+static inline void free_ifc(struct ifc_struct* ifc){
+  kmem_cache_free(ifc_cache, ifc);
+}
+
+/*
+* @cred points to the credentials.
+* @gfp indicates the atomicity of any memory allocations.
+* Only allocate sufficient memory and attach to @cred such that
+* cred_transfer() will not get ENOMEM.
+*/
+static int ifc_cred_alloc_blank(struct cred *cred, gfp_t gfp)
+{
+  struct ifc_struct* ifc = alloc_ifc(gfp);
+  if(!ifc){
+    return -ENOMEM;
+  }
+  cred->ifc = ifc;
+  return 0;
+}
+
+/*
+* @cred points to the credentials.
+* Deallocate and clear the cred->security field in a set of credentials.
+*/
+static void ifc_cred_free(struct cred *cred)
+{
+  free_ifc(cred->ifc);
+  cred->ifc = NULL;
+}
+
+/*
+* @new points to the new credentials.
+* @old points to the original credentials.
+* @gfp indicates the atomicity of any memory allocations.
+* Prepare a new set of credentials by copying the data from the old set.
+*/
+static int ifc_cred_prepare(struct cred *new, const struct cred *old, gfp_t gfp)
+{
+  struct ifc_struct *old_ifc = old->ifc;
+  struct ifc_struct *new_ifc, *caller_ifc;
+  pid_t cpid;
+  struct task_struct* dest;
+  const struct cred* caller;
+
+  if(unlikely(old_ifc->bridge.spawner==true)){
+    new_ifc = alloc_ifc(gfp);
+    if(!new_ifc){
+      return -ENOMEM;
+    }
+    new_ifc->bridge.remote_pid = old_ifc->bridge.remote_pid;
+    new_ifc->bridge.bridge=true;
+    cpid = task_pid_vnr(current);
+    dest = find_task_by_vpid(new_ifc->bridge.remote_pid);
+    if(dest==NULL){
+      return -EFAULT;
+    }
+    caller = __task_cred(dest);
+    caller_ifc = caller->ifc;
+    caller_ifc->bridge.remote_pid = cpid;
+  }else{
+    new_ifc = inherit_ifc(old_ifc, gfp);
+  }
+
+  new->ifc=new_ifc;
+	return 0;
+}
+
+/*
+* @new points to the new credentials.
+* @old points to the original credentials.
+* Transfer data from original creds to new creds
+*/
+static void ifc_cred_transfer(struct cred *new, const struct cred *old)
+{
+  struct ifc_struct *old_ifc = old->ifc;
+	struct ifc_struct *ifc = new->ifc;
+
+  *old_ifc=*ifc;
+}
+
+/*
+* Allocate and attach a security structure to @inode->i_security.  The
+* i_security field is initialized to NULL when the inode structure is
+* allocated.
+* @inode contains the inode structure.
+* Return 0 if operation was successful.
+*/
+static int ifc_inode_alloc_security(struct inode *inode)
+{
+  struct ifc_struct* cifc = current_ifc();
+  struct ifc_struct* ifc = inherit_ifc(cifc, GFP_KERNEL);
+  if(!ifc){
+    return -ENOMEM;
+  }
+  alloc_camflow(inode, GFP_KERNEL);
+  inode_set_ifc(inode, (void**)&ifc);
+  return 0;
+}
+
+/*
+* @inode contains the inode structure.
+* Deallocate the inode security structure and set @inode->i_security to
+* NULL.
+*/
+static void ifc_inode_free_security(struct inode *inode)
+{
+  struct ifc_struct* ifc = inode_get_ifc(inode);
+  if(!ifc)
+    free_ifc(ifc);
+	inode_set_ifc(inode, NULL);
+	free_camflow(inode);
+}
+
+/*
+* Check permission before accessing an inode.  This hook is called by the
+* existing Linux permission function, so a security module can use it to
+* provide additional checking for existing Linux permission checks.
+* Notice that this hook is called when a file is opened (as well as many
+* other operations), whereas the file_security_ops permission hook is
+* called when the actual read/write operations are performed.
+* @inode contains the inode structure to check.
+* @mask contains the permission mask.
+* Return 0 if permission is granted.
+*/
+static int ifc_inode_permission(struct inode *inode, int mask)
+{
+  struct ifc_struct* cifc = current_ifc();
+  struct ifc_struct* ifc=NULL;
+#ifdef CONFIG_SECURITY_PROVENANCE
+	prov_msg_t *i_prov=NULL;
+  prov_msg_t *p_prov=NULL;
+#endif
+
+  if((mask & MAY_EXEC)!=0)
+    return 0;
+
+  mask &= (MAY_READ|MAY_WRITE|MAY_APPEND);
+  // no permission to check. Existence test
+  if (!mask)
+		return 0;
+
+  if(unlikely(IS_PRIVATE(inode)))
+		return 0;
+
+  ifc = inode_get_ifc(inode);
+  if(!ifc){
+    ifc_inode_alloc_security(inode);
+    ifc = inode_get_ifc(inode);
+  }
+
+#ifdef CONFIG_SECURITY_PROVENANCE
+  i_prov=inode_get_provenance(inode);
+  p_prov=current_provenance();
+  if(ifc_is_labelled(&cifc->context))
+    p_prov->node_info.node_kern.tracked=NODE_TRACKED;
+
+  if(ifc_is_labelled(&ifc->context))
+    i_prov->node_info.node_kern.tracked=NODE_TRACKED;
+#endif
+
+  if((mask & (MAY_WRITE|MAY_APPEND)) != 0){
+    // process -> inode
+    if(!ifc_can_flow(&cifc->context, &ifc->context)){
+#ifdef CONFIG_SECURITY_PROVENANCE
+      record_edge(ED_DATA, p_prov, i_prov, FLOW_DISALLOWED);
+#endif
+      return -EPERM;
+    }
+  }
+  if((mask & (MAY_READ)) != 0){
+    // inode -> process
+    if(!ifc_can_flow(&ifc->context, &cifc->context)){
+#ifdef CONFIG_SECURITY_PROVENANCE
+      record_edge(ED_DATA, i_prov, p_prov, FLOW_DISALLOWED);
+#endif
+      return -EPERM;
+    }
+  }
+  return 0;
+}
+
+/*
+* Check file permissions before accessing an open file.  This hook is
+* called by various operations that read or write files.  A security
+* module can use this hook to perform additional checking on these
+* operations, e.g.  to revalidate permissions on use to support privilege
+* bracketing or policy changes.  Notice that this hook is used when the
+* actual read/write operations are performed, whereas the
+* inode_security_ops hook is called when a file is opened (as well as
+* many other operations).
+* Caveat:  Although this hook can be used to revalidate permissions for
+* various system call operations that read or write files, it does not
+* address the revalidation of permissions for memory-mapped files.
+* Security modules must handle this separately if they need such
+* revalidation.
+* @file contains the file structure being accessed.
+* @mask contains the requested permissions.
+* Return 0 if permission is granted.
+*/
+static int ifc_file_permission(struct file *file, int mask)
+{
+  struct inode *inode = file_inode(file);
+  return ifc_inode_permission(inode, mask);
+}
+
+/*
+* Allocate and attach a security structure to the msg->security field.
+* The security field is initialized to NULL when the structure is first
+* created.
+* @msg contains the message structure to be modified.
+* Return 0 if operation was successful and permission is granted.
+*/
+static int ifc_msg_msg_alloc_security(struct msg_msg *msg)
+{
+  struct ifc_struct* cifc = current_ifc();
+  struct ifc_struct* ifc= inherit_ifc(cifc, GFP_KERNEL);
+
+  if(!ifc)
+    return -ENOMEM;
+  msg->ifc = ifc;
+  return 0;
+}
+
+/*
+* Deallocate the security structure for this message.
+* @msg contains the message structure to be modified.
+*/
+static void ifc_msg_msg_free_security(struct msg_msg *msg)
+{
+  struct ifc_struct* ifc = msg->ifc;
+  msg->ifc=NULL;
+  free_ifc(ifc);
+}
+
+/*
+* Check permission before a message, @msg, is enqueued on the message
+* queue, @msq.
+* @msq contains the message queue to send message to.
+* @msg contains the message to be enqueued.
+* @msqflg contains operational flags.
+* Return 0 if permission is granted.
+*/
+static int ifc_msg_queue_msgsnd(struct msg_queue *msq, struct msg_msg *msg, int msqflg)
+{
+  struct ifc_struct* cifc = current_ifc();
+  struct ifc_struct* ifc = msg->ifc;
+#ifdef CONFIG_SECURITY_PROVENANCE
+	prov_msg_t *p_prov=NULL;
+  prov_msg_t *m_prov=NULL;
+#endif
+
+  if(!ifc_can_flow(&cifc->context, &ifc->context)){
+#ifdef CONFIG_SECURITY_PROVENANCE
+    p_prov=current_provenance();
+    m_prov=msg->provenance;
+    record_edge(ED_DATA, p_prov, m_prov, FLOW_DISALLOWED);
+#endif
+    return -EPERM;
+  }
+  return 0;
+}
+
+/*
+* Check permission before a message, @msg, is removed from the message
+* queue, @msq.  The @target task structure contains a pointer to the
+* process that will be receiving the message (not equal to the current
+* process when inline receives are being performed).
+* @msq contains the message queue to retrieve message from.
+* @msg contains the message destination.
+* @target contains the task structure for recipient process.
+* @type contains the type of message requested.
+* @mode contains the operational flags.
+* Return 0 if permission is granted.
+*/
+static int ifc_msg_queue_msgrcv(struct msg_queue *msq, struct msg_msg *msg,
+				    struct task_struct *target,
+				    long type, int mode)
+{
+  struct ifc_struct* cifc = target->cred->ifc;
+  struct ifc_struct* ifc = msg->ifc;
+#ifdef CONFIG_SECURITY_PROVENANCE
+	prov_msg_t *p_prov=NULL;
+  prov_msg_t *m_prov=NULL;
+#endif
+
+
+  if(!ifc_can_flow(&ifc->context, &cifc->context)){
+#ifdef CONFIG_SECURITY_PROVENANCE
+    p_prov = target->cred->provenance;
+    m_prov = msg->provenance;
+    record_edge(ED_DATA, m_prov, p_prov, FLOW_DISALLOWED);
+#endif
+    return -EPERM;
+  }
+
+  return 0;
+}
+
+/*
+* Check permissions for a mmap operation.  The @file may be NULL, e.g.
+* if mapping anonymous memory.
+* @file contains the file structure for file to map (may be NULL).
+* @reqprot contains the protection requested by the application.
+* @prot contains the protection that will be applied by the kernel.
+* @flags contains the operational flags.
+* Return 0 if permission is granted.
+*/
+static int ifc_mmap_file(struct file *file, unsigned long reqprot, unsigned long prot, unsigned long flags)
+{
+  struct ifc_struct* cifc = current_ifc();
+  struct ifc_struct* iifc;
+#ifdef CONFIG_SECURITY_PROVENANCE
+  prov_msg_t* cprov = current_provenance();
+  prov_msg_t* iprov;
+#endif
+  struct inode *inode;
+
+  if((prot & PROT_EXEC) != 0)
+    return 0;
+
+  if(file==NULL){ // what to do for NULL?
+    return 0;
+  }
+  inode = file_inode(file);
+  iifc = inode_get_ifc(inode);
+
+#ifdef CONFIG_SECURITY_PROVENANCE
+  iprov = inode_get_provenance(inode);
+#endif
+
+  prot &= (PROT_READ|PROT_WRITE);
+  //if((prot & (PROT_WRITE|PROT_EXEC)) != 0){
+  if((prot & PROT_WRITE) != 0){
+    if(!ifc_can_flow(&cifc->context, &iifc->context)){
+#ifdef CONFIG_SECURITY_PROVENANCE
+      record_edge(ED_MMAP, cprov, iprov, FLOW_DISALLOWED);
+#endif
+      return -EPERM;
+    }
+  }
+
+  if((prot & (PROT_READ|PROT_WRITE)) != 0){
+    // we assume write imply read
+    if(!ifc_can_flow(&iifc->context, &cifc->context)){
+#ifdef CONFIG_SECURITY_PROVENANCE
+      record_edge(ED_MMAP, iprov, cprov, FLOW_DISALLOWED);
+#endif
+      return -EPERM;
+    }
+  }
+  return 0;
+}
+
+/*
+* Allocate and attach a security structure to the shp->shm_perm.security
+* field.  The security field is initialized to NULL when the structure is
+* first created.
+* @shp contains the shared memory structure to be modified.
+* Return 0 if operation was successful and permission is granted.
+*/
+static int ifc_shm_alloc_security(struct shmid_kernel *shp)
+{
+  struct ifc_struct* cifc = current_ifc();
+  struct ifc_struct* sifc= inherit_ifc(cifc, GFP_KERNEL);
+
+  if(!sifc)
+    return -ENOMEM;
+
+  shp->shm_perm.ifc=sifc;
+	return 0;
+}
+
+/*
+* Deallocate the security struct for this memory segment.
+* @shp contains the shared memory structure to be modified.
+*/
+static void ifc_shm_free_security(struct shmid_kernel *shp)
+{
+  free_ifc(shp->shm_perm.ifc);
+  shp->shm_perm.ifc=NULL;
+}
+
+/*
+* Check permissions prior to allowing the shmat system call to attach the
+* shared memory segment @shp to the data segment of the calling process.
+* The attaching address is specified by @shmaddr.
+* @shp contains the shared memory structure to be modified.
+* @shmaddr contains the address to attach memory region to.
+* @shmflg contains the operational flags.
+* Return 0 if permission is granted.
+*/
+static int ifc_shm_shmat(struct shmid_kernel *shp,
+			     char __user *shmaddr, int shmflg)
+{
+  struct ifc_struct* cifc = current_ifc();
+  struct ifc_struct* sifc = shp->shm_perm.ifc;
+#ifdef CONFIG_SECURITY_PROVENANCE
+  prov_msg_t* cprov = current_provenance();
+	prov_msg_t* sprov = shp->shm_perm.provenance;
+#endif
+
+  if(!sprov)
+    return -ENOMEM;
+
+  if(shmflg & SHM_RDONLY){
+    if(!ifc_can_flow(&sifc->context, &cifc->context)){
+#ifdef CONFIG_SECURITY_PROVENANCE
+      record_edge(ED_ATTACH, sprov, cprov, FLOW_DISALLOWED);
+#endif
+      return -EPERM;
+    }
+  }else{
+    if(!ifc_can_flow(&sifc->context, &cifc->context) || !ifc_can_flow(&cifc->context, &sifc->context)){
+#ifdef CONFIG_SECURITY_PROVENANCE
+      record_edge(ED_ATTACH, sprov, cprov, FLOW_DISALLOWED);
+      record_edge(ED_ATTACH, cprov, sprov, FLOW_DISALLOWED);
+#endif
+      return -EPERM;
+    }
+  }
+	return 0;
+}
+
+/*
+* Save security information in the bprm->security field, typically based
+* on information about the bprm->file, for later use by the apply_creds
+* hook.  This hook may also optionally check permissions (e.g. for
+* transitions between security domains).
+* This hook may be called multiple times during a single execve, e.g. for
+* interpreters.  The hook can tell whether it has already been called by
+* checking to see if @bprm->security is non-NULL.  If so, then the hook
+* may decide either to retain the security information saved earlier or
+* to replace it.
+* @bprm contains the linux_binprm structure.
+* Return 0 if the hook is successful and permission is granted.
+*/
+static int ifc_bprm_set_creds(struct linux_binprm *bprm){
+  int rv=0;
+  struct inode *inode = file_inode(bprm->file);
+  struct ifc_struct* old_ifc = current_ifc();
+  struct ifc_struct* new_ifc = bprm->cred->ifc;
+  struct ifc_struct* file_ifc = inode_get_ifc(inode);
+
+  if(!old_ifc && !file_ifc && !new_ifc){
+    if(ifc_is_labelled(&file_ifc->context)){
+      rv |= ifc_merge_context(&new_ifc->context, &file_ifc->context);
+    }
+    if(ifc_is_labelled(&old_ifc->context)){
+      rv |= ifc_merge_context(&new_ifc->context, &old_ifc->context);
+    }
+  }
+  return rv;
+}
+
+/*
+* Allocate and attach a security structure to the sk->sk_security field,
+* which is used to copy security attributes between local stream sockets.
+*/
+static int ifc_sk_alloc_security(struct sock *sk, int family, gfp_t priority)
+{
+  struct ifc_struct* cifc = current_ifc();
+  struct ifc_struct* ifc = alloc_ifc(priority);;
+  sk->sk_ifc=ifc;
+  if(!ifc_is_labelled(&cifc->context)){
+    return 0;
+  }
+
+  if(family!=AF_UNIX && family!=AF_NETLINK && family!=AF_ALG){
+    return -EPERM;
+  }
+  /* we trust socket to crypto stuff, should we? */
+  if(family==AF_ALG){
+    ifc->context.trusted = IFC_TRUSTED;
+  }else if(family==AF_UNIX){
+    ifc = inherit_ifc(cifc, priority);
+    sk->sk_ifc=ifc;
+  }
+  return 0;
+}
+
+/*
+* Deallocate security structure.
+*/
+static void ifc_sk_free_security(struct sock *sk)
+{
+  if(sk->sk_ifc!=NULL)
+    free_ifc(sk->sk_ifc);
+	sk->sk_ifc = NULL;
+}
+
+/*
+* This hook allows a module to update or allocate a per-socket security
+* structure. Note that the security field was not added directly to the
+* socket structure, but rather, the socket security information is stored
+* in the associated inode.  Typically, the inode alloc_security hook will
+* allocate and and attach security information to
+* sock->inode->i_security.  This hook may be used to update the
+* sock->inode->i_security field with additional information that wasn't
+* available when the inode was allocated.
+* @sock contains the newly created socket structure.
+* @family contains the requested protocol family.
+* @type contains the requested communications type.
+* @protocol contains the requested protocol.
+* @kern set to 1 if a kernel socket.
+*/
+static int ifc_socket_post_create(struct socket *sock, int family,
+				      int type, int protocol, int kern)
+{
+  struct ifc_struct* cifc  = current_ifc();
+  struct ifc_struct* iifc  = inode_get_ifc(SOCK_INODE(sock));
+  struct ifc_struct* skifc = NULL;
+  int rc;
+
+  if(kern){
+    return 0;
+  }
+
+  if(!sock->sk->sk_ifc){
+		rc = ifc_sk_alloc_security(sock->sk, family, GFP_KERNEL);
+    if(rc)
+      return rc;
+	}
+
+  if(!ifc_is_labelled(&cifc->context)){
+    return 0;
+  }
+
+  if(family!=AF_UNIX && family!=AF_NETLINK && family!=AF_ALG){
+    return -EPERM;
+  }
+
+  skifc = sock->sk->sk_ifc;
+
+  if(family==AF_NETLINK){
+    if(protocol!=NETLINK_CAMFLOW_IFC_BRIDGE){
+      return -EPERM;
+    }else{
+      skifc->context.trusted = IFC_TRUSTED;
+    }
+  }
+
+  memcpy(iifc, skifc, sizeof(struct ifc_struct));
+  return 0;
+}
+
+/*
+* Check permission before socket protocol layer bind operation is
+* performed and the socket @sock is bound to the address specified in the
+* @address parameter.
+* @sock contains the socket structure.
+* @address contains the address to bind to.
+* @addrlen contains the length of address.
+* Return 0 if permission is granted.
+*/
+static int ifc_socket_bind(struct socket *sock, struct sockaddr *address, int addrlen)
+{
+  return ifc_inode_permission(SOCK_INODE(sock), MAY_WRITE); // check if MAY_WRITE is ok
+}
+
+/*
+* Check permission before socket protocol layer connect operation
+* attempts to connect socket @sock to a remote address, @address.
+* @sock contains the socket structure.
+* @address contains the address of remote endpoint.
+* @addrlen contains the length of address.
+* Return 0 if permission is granted.
+*/
+static int ifc_socket_connect(struct socket *sock, struct sockaddr *address, int addrlen)
+{
+  return ifc_inode_permission(SOCK_INODE(sock), MAY_WRITE); // check if MAY_WRITE is ok
+}
+
+/*
+* Check permission before socket protocol layer listen operation.
+* @sock contains the socket structure.
+* @backlog contains the maximum length for the pending connection queue.
+* Return 0 if permission is granted.
+*/
+static int ifc_socket_listen(struct socket *sock, int backlog)
+{
+  return ifc_inode_permission(SOCK_INODE(sock), MAY_READ); // check if MAY_READ is ok
+}
+
+/*
+* Check permission before transmitting a message to another socket.
+* @sock contains the socket structure.
+* @msg contains the message to be transmitted.
+* @size contains the size of message.
+* Return 0 if permission is granted.
+*/
+static int ifc_socket_sendmsg(struct socket *sock, struct msghdr *msg,
+				  int size)
+{
+	return ifc_inode_permission(SOCK_INODE(sock), MAY_WRITE);
+}
+
+/*
+* Check permission before receiving a message from a socket.
+* @sock contains the socket structure.
+* @msg contains the message structure.
+* @size contains the size of message structure.
+* @flags contains the operational flags.
+* Return 0 if permission is granted.
+*/
+static int ifc_socket_recvmsg(struct socket *sock, struct msghdr *msg,
+				  int size, int flags)
+{
+	return ifc_inode_permission(SOCK_INODE(sock), MAY_READ);
+}
+
+/*
+* Check permission before accepting a new connection.  Note that the new
+* socket, @newsock, has been created and some information copied to it,
+* but the accept operation has not actually been performed.
+* @sock contains the listening socket structure.
+* @newsock contains the newly created server socket for connection.
+* Return 0 if permission is granted.
+*/
+static int ifc_socket_accept(struct socket *sock, struct socket *newsock)
+{
+  return ifc_inode_permission(SOCK_INODE(sock), MAY_READ);
+}
+
+/*
+* Check permissions before establishing a Unix domain stream connection
+* between @sock and @other.
+* @sock contains the sock structure.
+* @other contains the peer sock structure.
+* @newsk contains the new sock structure.
+* Return 0 if permission is granted.
+*/
+static int ifc_unix_stream_connect(struct sock *sock,
+					      struct sock *other,
+					      struct sock *newsk)
+{
+  struct ifc_struct* skifc = sock->sk_ifc;
+  struct ifc_struct* okifc = other->sk_ifc;
+  struct ifc_struct* nifc = newsk->sk_ifc;
+
+  if(!ifc_is_labelled(&skifc->context) && !ifc_is_labelled(&okifc->context))
+    return 0;
+
+  if(!ifc_can_flow(&skifc->context, &okifc->context))
+    return -EPERM;
+  if(!ifc_can_flow(&okifc->context, &skifc->context))
+    return -EPERM;
+  memcpy(nifc, skifc, sizeof(struct ifc_struct));
+  return 0;
+}
+
+/*
+* Check permissions before connecting or sending datagrams from @sock to
+* @other.
+* @sock contains the socket structure.
+* @other contains the peer socket structure.
+* Return 0 if permission is granted.
+*/
+static int ifc_unix_may_send(struct socket *sock,
+					struct socket *other)
+{
+  struct ifc_struct* skifc = sock->sk->sk_ifc;
+  struct ifc_struct* okifc = other->sk->sk_ifc;
+
+  if(!ifc_is_labelled(&skifc->context) && !ifc_is_labelled(&okifc->context))
+    return 0;
+
+  if(!ifc_can_flow(&skifc->context, &okifc->context))
+    return -EPERM;
+  return 0;
+}
+
+static struct security_hook_list ifc_hooks[] = {
+  LSM_HOOK_INIT(cred_alloc_blank, ifc_cred_alloc_blank),
+  LSM_HOOK_INIT(cred_free, ifc_cred_free),
+  LSM_HOOK_INIT(cred_prepare, ifc_cred_prepare),
+  LSM_HOOK_INIT(cred_transfer, ifc_cred_transfer),
+  LSM_HOOK_INIT(inode_alloc_security, ifc_inode_alloc_security),
+  LSM_HOOK_INIT(inode_free_security, ifc_inode_free_security),
+  LSM_HOOK_INIT(inode_permission, ifc_inode_permission),
+  LSM_HOOK_INIT(file_permission, ifc_file_permission),
+  LSM_HOOK_INIT(msg_msg_alloc_security, ifc_msg_msg_alloc_security),
+  LSM_HOOK_INIT(msg_msg_free_security, ifc_msg_msg_free_security),
+  LSM_HOOK_INIT(msg_queue_msgsnd, ifc_msg_queue_msgsnd),
+  LSM_HOOK_INIT(msg_queue_msgrcv, ifc_msg_queue_msgrcv),
+  LSM_HOOK_INIT(mmap_file, ifc_mmap_file),
+  LSM_HOOK_INIT(shm_alloc_security, ifc_shm_alloc_security),
+  LSM_HOOK_INIT(shm_free_security, ifc_shm_free_security),
+  LSM_HOOK_INIT(shm_shmat, ifc_shm_shmat),
+  LSM_HOOK_INIT(bprm_set_creds, ifc_bprm_set_creds),
+  LSM_HOOK_INIT(sk_alloc_security, ifc_sk_alloc_security),
+  LSM_HOOK_INIT(sk_free_security, ifc_sk_free_security),
+  LSM_HOOK_INIT(socket_post_create, ifc_socket_post_create),
+  LSM_HOOK_INIT(socket_bind, ifc_socket_bind),
+  LSM_HOOK_INIT(socket_connect, ifc_socket_connect),
+  LSM_HOOK_INIT(socket_listen, ifc_socket_listen),
+  LSM_HOOK_INIT(socket_sendmsg, ifc_socket_sendmsg),
+  LSM_HOOK_INIT(socket_recvmsg, ifc_socket_recvmsg),
+  LSM_HOOK_INIT(socket_accept, ifc_socket_accept),
+  LSM_HOOK_INIT(unix_stream_connect, ifc_unix_stream_connect),
+  LSM_HOOK_INIT(unix_may_send, ifc_unix_may_send)
+};
+
+/* init security of the first process */
+static void cred_init_security(void){
+	struct cred *cred = (struct cred *)current->real_cred;
+	struct ifc_struct *ifc;
+
+  ifc = alloc_ifc(GFP_KERNEL);
+	if(!ifc){
+		panic("IFC: Failed to initialize initial task.\n");
+	}
+	cred->ifc = ifc;
+}
+
+atomic64_t ifc_tag_count=ATOMIC64_INIT(1);
+
+struct kmem_cache *camflow_cache=NULL;
+
+void __init ifc_add_hooks(void){
+  ifc_cache = kmem_cache_create("ifc_struct",
+					    sizeof(struct ifc_struct),
+					    0, SLAB_PANIC, NULL);
+
+  camflow_cache = kmem_cache_create("camflow_i_ptr",
+					    sizeof(struct camflow_i_ptr),
+					    0, SLAB_PANIC, NULL);
+  cred_init_security();
+  security_add_hooks(ifc_hooks, ARRAY_SIZE(ifc_hooks));
+  printk(KERN_INFO "IFC Camflow %s\n", CAMFLOW_VERSION_STR);
+  printk(KERN_INFO "IFC hooks ready.\n");
+}
diff -uprN ./pristine/linux-4.4.6/security/ifc/Kconfig ./linux-4.4.6/security/ifc/Kconfig
--- ./pristine/linux-4.4.6/security/ifc/Kconfig	1970-01-01 01:00:00.000000000 +0100
+++ ./linux-4.4.6/security/ifc/Kconfig	2016-05-26 17:22:39.811013999 +0200
@@ -0,0 +1,9 @@
+config SECURITY_IFC
+         bool "IFC"
+         depends on SECURITY
+         select SECURITYFS
+         select CRYPTO_BLOWFISH_X86_64
+         default n
+         help
+          This selects IFC.
+          The IFC security module enforce DIFC.
diff -uprN ./pristine/linux-4.4.6/security/ifc/Makefile ./linux-4.4.6/security/ifc/Makefile
--- ./pristine/linux-4.4.6/security/ifc/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ ./linux-4.4.6/security/ifc/Makefile	2016-05-26 17:22:39.811013999 +0200
@@ -0,0 +1,6 @@
+#
+# Makefile for Provenance LSM
+#
+obj-$(CONFIG_SECURITY_IFC) := ifc.o
+
+ifc-y := hooks.o fs.o bridge.o
diff -uprN ./pristine/linux-4.4.6/security/Kconfig ./linux-4.4.6/security/Kconfig
--- ./pristine/linux-4.4.6/security/Kconfig	2016-03-16 16:43:17.000000000 +0100
+++ ./linux-4.4.6/security/Kconfig	2016-05-26 17:22:39.811013999 +0200
@@ -123,6 +123,8 @@ source security/smack/Kconfig
 source security/tomoyo/Kconfig
 source security/apparmor/Kconfig
 source security/yama/Kconfig
+source security/provenance/Kconfig
+source security/ifc/Kconfig
 
 source security/integrity/Kconfig
 
@@ -132,6 +134,8 @@ choice
 	default DEFAULT_SECURITY_SMACK if SECURITY_SMACK
 	default DEFAULT_SECURITY_TOMOYO if SECURITY_TOMOYO
 	default DEFAULT_SECURITY_APPARMOR if SECURITY_APPARMOR
+	default DEFAULT_SECURITY_PROVENANCE if SECURITY_PROVENANCE
+	default DEFAULT_SECURITY_IFC if SECURITY_IFC
 	default DEFAULT_SECURITY_DAC
 
 	help
@@ -150,6 +154,12 @@ choice
 	config DEFAULT_SECURITY_APPARMOR
 		bool "AppArmor" if SECURITY_APPARMOR=y
 
+	config DEFAULT_SECURITY_PROVENANCE
+		bool "Provenance" if SECURITY_PROVENANCE=y
+
+	config DEFAULT_SECURITY_IFC
+		bool "IFC" if SECURITY_IFC=y
+
 	config DEFAULT_SECURITY_DAC
 		bool "Unix Discretionary Access Controls"
 
@@ -161,7 +171,8 @@ config DEFAULT_SECURITY
 	default "smack" if DEFAULT_SECURITY_SMACK
 	default "tomoyo" if DEFAULT_SECURITY_TOMOYO
 	default "apparmor" if DEFAULT_SECURITY_APPARMOR
+	default "provenance" if DEFAULT_SECURITY_PROVENANCE
+	default "ifc" if DEFAULT_SECURITY_IFC
 	default "" if DEFAULT_SECURITY_DAC
 
 endmenu
-
diff -uprN ./pristine/linux-4.4.6/security/Makefile ./linux-4.4.6/security/Makefile
--- ./pristine/linux-4.4.6/security/Makefile	2016-03-16 16:43:17.000000000 +0100
+++ ./linux-4.4.6/security/Makefile	2016-05-26 17:22:39.811013999 +0200
@@ -8,6 +8,8 @@ subdir-$(CONFIG_SECURITY_SMACK)		+= smac
 subdir-$(CONFIG_SECURITY_TOMOYO)        += tomoyo
 subdir-$(CONFIG_SECURITY_APPARMOR)	+= apparmor
 subdir-$(CONFIG_SECURITY_YAMA)		+= yama
+subdir-$(CONFIG_SECURITY_PROVENANCE)	+= provenance
+subdir-$(CONFIG_SECURITY_IFC)	+= ifc
 
 # always enable default capabilities
 obj-y					+= commoncap.o
@@ -22,6 +24,8 @@ obj-$(CONFIG_AUDIT)			+= lsm_audit.o
 obj-$(CONFIG_SECURITY_TOMOYO)		+= tomoyo/
 obj-$(CONFIG_SECURITY_APPARMOR)		+= apparmor/
 obj-$(CONFIG_SECURITY_YAMA)		+= yama/
+obj-$(CONFIG_SECURITY_PROVENANCE)		+= provenance/
+obj-$(CONFIG_SECURITY_IFC)		+= ifc/
 obj-$(CONFIG_CGROUP_DEVICE)		+= device_cgroup.o
 
 # Object integrity file lists
diff -uprN ./pristine/linux-4.4.6/security/provenance/fs.c ./linux-4.4.6/security/provenance/fs.c
--- ./pristine/linux-4.4.6/security/provenance/fs.c	1970-01-01 01:00:00.000000000 +0100
+++ ./linux-4.4.6/security/provenance/fs.c	2016-05-26 17:22:39.813013999 +0200
@@ -0,0 +1,343 @@
+/*
+*
+* /linux/security/provenance/fs.c
+*
+* Author: Thomas Pasquier <tfjmp2@cam.ac.uk>
+*
+* Copyright (C) 2015 University of Cambridge
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License version 2, as
+* published by the Free Software Foundation.
+*
+*/
+
+#include <linux/security.h>
+#include <linux/provenance.h>
+
+#define TMPBUFLEN	12
+
+bool prov_enabled=false;
+
+static ssize_t prov_write_enable(struct file *file, const char __user *buf,
+				 size_t count, loff_t *ppos)
+
+{
+  char* page = NULL;
+  ssize_t length;
+  bool new_value;
+  int tmp;
+
+  /* no partial write */
+  if(*ppos > 0)
+    return -EINVAL;
+
+  if(__kuid_val(current_euid())!=0)
+    return -EPERM;
+
+  page = (char *)get_zeroed_page(GFP_KERNEL);
+  if (!page)
+    return -ENOMEM;
+
+  length=-EFAULT;
+	if (copy_from_user(page, buf, count))
+		goto out;
+
+  length = -EINVAL;
+  if (sscanf(page, "%d", &tmp) != 1)
+		goto out;
+
+  new_value=tmp;
+  if(new_value!=prov_enabled){
+    if(new_value)
+      prov_print("Enabling provenance capture");
+    else
+      prov_print("Disabling provenance capture");
+    prov_enabled=new_value;
+  }
+  length=count;
+out:
+  free_page((unsigned long)page);
+  return length;
+}
+
+static ssize_t prov_read_enable(struct file *filp, char __user *buf,
+				size_t count, loff_t *ppos)
+{
+	char tmpbuf[TMPBUFLEN];
+	ssize_t length;
+  int tmp = prov_enabled;
+
+	length = scnprintf(tmpbuf, TMPBUFLEN, "%d", tmp);
+	return simple_read_from_buffer(buf, count, ppos, tmpbuf, length);
+}
+
+static const struct file_operations prov_enable_ops = {
+	.write		= prov_write_enable,
+  .read     = prov_read_enable,
+	.llseek		= generic_file_llseek,
+};
+
+bool prov_all=false;
+
+static ssize_t prov_write_all(struct file *file, const char __user *buf,
+				 size_t count, loff_t *ppos)
+
+{
+  char* page = NULL;
+  ssize_t length;
+  bool new_value;
+  int tmp;
+
+  /* no partial write */
+  if(*ppos > 0)
+    return -EINVAL;
+
+  if(__kuid_val(current_euid())!=0)
+    return -EPERM;
+
+  page = (char *)get_zeroed_page(GFP_KERNEL);
+  if (!page)
+    return -ENOMEM;
+
+  length=-EFAULT;
+	if (copy_from_user(page, buf, count))
+		goto out;
+
+  length = -EINVAL;
+  if (sscanf(page, "%d", &tmp) != 1)
+		goto out;
+
+  new_value=tmp;
+  if(new_value!=prov_all){
+    if(new_value)
+      prov_print("Enabling all capture");
+    else
+      prov_print("Disabling all capture");
+    prov_all=new_value;
+  }
+  length=count;
+out:
+  free_page((unsigned long)page);
+  return length;
+}
+
+static ssize_t prov_read_all(struct file *filp, char __user *buf,
+				size_t count, loff_t *ppos)
+{
+	char tmpbuf[TMPBUFLEN];
+	ssize_t length;
+  int tmp = prov_all;
+
+	length = scnprintf(tmpbuf, TMPBUFLEN, "%d", tmp);
+	return simple_read_from_buffer(buf, count, ppos, tmpbuf, length);
+}
+
+static const struct file_operations prov_all_ops = {
+	.write		= prov_write_all,
+  .read     = prov_read_all,
+	.llseek		= generic_file_llseek,
+};
+
+static ssize_t prov_write_opaque(struct file *file, const char __user *buf,
+				 size_t count, loff_t *ppos)
+
+{
+	prov_msg_t* cprov = current_provenance();
+  char* page = NULL;
+  ssize_t length;
+  int tmp;
+
+  /* no partial write */
+  if(*ppos > 0)
+    return -EINVAL;
+
+  if(__kuid_val(current_euid())!=0)
+    return -EPERM;
+
+  page = (char *)get_zeroed_page(GFP_KERNEL);
+  if (!page)
+    return -ENOMEM;
+
+  length=-EFAULT;
+	if (copy_from_user(page, buf, count))
+		goto out;
+
+  length = -EINVAL;
+  if (sscanf(page, "%d", &tmp) != 1)
+		goto out;
+
+	cprov->task_info.node_kern.opaque=tmp;
+  length=count;
+out:
+  free_page((unsigned long)page);
+  return length;
+}
+
+static ssize_t prov_read_opaque(struct file *filp, char __user *buf,
+				size_t count, loff_t *ppos)
+{
+	prov_msg_t* cprov = current_provenance();
+	char tmpbuf[TMPBUFLEN];
+	ssize_t length;
+  int tmp = cprov->task_info.node_kern.opaque;
+
+	length = scnprintf(tmpbuf, TMPBUFLEN, "%d", tmp);
+	return simple_read_from_buffer(buf, count, ppos, tmpbuf, length);
+}
+
+static const struct file_operations prov_opaque_ops = {
+	.write		= prov_write_opaque,
+  .read     = prov_read_opaque,
+	.llseek		= generic_file_llseek,
+};
+
+static ssize_t prov_write_node(struct file *file, const char __user *buf,
+				 size_t count, loff_t *ppos)
+
+{
+	prov_msg_t* node = (prov_msg_t*)buf;
+
+	if(count < sizeof(struct disc_node_struct))
+	{
+		return -ENOMEM;
+	}
+
+	set_node_id(node, ASSIGN_NODE_ID);
+	node->disc_node_info.msg_info.type = MSG_DISC_NODE;
+	prov_write(node);
+	return count;
+}
+
+static ssize_t prov_read_node(struct file *filp, char __user *buf,
+				size_t count, loff_t *ppos)
+{
+	return -EPERM; // write only
+}
+
+static const struct file_operations prov_node_ops = {
+	.write		= prov_write_node,
+  .read     = prov_read_node,
+	.llseek		= generic_file_llseek,
+};
+
+static ssize_t prov_write_edge(struct file *file, const char __user *buf,
+				 size_t count, loff_t *ppos)
+{
+	prov_msg_t edge;
+
+	if(count < sizeof(struct edge_struct))
+	{
+		return -ENOMEM;
+	}
+	if(copy_from_user(&edge, buf, sizeof(struct edge_struct))){
+		return -ENOMEM;
+	}
+	edge.msg_info.msg_info.type=MSG_EDGE;
+	prov_write(&edge);
+	return count;
+}
+
+static ssize_t prov_read_edge(struct file *filp, char __user *buf,
+				size_t count, loff_t *ppos)
+{
+	return -EPERM; // write only
+}
+
+static const struct file_operations prov_edge_ops = {
+	.write		= prov_write_edge,
+  .read     = prov_read_edge,
+	.llseek		= generic_file_llseek,
+};
+
+static ssize_t prov_write_self(struct file *file, const char __user *buf,
+				 size_t count, loff_t *ppos)
+{
+	return -EPERM; // read only
+}
+
+static ssize_t prov_read_self(struct file *filp, char __user *buf,
+				size_t count, loff_t *ppos)
+{
+	prov_msg_t* tmp = (prov_msg_t*)buf;
+	prov_msg_t* cprov = current_provenance();
+
+	if(count < sizeof(struct task_prov_struct))
+	{
+		return -ENOMEM;
+	}
+	if(copy_to_user(tmp, cprov, sizeof(prov_msg_t))){
+		return -EAGAIN;
+	}
+	record_node(cprov); // record self
+	return count; // write only
+}
+
+static const struct file_operations prov_self_ops = {
+	.write		= prov_write_self,
+  .read     = prov_read_self,
+	.llseek		= generic_file_llseek,
+};
+
+static ssize_t prov_write_machine_id(struct file *file, const char __user *buf,
+				 size_t count, loff_t *ppos)
+{
+	uint32_t* tmp = (uint32_t*)buf;
+
+	if(__kuid_val(current_euid())!=0) // only allowed for root
+    return -EPERM;
+
+	if(count < sizeof(uint32_t))
+	{
+		return -ENOMEM;
+	}
+
+	if(copy_from_user(&prov_machine_id, tmp, sizeof(uint32_t)))
+	{
+		return -EAGAIN;
+	}
+	printk(KERN_INFO "Provenance: machine_id set to %u.", prov_machine_id);
+
+	return count; // read only
+}
+
+static ssize_t prov_read_machine_id(struct file *filp, char __user *buf,
+				size_t count, loff_t *ppos)
+{
+	uint32_t* tmp = (uint32_t*)buf;
+
+	if(count < sizeof(uint32_t))
+	{
+		return -ENOMEM;
+	}
+
+	if(copy_to_user(tmp, &prov_machine_id, sizeof(uint32_t)))
+	{
+		return -EAGAIN;
+	}
+	return count; // write only
+}
+
+static const struct file_operations prov_machine_id_ops = {
+	.write		= prov_write_machine_id,
+  .read     = prov_read_machine_id,
+	.llseek		= generic_file_llseek,
+};
+
+static int __init init_prov_fs(void)
+{
+   struct dentry *prov_dir;
+
+   prov_dir = securityfs_create_dir("provenance", NULL);
+
+   securityfs_create_file("enable", 0644, prov_dir, NULL, &prov_enable_ops);
+	 securityfs_create_file("all", 0644, prov_dir, NULL, &prov_all_ops);
+	 securityfs_create_file("opaque", 0644, prov_dir, NULL, &prov_opaque_ops);
+	 securityfs_create_file("node", 0666, prov_dir, NULL, &prov_node_ops);
+	 securityfs_create_file("edge", 0666, prov_dir, NULL, &prov_edge_ops);
+	 securityfs_create_file("self", 0444, prov_dir, NULL, &prov_self_ops);
+	 securityfs_create_file("machine_id", 0444, prov_dir, NULL, &prov_machine_id_ops);
+   return 0;
+}
+
+__initcall(init_prov_fs);
diff -uprN ./pristine/linux-4.4.6/security/provenance/hooks.c ./linux-4.4.6/security/provenance/hooks.c
--- ./pristine/linux-4.4.6/security/provenance/hooks.c	1970-01-01 01:00:00.000000000 +0100
+++ ./linux-4.4.6/security/provenance/hooks.c	2016-05-26 17:22:39.813013999 +0200
@@ -0,0 +1,982 @@
+/*
+*
+* /linux/security/provenance/hooks.c
+*
+* Author: Thomas Pasquier <tfjmp2@cam.ac.uk>
+*
+* Copyright (C) 2015 University of Cambridge
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License version 2, as
+* published by the Free Software Foundation.
+*
+*/
+
+#include <linux/provenance.h>
+#include <linux/ifc.h>
+#include <linux/slab.h>
+#include <linux/lsm_hooks.h>
+#include <linux/msg.h>
+#include <net/sock.h>
+#include <linux/binfmts.h>
+#include <linux/random.h>
+#include <linux/xattr.h>
+#include <linux/camflow.h>
+
+struct kmem_cache *provenance_cache=NULL;
+struct kmem_cache *long_provenance_cache=NULL;
+
+/*
+ * initialise the security for the init task
+ */
+static void cred_init_provenance(void)
+{
+	struct cred *cred = (struct cred *) current->real_cred;
+	prov_msg_t *prov = alloc_provenance(MSG_TASK, GFP_KERNEL);
+	if (!prov)
+		panic("Provenance:  Failed to initialize initial task.\n");
+  set_node_id(prov, ASSIGN_NODE_ID);
+  prov->task_info.uid=__kuid_val(cred->euid);
+  prov->task_info.gid=__kgid_val(cred->egid);
+
+	cred->provenance = prov;
+}
+
+/*
+* @cred points to the credentials.
+* @gfp indicates the atomicity of any memory allocations.
+* Only allocate sufficient memory and attach to @cred such that
+* cred_transfer() will not get ENOMEM.
+*/
+static int provenance_cred_alloc_blank(struct cred *cred, gfp_t gfp)
+{
+  prov_msg_t* prov  = alloc_provenance(MSG_TASK, gfp);
+
+  if(!prov)
+    return -ENOMEM;
+  set_node_id(prov, ASSIGN_NODE_ID);
+
+  prov->task_info.uid=__kuid_val(cred->euid);
+  prov->task_info.gid=__kgid_val(cred->egid);
+
+  cred->provenance = prov;
+  return 0;
+}
+
+/*
+* @cred points to the credentials.
+* Deallocate and clear the cred->security field in a set of credentials.
+*/
+static void provenance_cred_free(struct cred *cred)
+{
+  free_provenance(cred->provenance);
+  cred->provenance = NULL;
+}
+
+/*
+* @new points to the new credentials.
+* @old points to the original credentials.
+* @gfp indicates the atomicity of any memory allocations.
+* Prepare a new set of credentials by copying the data from the old set.
+*/
+static int provenance_cred_prepare(struct cred *new, const struct cred *old, gfp_t gfp)
+{
+  prov_msg_t* old_prov = old->provenance;
+  prov_msg_t* prov = alloc_provenance(MSG_TASK, gfp);
+#ifdef CONFIG_SECURITY_IFC
+	struct ifc_struct *new_ifc;
+#endif
+
+  if(!prov){
+    return -ENOMEM;
+  }
+  set_node_id(prov, ASSIGN_NODE_ID);
+  prov->task_info.uid=__kuid_val(new->euid);
+  prov->task_info.gid=__kgid_val(new->egid);
+
+#ifdef CONFIG_SECURITY_IFC
+	new_ifc = new->ifc;
+	if(ifc_is_labelled(&new_ifc->context)){
+		prov->node_info.node_kern.tracked=NODE_TRACKED;
+		prov_record_ifc(prov, &new_ifc->context);
+	}
+#endif
+
+  record_edge(ED_CREATE, old_prov, prov, FLOW_ALLOWED);
+  new->provenance = prov;
+  return 0;
+}
+
+/*
+* @new points to the new credentials.
+* @old points to the original credentials.
+* Transfer data from original creds to new creds
+*/
+static void provenance_cred_transfer(struct cred *new, const struct cred *old)
+{
+  const prov_msg_t *old_prov = old->provenance;
+	prov_msg_t *prov = new->provenance;
+
+  *prov=*old_prov;
+}
+
+/*
+* Update the module's state after setting one or more of the user
+* identity attributes of the current process.  The @flags parameter
+* indicates which of the set*uid system calls invoked this hook.  If
+* @new is the set of credentials that will be installed.  Modifications
+* should be made to this rather than to @current->cred.
+* @old is the set of credentials that are being replaces
+* @flags contains one of the LSM_SETID_* values.
+* Return 0 on success.
+*/
+static int provenance_task_fix_setuid(struct cred *new, const struct cred *old, int flags)
+{
+  prov_msg_t *old_prov = old->provenance;
+	prov_msg_t *prov = new->provenance;
+
+  record_edge(ED_CHANGE, old_prov, prov, FLOW_ALLOWED);
+  return 0;
+}
+
+/*
+* Allocate and attach a security structure to @inode->i_security.  The
+* i_security field is initialized to NULL when the inode structure is
+* allocated.
+* @inode contains the inode structure.
+* Return 0 if operation was successful.
+*/
+static int provenance_inode_alloc_security(struct inode *inode)
+{
+	prov_msg_t* cprov = current_provenance();
+  prov_msg_t* iprov = alloc_provenance(MSG_INODE, GFP_KERNEL);
+  prov_msg_t* sprov;
+#ifdef CONFIG_SECURITY_IFC
+	struct ifc_struct *ifc=NULL;
+#endif
+
+  if(unlikely(!iprov))
+    return -ENOMEM;
+  set_node_id(iprov, inode->i_ino);
+
+  iprov->inode_info.uid=__kuid_val(inode->i_uid);
+  iprov->inode_info.gid=__kgid_val(inode->i_gid);
+  iprov->inode_info.mode=inode->i_mode;
+  sprov = inode->i_sb->s_provenance;
+  memcpy(iprov->inode_info.sb_uuid, sprov->sb_info.uuid, 16*sizeof(uint8_t));
+
+	alloc_camflow(inode, GFP_KERNEL);
+  inode_set_provenance(inode, (void**)&iprov);
+
+#ifdef CONFIG_SECURITY_IFC
+	ifc = inode_get_ifc(inode);
+	if(ifc_is_labelled(&ifc->context)){
+		iprov->node_info.node_kern.tracked=NODE_TRACKED;
+		prov_record_ifc(iprov, &ifc->context);
+	}
+#endif
+
+  record_edge(ED_CREATE, cprov, iprov, FLOW_ALLOWED); /* creating inode != creating the file */
+  return 0;
+}
+
+/*
+* @inode contains the inode structure.
+* Deallocate the inode security structure and set @inode->i_security to
+* NULL.
+*/
+static void provenance_inode_free_security(struct inode *inode)
+{
+  prov_msg_t* prov = inode_get_provenance(inode);
+  if(!prov)
+    free_provenance(prov);
+	inode_set_provenance(inode, NULL);
+	free_camflow(inode);
+}
+
+/*
+* Check permission before accessing an inode.  This hook is called by the
+* existing Linux permission function, so a security module can use it to
+* provide additional checking for existing Linux permission checks.
+* Notice that this hook is called when a file is opened (as well as many
+* other operations), whereas the file_security_ops permission hook is
+* called when the actual read/write operations are performed.
+* @inode contains the inode structure to check.
+* @mask contains the permission mask.
+* Return 0 if permission is granted.
+*/
+static int provenance_inode_permission(struct inode *inode, int mask)
+{
+  prov_msg_t* cprov = current_provenance();
+  prov_msg_t* iprov;
+
+	if(unlikely(IS_PRIVATE(inode)))
+		return 0;
+
+	iprov = inode_get_provenance(inode);
+  if(!iprov){ // alloc provenance if none there
+    provenance_inode_alloc_security(inode);
+		iprov = inode_get_provenance(inode);
+  }
+
+  mask &= (MAY_READ|MAY_WRITE|MAY_EXEC|MAY_APPEND);
+
+  if((mask & (MAY_WRITE|MAY_APPEND)) != 0){
+    record_edge(ED_DATA, cprov, iprov, FLOW_ALLOWED);
+  }
+  if((mask & (MAY_READ|MAY_EXEC)) != 0){
+    record_edge(ED_DATA, iprov, cprov, FLOW_ALLOWED);
+  }
+  return 0;
+}
+
+/*
+* Check permission before creating a new hard link to a file.
+* @old_dentry contains the dentry structure for an existing
+* link to the file.
+* @dir contains the inode structure of the parent directory
+* of the new link.
+* @new_dentry contains the dentry structure for the new link.
+* Return 0 if permission is granted.
+*/
+
+static int provenance_inode_link(struct dentry *old_dentry, struct inode *dir, struct dentry *new_dentry)
+{
+  prov_msg_t* cprov = current_provenance();
+  prov_msg_t* dprov;
+  prov_msg_t* iprov;
+  long_prov_msg_t* link_prov;
+
+  if(!inode_get_provenance(dir)){ // alloc provenance if none there
+    provenance_inode_alloc_security(dir);
+  }
+
+  if(!inode_get_provenance(old_dentry->d_inode)){
+    provenance_inode_alloc_security(old_dentry->d_inode);
+  }
+
+  dprov = inode_get_provenance(dir); // directory
+  iprov = inode_get_provenance(old_dentry->d_inode); // inode pointed by dentry
+
+  // writing to the directory
+  record_edge(ED_DATA, cprov, dprov, FLOW_ALLOWED);
+  record_edge(ED_DATA, cprov, iprov, FLOW_ALLOWED);
+
+  if(prov_enabled && (provenance_is_tracked(iprov) || provenance_is_tracked(dprov) || provenance_is_tracked(cprov))){
+    link_prov = alloc_long_provenance(MSG_LINK, GFP_KERNEL);
+    link_prov->link_info.length = new_dentry->d_name.len;
+    memcpy(link_prov->link_info.name, new_dentry->d_name.name, new_dentry->d_name.len);
+		copy_node_info(&link_prov->link_info.dir, &dprov->inode_info.node_info);
+		copy_node_info(&link_prov->link_info.task, &cprov->task_info.node_info);
+		copy_node_info(&link_prov->link_info.inode, &iprov->task_info.node_info);
+    long_prov_write(link_prov);
+    free_long_provenance(link_prov);
+  }
+  return 0;
+}
+
+/*
+* Check the permission to remove a hard link to a file.
+* @dir contains the inode structure of parent directory of the file.
+* @dentry contains the dentry structure for file to be unlinked.
+* Return 0 if permission is granted.
+*/
+static int provenance_inode_unlink(struct inode *dir, struct dentry *dentry)
+{
+  prov_msg_t* cprov = current_provenance();
+  prov_msg_t* dprov;
+  prov_msg_t* iprov;
+  long_prov_msg_t* link_prov;
+
+  if(!inode_get_provenance(dir)){ // alloc provenance if none there
+    provenance_inode_alloc_security(dir);
+  }
+
+  if(!inode_get_provenance(dentry->d_inode)){
+    provenance_inode_alloc_security(dentry->d_inode);
+  }
+
+  dprov = inode_get_provenance(dir); // directory
+  iprov = inode_get_provenance(dentry->d_inode); // inode pointed by dentry
+
+  // writing to the directory
+  record_edge(ED_DATA, cprov, dprov, FLOW_ALLOWED);
+  record_edge(ED_DATA, cprov, iprov, FLOW_ALLOWED);
+
+  if(prov_enabled && (provenance_is_tracked(iprov) || provenance_is_tracked(dprov) || provenance_is_tracked(cprov))){
+    link_prov = alloc_long_provenance(MSG_UNLINK, GFP_KERNEL);
+    link_prov->unlink_info.length = dentry->d_name.len;
+    memcpy(link_prov->unlink_info.name, dentry->d_name.name, dentry->d_name.len);
+		copy_node_info(&link_prov->unlink_info.dir, &dprov->inode_info.node_info);
+		copy_node_info(&link_prov->unlink_info.task, &cprov->task_info.node_info);
+		copy_node_info(&link_prov->unlink_info.inode, &iprov->task_info.node_info);
+    long_prov_write(link_prov);
+    free_long_provenance(link_prov);
+  }
+  return 0;
+}
+
+static inline void provenance_record_file_name(struct file *file){
+	struct inode *inode = file_inode(file);
+	prov_msg_t *iprov = inode_get_provenance(inode);
+	long_prov_msg_t *fname_prov;
+	char *buffer;
+	char *ptr;
+
+	if(!provenance_is_name_recorded(iprov) && provenance_is_tracked(iprov)){
+		buffer = (char*)kzalloc(PATH_MAX, GFP_KERNEL);
+		fname_prov = alloc_long_provenance(MSG_FILE_NAME, GFP_KERNEL);
+		ptr = dentry_path_raw(file->f_path.dentry, buffer, PATH_MAX);
+		strlcpy(fname_prov->file_name_info.name, ptr, PATH_MAX);
+		kfree(buffer);
+		fname_prov->file_name_info.length=strlen(fname_prov->file_name_info.name);
+		copy_node_info(&fname_prov->file_name_info.inode, &iprov->task_info.node_info);
+		long_prov_write(fname_prov);
+		free_long_provenance(fname_prov);
+		iprov->node_info.node_kern.name_recorded=NAME_RECORDED;
+	}
+}
+
+/*
+* Check file permissions before accessing an open file.  This hook is
+* called by various operations that read or write files.  A security
+* module can use this hook to perform additional checking on these
+* operations, e.g.  to revalidate permissions on use to support privilege
+* bracketing or policy changes.  Notice that this hook is used when the
+* actual read/write operations are performed, whereas the
+* inode_security_ops hook is called when a file is opened (as well as
+* many other operations).
+* Caveat:  Although this hook can be used to revalidate permissions for
+* various system call operations that read or write files, it does not
+* address the revalidation of permissions for memory-mapped files.
+* Security modules must handle this separately if they need such
+* revalidation.
+* @file contains the file structure being accessed.
+* @mask contains the requested permissions.
+* Return 0 if permission is granted.
+*/
+static int provenance_file_permission(struct file *file, int mask)
+{
+  struct inode *inode = file_inode(file);
+	provenance_record_file_name(file);
+  provenance_inode_permission(inode, mask);
+  return 0;
+}
+
+/*
+* Save open-time permission checking state for later use upon
+* file_permission, and recheck access if anything has changed
+* since inode_permission.
+*/
+static int provenance_file_open(struct file *file, const struct cred *cred)
+{
+	prov_msg_t* cprov = current_provenance();
+	struct inode *inode = file_inode(file);
+	prov_msg_t* iprov;
+
+	if(!inode_get_provenance(inode)){ // alloc provenance if none there
+    provenance_inode_alloc_security(inode);
+  }
+	provenance_record_file_name(file);
+
+	iprov = inode_get_provenance(inode);
+	record_edge(ED_OPEN, cprov, iprov, FLOW_ALLOWED);
+	return 0;
+}
+
+/*
+* Check permissions for a mmap operation.  The @file may be NULL, e.g.
+* if mapping anonymous memory.
+* @file contains the file structure for file to map (may be NULL).
+* @reqprot contains the protection requested by the application.
+* @prot contains the protection that will be applied by the kernel.
+* @flags contains the operational flags.
+* Return 0 if permission is granted.
+*/
+static int provenance_mmap_file(struct file *file, unsigned long reqprot, unsigned long prot, unsigned long flags)
+{
+  prov_msg_t* cprov = current_provenance();
+  prov_msg_t* iprov;
+  struct inode *inode;
+
+  if(file==NULL){ // what to do for NULL?
+    return 0;
+  }
+	provenance_record_file_name(file);
+
+  inode = file_inode(file);
+  iprov = inode_get_provenance(inode);
+  prot &= (PROT_EXEC|PROT_READ|PROT_WRITE);
+
+  if((prot & (PROT_WRITE|PROT_EXEC)) != 0){
+    record_edge(ED_MMAP, cprov, iprov, FLOW_ALLOWED);
+  }
+  if((prot & (PROT_READ|PROT_EXEC|PROT_WRITE)) != 0){
+    // we assume write imply read
+    record_edge(ED_MMAP, iprov, cprov, FLOW_ALLOWED);
+  }
+  return 0;
+}
+
+/*
+* @file contains the file structure.
+* @cmd contains the operation to perform.
+* @arg contains the operational arguments.
+* Check permission for an ioctl operation on @file.  Note that @arg
+* sometimes represents a user space pointer; in other cases, it may be a
+* simple integer value.  When @arg represents a user space pointer, it
+* should never be used by the security module.
+* Return 0 if permission is granted.
+*/
+static int provenance_file_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
+{
+  prov_msg_t* cprov = current_provenance();
+  prov_msg_t* iprov;
+  struct inode *inode = file_inode(file);
+
+  if(!inode_get_provenance(inode)){ // alloc provenance if none there
+    provenance_inode_alloc_security(inode);
+  }
+	provenance_record_file_name(file);
+
+  iprov = inode_get_provenance(inode);
+
+  record_edge(ED_DATA, iprov, cprov, FLOW_ALLOWED); // both way exchange
+  record_edge(ED_DATA, cprov, iprov, FLOW_ALLOWED);
+
+  return 0;
+}
+
+/* msg */
+
+/*
+* Allocate and attach a security structure to the msg->security field.
+* The security field is initialized to NULL when the structure is first
+* created.
+* @msg contains the message structure to be modified.
+* Return 0 if operation was successful and permission is granted.
+*/
+static int provenance_msg_msg_alloc_security(struct msg_msg *msg)
+{
+  prov_msg_t* cprov = current_provenance();
+  prov_msg_t* mprov;
+#ifdef CONFIG_SECURITY_IFC
+	struct ifc_struct* ifc= msg->ifc;
+#endif
+  /* alloc new prov struct with generated id */
+  mprov = alloc_provenance(MSG_MSG, GFP_KERNEL);
+
+  if(!mprov)
+    return -ENOMEM;
+
+  set_node_id(mprov, ASSIGN_NODE_ID);
+  mprov->msg_msg_info.type=msg->m_type;
+#ifdef CONFIG_SECURITY_IFC
+	if(!ifc){
+		if(ifc_is_labelled(&ifc->context)){
+			mprov->msg_msg_info.node_kern.tracked=NODE_TRACKED;
+			prov_record_ifc(mprov, &ifc->context);
+		}
+	}
+#endif
+  msg->provenance = mprov;
+  record_edge(ED_CREATE, cprov, mprov, FLOW_ALLOWED);
+  return 0;
+}
+
+/*
+* Deallocate the security structure for this message.
+* @msg contains the message structure to be modified.
+*/
+static void provenance_msg_msg_free_security(struct msg_msg *msg)
+{
+	prov_msg_t *prov = msg->provenance;
+  msg->provenance=NULL;
+  free_provenance(prov);
+}
+
+/*
+* Check permission before a message, @msg, is enqueued on the message
+* queue, @msq.
+* @msq contains the message queue to send message to.
+* @msg contains the message to be enqueued.
+* @msqflg contains operational flags.
+* Return 0 if permission is granted.
+*/
+static int provenance_msg_queue_msgsnd(struct msg_queue *msq, struct msg_msg *msg, int msqflg)
+{
+  prov_msg_t* cprov = current_provenance();
+  prov_msg_t* mprov = msg->provenance;
+  record_edge(ED_DATA, cprov, mprov, FLOW_ALLOWED);
+  return 0;
+}
+
+/*
+* Check permission before a message, @msg, is removed from the message
+* queue, @msq.  The @target task structure contains a pointer to the
+* process that will be receiving the message (not equal to the current
+* process when inline receives are being performed).
+* @msq contains the message queue to retrieve message from.
+* @msg contains the message destination.
+* @target contains the task structure for recipient process.
+* @type contains the type of message requested.
+* @mode contains the operational flags.
+* Return 0 if permission is granted.
+*/
+static int provenance_msg_queue_msgrcv(struct msg_queue *msq, struct msg_msg *msg,
+				    struct task_struct *target,
+				    long type, int mode)
+{
+  prov_msg_t* cprov = target->cred->provenance;
+  prov_msg_t* mprov = msg->provenance;
+
+  record_edge(ED_DATA, mprov, cprov, FLOW_ALLOWED);
+  return 0;
+}
+
+/*
+* Allocate and attach a security structure to the shp->shm_perm.security
+* field.  The security field is initialized to NULL when the structure is
+* first created.
+* @shp contains the shared memory structure to be modified.
+* Return 0 if operation was successful and permission is granted.
+*/
+static int provenance_shm_alloc_security(struct shmid_kernel *shp)
+{
+	prov_msg_t* cprov = current_provenance();
+  prov_msg_t* sprov = alloc_provenance(MSG_SHM, GFP_KERNEL);
+#ifdef CONFIG_SECURITY_IFC
+	struct ifc_struct* ifc= shp->shm_perm.ifc;
+#endif
+
+  if(!sprov)
+    return -ENOMEM;
+
+  set_node_id(sprov, ASSIGN_NODE_ID);
+  sprov->shm_info.mode=shp->shm_perm.mode;
+
+#ifdef CONFIG_SECURITY_IFC
+	if(!ifc){
+		if(ifc_is_labelled(&ifc->context)){
+			sprov->shm_info.node_kern.tracked=NODE_TRACKED;
+			prov_record_ifc(sprov, &ifc->context);
+		}
+	}
+#endif
+
+  shp->shm_perm.provenance=sprov;
+  record_edge(ED_ATTACH, sprov, cprov, FLOW_ALLOWED);
+  record_edge(ED_ATTACH, cprov, sprov, FLOW_ALLOWED);
+	return 0;
+}
+
+/*
+* Deallocate the security struct for this memory segment.
+* @shp contains the shared memory structure to be modified.
+*/
+static void provenance_shm_free_security(struct shmid_kernel *shp)
+{
+  free_provenance(shp->shm_perm.provenance);
+  shp->shm_perm.provenance=NULL;
+}
+
+/*
+* Check permissions prior to allowing the shmat system call to attach the
+* shared memory segment @shp to the data segment of the calling process.
+* The attaching address is specified by @shmaddr.
+* @shp contains the shared memory structure to be modified.
+* @shmaddr contains the address to attach memory region to.
+* @shmflg contains the operational flags.
+* Return 0 if permission is granted.
+*/
+static int provenance_shm_shmat(struct shmid_kernel *shp,
+			     char __user *shmaddr, int shmflg)
+{
+  prov_msg_t* cprov = current_provenance();
+	prov_msg_t* sprov = shp->shm_perm.provenance;
+
+  if(!sprov)
+    return -ENOMEM;
+
+  if(shmflg & SHM_RDONLY){
+    record_edge(ED_ATTACH, sprov, cprov, FLOW_ALLOWED);
+  }else{
+    record_edge(ED_ATTACH, sprov, cprov, FLOW_ALLOWED);
+    record_edge(ED_ATTACH, cprov, sprov, FLOW_ALLOWED);
+  }
+	return 0;
+}
+
+/*
+* Allocate and attach a security structure to the sk->sk_security field,
+* which is used to copy security attributes between local stream sockets.
+*/
+static int provenance_sk_alloc_security(struct sock *sk, int family, gfp_t priority)
+{
+  prov_msg_t* skprov = alloc_provenance(MSG_SOCK, priority);
+
+  if(!skprov)
+    return -ENOMEM;
+  set_node_id(skprov, ASSIGN_NODE_ID);
+
+  sk->sk_provenance=skprov;
+  return 0;
+}
+
+/*
+* Deallocate security structure.
+*/
+static void provenance_sk_free_security(struct sock *sk)
+{
+	free_provenance(sk->sk_provenance);
+	sk->sk_provenance = NULL;
+}
+
+/*
+* This hook allows a module to update or allocate a per-socket security
+* structure. Note that the security field was not added directly to the
+* socket structure, but rather, the socket security information is stored
+* in the associated inode.  Typically, the inode alloc_security hook will
+* allocate and and attach security information to
+* sock->inode->i_security.  This hook may be used to update the
+* sock->inode->i_security field with additional information that wasn't
+* available when the inode was allocated.
+* @sock contains the newly created socket structure.
+* @family contains the requested protocol family.
+* @type contains the requested communications type.
+* @protocol contains the requested protocol.
+* @kern set to 1 if a kernel socket.
+*/
+static int provenance_socket_post_create(struct socket *sock, int family,
+				      int type, int protocol, int kern)
+{
+  prov_msg_t* cprov  = current_provenance();
+  prov_msg_t* iprov  = inode_get_provenance(SOCK_INODE(sock));
+  prov_msg_t* skprov = NULL;
+
+  if(kern){
+    return 0;
+  }
+
+  if(!sock->sk->sk_provenance){
+		provenance_sk_alloc_security(sock->sk, family, GFP_KERNEL);
+	}
+  skprov = sock->sk->sk_provenance;
+  skprov->sock_info.type = type;
+  skprov->sock_info.family = family;
+  skprov->sock_info.protocol = protocol;
+  record_edge(ED_CREATE, cprov, skprov, FLOW_ALLOWED);
+  record_edge(ED_ASSOCIATE, skprov, iprov, FLOW_ALLOWED);
+
+  return 0;
+}
+
+static inline void provenance_record_address(struct socket *sock, struct sockaddr *address, int addrlen){
+	prov_msg_t* skprov = sock->sk->sk_provenance;
+	long_prov_msg_t* addr_info = NULL;
+
+	if(!provenance_is_name_recorded(skprov) && provenance_is_tracked(skprov)){
+	  addr_info = alloc_long_provenance(MSG_ADDR, GFP_KERNEL);
+		copy_node_info(&addr_info->address_info.sock_info, &skprov->sock_info.node_info);
+	  addr_info->address_info.length=addrlen;
+	  memcpy(&(addr_info->address_info.addr), address, addrlen);
+	  long_prov_write(addr_info);
+	  free_long_provenance(addr_info);
+		skprov->sock_info.node_kern.name_recorded=NAME_RECORDED;
+	}
+}
+
+/*
+* Check permission before socket protocol layer bind operation is
+* performed and the socket @sock is bound to the address specified in the
+* @address parameter.
+* @sock contains the socket structure.
+* @address contains the address to bind to.
+* @addrlen contains the length of address.
+* Return 0 if permission is granted.
+*/
+static int provenance_socket_bind(struct socket *sock, struct sockaddr *address, int addrlen)
+{
+  prov_msg_t* cprov  = current_provenance();
+  prov_msg_t* skprov = sock->sk->sk_provenance;
+
+  if(cprov->task_info.node_kern.opaque==NODE_OPAQUE)
+    return 0;
+
+  if(!skprov)
+    return -ENOMEM;
+
+	provenance_record_address(sock, address, addrlen);
+	record_edge(ED_BIND, cprov, skprov, FLOW_ALLOWED);
+
+  return 0;
+}
+
+/*
+* Check permission before socket protocol layer connect operation
+* attempts to connect socket @sock to a remote address, @address.
+* @sock contains the socket structure.
+* @address contains the address of remote endpoint.
+* @addrlen contains the length of address.
+* Return 0 if permission is granted.
+*/
+static int provenance_socket_connect(struct socket *sock, struct sockaddr *address, int addrlen)
+{
+  prov_msg_t* cprov  = current_provenance();
+  prov_msg_t* skprov = sock->sk->sk_provenance;
+
+  if(cprov->task_info.node_kern.opaque==NODE_OPAQUE)
+    return 0;
+
+  if(!skprov)
+    return -ENOMEM;
+
+	provenance_record_address(sock, address, addrlen);
+	record_edge(ED_CONNECT, cprov, skprov, FLOW_ALLOWED);
+
+  return 0;
+}
+
+/*
+* Check permission before socket protocol layer listen operation.
+* @sock contains the socket structure.
+* @backlog contains the maximum length for the pending connection queue.
+* Return 0 if permission is granted.
+*/
+static int provenance_socket_listen(struct socket *sock, int backlog)
+{
+  prov_msg_t* cprov  = current_provenance();
+  prov_msg_t* skprov = sock->sk->sk_provenance;
+
+  record_edge(ED_LISTEN, cprov, skprov, FLOW_ALLOWED);
+  return 0;
+}
+
+/*
+* Check permission before transmitting a message to another socket.
+* @sock contains the socket structure.
+* @msg contains the message to be transmitted.
+* @size contains the size of message.
+* Return 0 if permission is granted.
+*/
+static int provenance_socket_sendmsg(struct socket *sock, struct msghdr *msg,
+				  int size)
+{
+	return provenance_inode_permission(SOCK_INODE(sock), MAY_WRITE);
+}
+
+/*
+* Check permission before receiving a message from a socket.
+* @sock contains the socket structure.
+* @msg contains the message structure.
+* @size contains the size of message structure.
+* @flags contains the operational flags.
+* Return 0 if permission is granted.
+*/
+static int provenance_socket_recvmsg(struct socket *sock, struct msghdr *msg,
+				  int size, int flags)
+{
+	return provenance_inode_permission(SOCK_INODE(sock), MAY_READ);
+}
+
+/*
+* Check permission before accepting a new connection.  Note that the new
+* socket, @newsock, has been created and some information copied to it,
+* but the accept operation has not actually been performed.
+* @sock contains the listening socket structure.
+* @newsock contains the newly created server socket for connection.
+* Return 0 if permission is granted.
+*/
+static int provenance_socket_accept(struct socket *sock, struct socket *newsock)
+{
+  prov_msg_t* cprov  = current_provenance();
+  prov_msg_t* skprov = inode_get_provenance(SOCK_INODE(sock));
+  prov_msg_t* nskprov = inode_get_provenance(SOCK_INODE(newsock));
+  record_edge(ED_CREATE, skprov, nskprov, FLOW_ALLOWED);
+  record_edge(ED_ACCEPT, nskprov, cprov, FLOW_ALLOWED);
+  return 0;
+}
+
+/*
+* Check permissions before establishing a Unix domain stream connection
+* between @sock and @other.
+* @sock contains the sock structure.
+* @other contains the peer sock structure.
+* @newsk contains the new sock structure.
+* Return 0 if permission is granted.
+*/
+static int provenance_unix_stream_connect(struct sock *sock,
+					      struct sock *other,
+					      struct sock *newsk)
+{
+  prov_msg_t* cprov  = current_provenance();
+  prov_msg_t* skprov = sock->sk_provenance;
+  prov_msg_t* nskprov = newsk->sk_provenance;
+  prov_msg_t* okprov = other->sk_provenance;
+
+  record_edge(ED_CONNECT, cprov, skprov, FLOW_ALLOWED);
+  record_edge(ED_ASSOCIATE, skprov, nskprov, FLOW_ALLOWED);
+  record_edge(ED_ASSOCIATE, skprov, okprov, FLOW_ALLOWED);
+  return 0;
+}
+
+/*
+* Check permissions before connecting or sending datagrams from @sock to
+* @other.
+* @sock contains the socket structure.
+* @other contains the peer socket structure.
+* Return 0 if permission is granted.
+*/
+static int provenance_unix_may_send(struct socket *sock,
+					struct socket *other)
+{
+  prov_msg_t* skprov = sock->sk->sk_provenance;
+  prov_msg_t* okprov = other->sk->sk_provenance;
+
+  record_edge(ED_DATA, skprov, okprov, FLOW_ALLOWED);
+  return 0;
+}
+
+/* outdated description */
+/*
+* Save security information in the bprm->security field, typically based
+* on information about the bprm->file, for later use by the apply_creds
+* hook.  This hook may also optionally check permissions (e.g. for
+* transitions between security domains).
+* This hook may be called multiple times during a single execve, e.g. for
+* interpreters.  The hook can tell whether it has already been called by
+* checking to see if @bprm->security is non-NULL.  If so, then the hook
+* may decide either to retain the security information saved earlier or
+* to replace it.
+* @bprm contains the linux_binprm structure.
+* Return 0 if the hook is successful and permission is granted.
+*/
+static int provenance_bprm_set_creds(struct linux_binprm *bprm){
+  if(!bprm->cred->provenance){
+    return provenance_cred_alloc_blank(bprm->cred, GFP_KERNEL);
+  }
+  return 0;
+}
+
+/*
+* Tidy up after the installation of the new security attributes of a
+* process being transformed by an execve operation.  The new credentials
+* have, by this point, been set to @current->cred.  @bprm points to the
+* linux_binprm structure.  This hook is a good place to perform state
+* changes on the process such as clearing out non-inheritable signal
+* state.  This is called immediately after commit_creds().
+*/
+ static void provenance_bprm_committing_creds(struct linux_binprm *bprm){
+   prov_msg_t* cprov  = current_provenance();
+   prov_msg_t* nprov = bprm->cred->provenance;
+   struct inode *inode = file_inode(bprm->file);
+   prov_msg_t* iprov = inode_get_provenance(inode);
+   record_edge(ED_CREATE, cprov, nprov, FLOW_ALLOWED);
+   record_edge(ED_CREATE, iprov, nprov, FLOW_ALLOWED);
+ }
+
+/*
+* Allocate and attach a security structure to the sb->s_security field.
+* The s_security field is initialized to NULL when the structure is
+* allocated.
+* @sb contains the super_block structure to be modified.
+* Return 0 if operation was successful.
+*/
+static int provenance_sb_alloc_security(struct super_block *sb)
+{
+  prov_msg_t* sbprov  = alloc_provenance(MSG_SB, GFP_KERNEL);
+  if(!sbprov)
+    return -ENOMEM;
+  sb->s_provenance = sbprov;
+  return 0;
+}
+
+/*
+* Deallocate and clear the sb->s_security field.
+* @sb contains the super_block structure to be modified.
+*/
+static void provenance_sb_free_security(struct super_block *sb)
+{
+  free_provenance(sb->s_provenance);
+  sb->s_provenance=NULL;
+}
+
+static int provenance_sb_kern_mount(struct super_block *sb, int flags, void *data)
+{
+  int i;
+  uint8_t c=0;
+  prov_msg_t* sbprov = sb->s_provenance;
+  for(i=0; i<16; i++){
+    sbprov->sb_info.uuid[i]=sb->s_uuid[i];
+    c|=sb->s_uuid[i];
+  }
+  if(c==0){ // no uuid defined, generate random one
+    get_random_bytes(sbprov->sb_info.uuid, 16*sizeof(uint8_t));
+  }
+  return 0;
+}
+
+static struct security_hook_list provenance_hooks[] = {
+  LSM_HOOK_INIT(cred_alloc_blank, provenance_cred_alloc_blank),
+  LSM_HOOK_INIT(cred_free, provenance_cred_free),
+  LSM_HOOK_INIT(cred_prepare, provenance_cred_prepare),
+  LSM_HOOK_INIT(cred_transfer, provenance_cred_transfer),
+  LSM_HOOK_INIT(task_fix_setuid, provenance_task_fix_setuid),
+  LSM_HOOK_INIT(inode_alloc_security, provenance_inode_alloc_security),
+  LSM_HOOK_INIT(inode_free_security, provenance_inode_free_security),
+  LSM_HOOK_INIT(inode_permission, provenance_inode_permission),
+  LSM_HOOK_INIT(file_permission, provenance_file_permission),
+  LSM_HOOK_INIT(mmap_file, provenance_mmap_file),
+  LSM_HOOK_INIT(file_ioctl, provenance_file_ioctl),
+  LSM_HOOK_INIT(inode_link, provenance_inode_link),
+	LSM_HOOK_INIT(inode_unlink, provenance_inode_unlink),
+	LSM_HOOK_INIT(msg_msg_alloc_security, provenance_msg_msg_alloc_security),
+	LSM_HOOK_INIT(msg_msg_free_security, provenance_msg_msg_free_security),
+  LSM_HOOK_INIT(msg_queue_msgsnd, provenance_msg_queue_msgsnd),
+  LSM_HOOK_INIT(msg_queue_msgrcv, provenance_msg_queue_msgrcv),
+  LSM_HOOK_INIT(shm_alloc_security, provenance_shm_alloc_security),
+  LSM_HOOK_INIT(shm_free_security, provenance_shm_free_security),
+  LSM_HOOK_INIT(shm_shmat, provenance_shm_shmat),
+  LSM_HOOK_INIT(sk_alloc_security, provenance_sk_alloc_security),
+  LSM_HOOK_INIT(sk_free_security, provenance_sk_free_security),
+  LSM_HOOK_INIT(socket_post_create, provenance_socket_post_create),
+  LSM_HOOK_INIT(socket_bind, provenance_socket_bind),
+  LSM_HOOK_INIT(socket_connect, provenance_socket_connect),
+  LSM_HOOK_INIT(socket_listen, provenance_socket_listen),
+  LSM_HOOK_INIT(socket_sendmsg, provenance_socket_sendmsg),
+  LSM_HOOK_INIT(socket_recvmsg, provenance_socket_recvmsg),
+  LSM_HOOK_INIT(socket_accept, provenance_socket_accept),
+  LSM_HOOK_INIT(unix_stream_connect, provenance_unix_stream_connect),
+  LSM_HOOK_INIT(unix_may_send, provenance_unix_may_send),
+  LSM_HOOK_INIT(bprm_set_creds, provenance_bprm_set_creds),
+  LSM_HOOK_INIT(bprm_committing_creds, provenance_bprm_committing_creds),
+  LSM_HOOK_INIT(sb_alloc_security, provenance_sb_alloc_security),
+  LSM_HOOK_INIT(sb_free_security, provenance_sb_free_security),
+  LSM_HOOK_INIT(sb_kern_mount, provenance_sb_kern_mount),
+	LSM_HOOK_INIT(file_open, provenance_file_open)
+};
+#ifndef CONFIG_SECURITY_IFC
+struct kmem_cache *camflow_cache=NULL;
+#endif
+
+uint32_t prov_machine_id=1; /* TODO get a proper id somehow */
+uint32_t prov_boot_id=0;
+void __init provenance_add_hooks(void){
+	printk(KERN_INFO "Provenance Camflow %s\n", CAMFLOW_VERSION_STR);
+	get_random_bytes(&prov_boot_id, sizeof(uint32_t));
+  provenance_cache = kmem_cache_create("provenance_struct",
+					    sizeof(prov_msg_t),
+					    0, SLAB_PANIC, NULL);
+  long_provenance_cache = kmem_cache_create("long_provenance_struct",
+					    sizeof(long_prov_msg_t),
+					    0, SLAB_PANIC, NULL);
+#ifndef CONFIG_SECURITY_IFC
+	camflow_cache = kmem_cache_create("camflow_i_ptr",
+							sizeof(struct camflow_i_ptr),
+							0, SLAB_PANIC, NULL);
+#endif
+  cred_init_provenance();
+  /* register the provenance security hooks */
+  security_add_hooks(provenance_hooks, ARRAY_SIZE(provenance_hooks));
+	printk(KERN_INFO "Provenance hooks ready.\n");
+}
diff -uprN ./pristine/linux-4.4.6/security/provenance/Kconfig ./linux-4.4.6/security/provenance/Kconfig
--- ./pristine/linux-4.4.6/security/provenance/Kconfig	1970-01-01 01:00:00.000000000 +0100
+++ ./linux-4.4.6/security/provenance/Kconfig	2016-05-26 17:22:39.811013999 +0200
@@ -0,0 +1,9 @@
+config SECURITY_PROVENANCE
+         bool "Provenance"
+         depends on SECURITY
+         select RELAY
+         select SECURITYFS
+         default n
+         help
+          This selects Provenance.
+          Provenance is an helper to capture provenance data.
diff -uprN ./pristine/linux-4.4.6/security/provenance/Makefile ./linux-4.4.6/security/provenance/Makefile
--- ./pristine/linux-4.4.6/security/provenance/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ ./linux-4.4.6/security/provenance/Makefile	2016-05-26 17:22:39.811013999 +0200
@@ -0,0 +1,6 @@
+#
+# Makefile for Provenance LSM
+#
+obj-$(CONFIG_SECURITY_PROVENANCE) := provenance.o
+
+provenance-y := provenance_relay.o hooks.o fs.o
diff -uprN ./pristine/linux-4.4.6/security/provenance/provenance_relay.c ./linux-4.4.6/security/provenance/provenance_relay.c
--- ./pristine/linux-4.4.6/security/provenance/provenance_relay.c	1970-01-01 01:00:00.000000000 +0100
+++ ./linux-4.4.6/security/provenance/provenance_relay.c	2016-05-26 17:22:39.816013999 +0200
@@ -0,0 +1,79 @@
+/*
+*
+* /linux/security/provenance/provenance.c
+*
+* Author: Thomas Pasquier <tfjmp2@cam.ac.uk>
+*
+* Copyright (C) 2015 University of Cambridge
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License version 2, as
+* published by the Free Software Foundation.
+*
+*/
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/provenance.h>
+#include <linux/debugfs.h>
+
+#define PROV_BASE_NAME "provenance"
+#define LONG_PROV_BASE_NAME "long_provenance"
+
+/* global variable, extern in provenance.h */
+ struct rchan *prov_chan=NULL;
+ struct rchan *long_prov_chan=NULL;
+ atomic64_t prov_evt_count=ATOMIC64_INIT(0);
+ atomic64_t prov_node_id=ATOMIC64_INIT(0);
+
+/*
+ * create_buf_file() callback.  Creates relay file in debugfs.
+ */
+static struct dentry *create_buf_file_handler(const char *filename,
+                                                struct dentry *parent,
+                                                umode_t mode,
+                                                struct rchan_buf *buf,
+                                                int *is_global)
+{
+        return debugfs_create_file(filename, mode, parent, buf,
+	                           &relay_file_operations);
+}
+
+/*
+ * remove_buf_file() callback.  Removes relay file from debugfs.
+ */
+static int remove_buf_file_handler(struct dentry *dentry)
+{
+        debugfs_remove(dentry);
+        return 0;
+}
+
+/*
+ * relay interface callbacks
+ */
+static struct rchan_callbacks relay_callbacks =
+{
+        .create_buf_file = create_buf_file_handler,
+        .remove_buf_file = remove_buf_file_handler,
+};
+
+static int __init relay_prov_init(void)
+{
+  printk(KERN_INFO "Provenance init.\n");
+  prov_chan = relay_open(PROV_BASE_NAME, NULL, 128*sizeof(prov_msg_t), 4, &relay_callbacks, NULL);
+  if(prov_chan==NULL){
+    printk(KERN_ERR "Provenance: relay_open failure\n");
+    return 0;
+  }
+
+  long_prov_chan = relay_open(LONG_PROV_BASE_NAME, NULL, 32*sizeof(long_prov_msg_t), 4, &relay_callbacks, NULL);
+  if(long_prov_chan==NULL){
+    printk(KERN_ERR "Provenance: relay_open failure\n");
+    return 0;
+  }
+
+  printk(KERN_INFO "Provenance module started!\n");
+  return 0;
+}
+
+core_initcall(relay_prov_init);
diff -uprN ./pristine/linux-4.4.6/security/security.c ./linux-4.4.6/security/security.c
--- ./pristine/linux-4.4.6/security/security.c	2016-03-16 16:43:17.000000000 +0100
+++ ./linux-4.4.6/security/security.c	2016-05-26 17:22:39.816013999 +0200
@@ -66,6 +66,12 @@ int __init security_init(void)
 	 */
 	do_security_initcalls();
 
+	/*
+	* Load IFC and Provenance module
+	*/
+	ifc_add_hooks();
+	provenance_add_hooks();
+
 	return 0;
 }
 
