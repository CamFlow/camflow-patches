diff -uprN -b -B ./pristine/linux-4.14.9/fs/splice.c ./linux-4.14.9/fs/splice.c
--- ./pristine/linux-4.14.9/fs/splice.c	2017-12-25 13:26:48.000000000 +0000
+++ ./linux-4.14.9/fs/splice.c	2017-12-27 07:56:41.247544698 +0000
@@ -1118,6 +1118,11 @@ static long do_splice(struct file *in, l
 		if (ipipe == opipe)
 			return -EINVAL;

+#ifdef CONFIG_SECURITY_FLOW_FRIENDLY
+		ret = security_file_splice_pipe_to_pipe(in, out);
+		if (ret)
+			return ret;
+#endif
 		return splice_pipe_to_pipe(ipipe, opipe, len, flags);
 	}

@@ -1256,6 +1261,12 @@ static long vmsplice_to_user(struct file
 	if (!pipe)
 		return -EBADF;

+#ifdef CONFIG_SECURITY_FLOW_FRIENDLY
+	ret = security_file_permission(file, MAY_READ);
+	if (ret)
+		return ret;
+#endif
+
 	ret = import_iovec(READ, uiov, nr_segs,
 			   ARRAY_SIZE(iovstack), &iov, &iter);
 	if (ret < 0)
@@ -1299,6 +1310,12 @@ static long vmsplice_to_pipe(struct file
 	if (!pipe)
 		return -EBADF;

+#ifdef CONFIG_SECURITY_FLOW_FRIENDLY
+	ret = security_file_permission(file, MAY_WRITE);
+	if (ret)
+		return ret;
+#endif
+
 	ret = import_iovec(WRITE, uiov, nr_segs,
 			   ARRAY_SIZE(iovstack), &iov, &from);
 	if (ret < 0)
@@ -1700,6 +1717,11 @@ static long do_tee(struct file *in, stru
 	 * copying the data.
 	 */
 	if (ipipe && opipe && ipipe != opipe) {
+#ifdef CONFIG_SECURITY_FLOW_FRIENDLY
+		ret = security_file_splice_pipe_to_pipe(in, out);
+		if (ret)
+			return ret;
+#endif
 		/*
 		 * Keep going, unless we encounter an error. The ipipe/opipe
 		 * ordering doesn't really matter.
diff -uprN -b -B ./pristine/linux-4.14.9/include/linux/cred.h ./linux-4.14.9/include/linux/cred.h
--- ./pristine/linux-4.14.9/include/linux/cred.h	2017-12-25 13:26:48.000000000 +0000
+++ ./linux-4.14.9/include/linux/cred.h	2017-12-27 19:40:12.209134652 +0000
@@ -141,6 +141,9 @@ struct cred {
 #endif
 #ifdef CONFIG_SECURITY
 	void		*security;	/* subjective LSM security */
+#ifdef CONFIG_SECURITY_PROVENANCE
+	void		*provenance;    /* subjective LSM provenance */
+#endif
 #endif
 	struct user_struct *user;	/* real user ID subscription */
 	struct user_namespace *user_ns; /* user_ns the caps and keyrings are relative to. */
@@ -365,6 +368,7 @@ static inline void put_cred(const struct
 #define current_cap()		(current_cred_xxx(cap_effective))
 #define current_user()		(current_cred_xxx(user))
 #define current_security()	(current_cred_xxx(security))
+#define current_provenance() (current_cred_xxx(provenance))

 extern struct user_namespace init_user_ns;
 #ifdef CONFIG_USER_NS
diff -uprN -b -B ./pristine/linux-4.14.9/include/linux/fs.h ./linux-4.14.9/include/linux/fs.h
--- ./pristine/linux-4.14.9/include/linux/fs.h	2017-12-25 13:26:48.000000000 +0000
+++ ./linux-4.14.9/include/linux/fs.h	2017-12-27 19:40:12.207134634 +0000
@@ -585,6 +585,9 @@ struct inode {

 #ifdef CONFIG_SECURITY
 	void			*i_security;
+#ifdef CONFIG_SECURITY_PROVENANCE
+	void 			*i_provenance;
+#endif
 #endif

 	/* Stat data, not accessed from path walking */
@@ -1354,6 +1357,9 @@ struct super_block {
 	atomic_t		s_active;
 #ifdef CONFIG_SECURITY
 	void                    *s_security;
+#ifdef CONFIG_SECURITY_PROVENANCE
+	void 										*s_provenance;
+#endif
 #endif
 	const struct xattr_handler **s_xattr;

diff -uprN -b -B ./pristine/linux-4.14.9/include/linux/ipc.h ./linux-4.14.9/include/linux/ipc.h
--- ./pristine/linux-4.14.9/include/linux/ipc.h	2017-12-25 13:26:48.000000000 +0000
+++ ./linux-4.14.9/include/linux/ipc.h	2017-12-27 19:40:12.208134643 +0000
@@ -23,6 +23,9 @@ struct kern_ipc_perm {
 	umode_t		mode;
 	unsigned long	seq;
 	void		*security;
+#ifdef CONFIG_SECURITY_PROVENANCE
+	void 		*provenance;
+#endif

 	struct rhash_head khtnode;

diff -uprN -b -B ./pristine/linux-4.14.9/include/linux/lsm_hooks.h ./linux-4.14.9/include/linux/lsm_hooks.h
--- ./pristine/linux-4.14.9/include/linux/lsm_hooks.h	2017-12-25 13:26:48.000000000 +0000
+++ ./linux-4.14.9/include/linux/lsm_hooks.h	2017-12-27 19:40:12.208134643 +0000
@@ -1682,6 +1682,22 @@ union security_list_options {
 				struct audit_context *actx);
 	void (*audit_rule_free)(void *lsmrule);
 #endif /* CONFIG_AUDIT */
+#ifdef CONFIG_SECURITY_FLOW_FRIENDLY
+void (*mmap_munmap)(struct mm_struct *mm,
+				struct vm_area_struct *vma,
+				unsigned long start, unsigned long end);
+int (*file_splice_pipe_to_pipe)(struct file *in,
+				struct file *out);
+int (*mq_timedsend)(struct inode *inode, struct msg_msg *msg,
+			struct timespec64 *ts);
+int (*mq_timedreceive)(struct inode *inode, struct msg_msg *msg,
+			struct timespec64 *ts);
+void (*shm_shmdt)(struct shmid_kernel *shp);
+int (*socket_sendmsg_always)(struct socket *sock, struct msghdr *msg,
+				int size);
+int (*socket_recvmsg_always)(struct socket *sock, struct msghdr *msg,
+				int size, int flags);
+#endif /* CONFIG_SECURITY_FLOW_FRIENDLY */
 };

 struct security_hook_heads {
@@ -1901,6 +1917,15 @@ struct security_hook_heads {
 	struct list_head audit_rule_match;
 	struct list_head audit_rule_free;
 #endif /* CONFIG_AUDIT */
+#ifdef CONFIG_SECURITY_FLOW_FRIENDLY
+	struct list_head mmap_munmap;
+	struct list_head file_splice_pipe_to_pipe;
+	struct list_head mq_timedsend;
+	struct list_head mq_timedreceive;
+	struct list_head shm_shmdt;
+	struct list_head socket_sendmsg_always;
+	struct list_head socket_recvmsg_always;
+#endif /* CONFIG_SECURITY_FLOW_FRIENDLY */
 } __randomize_layout;

 /*
@@ -1966,6 +1991,11 @@ extern void __init yama_add_hooks(void);
 #else
 static inline void __init yama_add_hooks(void) { }
 #endif
+#ifdef CONFIG_SECURITY_PROVENANCE
+extern void __init provenance_add_hooks(void);
+#else
+static inline void __init provenance_add_hooks(void) { }
+#endif
 #ifdef CONFIG_SECURITY_LOADPIN
 void __init loadpin_add_hooks(void);
 #else
diff -uprN -b -B ./pristine/linux-4.14.9/include/linux/msg.h ./linux-4.14.9/include/linux/msg.h
--- ./pristine/linux-4.14.9/include/linux/msg.h	2017-12-25 13:26:48.000000000 +0000
+++ ./linux-4.14.9/include/linux/msg.h	2017-12-27 19:40:12.209134652 +0000
@@ -13,6 +13,9 @@ struct msg_msg {
 	size_t m_ts;		/* message text size */
 	struct msg_msgseg *next;
 	void *security;
+#ifdef CONFIG_SECURITY_PROVENANCE
+	void *provenance;
+#endif
 	/* the actual message follows immediately */
 };

diff -uprN -b -B ./pristine/linux-4.14.9/include/linux/provenance_query.h ./linux-4.14.9/include/linux/provenance_query.h
--- ./pristine/linux-4.14.9/include/linux/provenance_query.h	1970-01-01 01:00:00.000000000 +0100
+++ ./linux-4.14.9/include/linux/provenance_query.h	2017-12-27 19:40:12.209134652 +0000
@@ -0,0 +1,33 @@
+/*
+ *
+ * Author: Thomas Pasquier <tfjmp@g.harvard.edu>
+ *
+ * Copyright (C) 2015-2017 University of Cambridge, Harvard University
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2, as
+ * published by the Free Software Foundation; either version 2 of the License,
+ * or (at your option) any later version.
+ *
+ */
+ #ifndef _LINUX_PROVENANCE_QUERY_H
+ #define _LINUX_PROVENANCE_QUERY_H
+
+ #include <uapi/linux/provenance.h>
+
+ #define PROVENANCE_RAISE_WARNING  1
+ #define PROVENANCE_PREVENT_FLOW   2
+
+ #define QUERY_HOOK_INIT(HEAD, HOOK) .HEAD=&HOOK
+
+struct provenance_query_hooks {
+  struct list_head list;
+  int (*out_edge)(prov_entry_t*, prov_entry_t*);
+  int (*in_edge)(prov_entry_t*, prov_entry_t*);
+};
+
+ extern struct list_head provenance_query_hooks;
+
+int register_provenance_query_hooks( struct provenance_query_hooks *hook);
+int unregister_provenance_query_hooks( struct provenance_query_hooks *hook);
+#endif
diff -uprN -b -B ./pristine/linux-4.14.9/include/linux/provenance_types.h ./linux-4.14.9/include/linux/provenance_types.h
--- ./pristine/linux-4.14.9/include/linux/provenance_types.h	1970-01-01 01:00:00.000000000 +0100
+++ ./linux-4.14.9/include/linux/provenance_types.h	2017-12-27 19:40:12.209134652 +0000
@@ -0,0 +1,23 @@
+/*
+ *
+ * Author: Thomas Pasquier <tfjmp@g.harvard.edu>
+ *
+ * Copyright (C) 2015-2017 University of Cambridge, Harvard University
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2, as
+ * published by the Free Software Foundation; either version 2 of the License,
+ * or (at your option) any later version.
+ *
+ */
+ #ifndef _PROVENANCE_TYPES_H
+ #define _PROVENANCE_TYPES_H
+
+  #include <uapi/linux/provenance_types.h>
+
+const char* relation_str(uint64_t type);
+uint64_t relation_id(const char* str);
+const char* node_str(uint64_t type);
+uint64_t node_id(const char* str);
+
+#endif /* _PROVENANCE_TYPES_H */
diff -uprN -b -B ./pristine/linux-4.14.9/include/linux/security.h ./linux-4.14.9/include/linux/security.h
--- ./pristine/linux-4.14.9/include/linux/security.h	2017-12-25 13:26:48.000000000 +0000
+++ ./linux-4.14.9/include/linux/security.h	2017-12-27 07:56:41.248544708 +0000
@@ -387,6 +387,20 @@ void security_inode_invalidate_secctx(st
 int security_inode_notifysecctx(struct inode *inode, void *ctx, u32 ctxlen);
 int security_inode_setsecctx(struct dentry *dentry, void *ctx, u32 ctxlen);
 int security_inode_getsecctx(struct inode *inode, void **ctx, u32 *ctxlen);
+#ifdef CONFIG_SECURITY_FLOW_FRIENDLY
+void security_shm_shmdt(struct shmid_kernel *shp);
+int security_mq_timedsend(struct inode *inode, struct msg_msg *msg,
+				size_t msg_len, struct timespec64 *ts);
+int security_mq_timedreceive(struct inode *inode, struct msg_msg *msg,
+				size_t msg_len, struct timespec64 *ts);
+int security_socket_sendmsg_always(struct socket *sock, struct msghdr *msg,
+				int size);
+int security_socket_recvmsg_always(struct socket *sock, struct msghdr *msg,
+			  int size, int flags);
+void security_mmap_munmap(struct mm_struct *mm, struct vm_area_struct *vma,
+			  unsigned long start, unsigned long end);
+int security_file_splice_pipe_to_pipe(struct file *in, struct file *out);
+#endif /* CONFIG_SECURITY_FLOW_FRIENDLY */
 #else /* CONFIG_SECURITY */
 struct security_mnt_opts {
 };
@@ -1751,6 +1765,47 @@ static inline char *alloc_secdata(void)

 static inline void free_secdata(void *secdata)
 { }
+
+#ifdef CONFIG_SECURITY_FLOW_FRIENDLY
+static inline void security_mmap_munmap(struct mm_struct *mm,
+					struct vm_area_struct *vma,
+					unsigned long start, unsigned long end)
+{ }
+
+static inline int security_file_splice_pipe_to_pipe(struct file *in,
+						    struct file *out)
+{
+	return 0;
+}
+
+static inline int security_mq_timedsend(struct inode *inode,
+			struct msg_msg *msg, size_t msg_len, struct timespec64 *ts)
+{
+	return 0;
+}
+
+static inline int security_mq_timedreceive(struct inode *inode,
+			struct msg_msg *msg, size_t msg_len, struct timespec64 *ts)
+{
+	return 0;
+}
+
+static inline void security_shm_shmdt(struct shmid_kernel *shp)
+{ }
+
+static inline int security_socket_sendmsg_always(struct socket *sock,
+					  struct msghdr *msg, int size)
+{
+	return 0;
+}
+
+static inline int security_socket_recvmsg_always(struct socket *sock,
+					  struct msghdr *msg, int size,
+					  int flags)
+{
+	return 0;
+}
+#endif /* CONFIG_SECURITY_FLOW_FRIENDLY */
 #endif /* CONFIG_SECURITY */

 #endif /* ! __LINUX_SECURITY_H */
diff -uprN -b -B ./pristine/linux-4.14.9/include/net/sock.h ./linux-4.14.9/include/net/sock.h
--- ./pristine/linux-4.14.9/include/net/sock.h	2017-12-25 13:26:48.000000000 +0000
+++ ./linux-4.14.9/include/net/sock.h	2017-12-27 19:40:12.209134652 +0000
@@ -301,6 +301,7 @@ struct sock_common {
   *	@sk_peek_off: current peek_offset value
   *	@sk_send_head: front of stuff to transmit
   *	@sk_security: used by security modules
+	*	@sk_provenance: used by provenance modules
   *	@sk_mark: generic packet mark
   *	@sk_cgrp_data: cgroup data for this cgroup
   *	@sk_memcg: this socket's memory cgroup association
@@ -468,6 +469,9 @@ struct sock {
 	void			*sk_user_data;
 #ifdef CONFIG_SECURITY
 	void			*sk_security;
+#ifdef CONFIG_SECURITY_PROVENANCE
+	void 			*sk_provenance;
+#endif
 #endif
 	struct sock_cgroup_data	sk_cgrp_data;
 	struct mem_cgroup	*sk_memcg;
diff -uprN -b -B ./pristine/linux-4.14.9/include/uapi/linux/camflow.h ./linux-4.14.9/include/uapi/linux/camflow.h
--- ./pristine/linux-4.14.9/include/uapi/linux/camflow.h	1970-01-01 01:00:00.000000000 +0100
+++ ./linux-4.14.9/include/uapi/linux/camflow.h	2017-12-27 19:40:12.209134652 +0000
@@ -0,0 +1,26 @@
+/*
+ *
+ * Author: Thomas Pasquier <thomas.pasquier@cl.cam.ac.uk>
+ *
+ * Copyright (C) 2015-2017 University of Cambridge, Harvard University
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2, as
+ * published by the Free Software Foundation; either version 2 of the License,
+ * or (at your option) any later version.
+ *
+ */
+#ifndef _UAPI_LINUX_CAMFLOW_H
+#define _UAPI_LINUX_CAMFLOW_H
+
+#define xstr(s) str(s)
+#define str(s) # s
+
+#define CAMFLOW_VERSION_MAJOR     0
+#define CAMFLOW_VERSION_MINOR     3
+#define CAMFLOW_VERSION_PATCH     9
+#define CAMFLOW_VERSION_STR "v"xstr(CAMFLOW_VERSION_MAJOR)\
+  "."xstr(CAMFLOW_VERSION_MINOR)\
+  "."xstr(CAMFLOW_VERSION_PATCH)\
+
+#endif
diff -uprN -b -B ./pristine/linux-4.14.9/include/uapi/linux/provenance.h ./linux-4.14.9/include/uapi/linux/provenance.h
--- ./pristine/linux-4.14.9/include/uapi/linux/provenance.h	1970-01-01 01:00:00.000000000 +0100
+++ ./linux-4.14.9/include/uapi/linux/provenance.h	2017-12-27 19:40:12.209134652 +0000
@@ -0,0 +1,454 @@
+/*
+ *
+ * Author: Thomas Pasquier <thomas.pasquier@cl.cam.ac.uk>
+ *
+ * Copyright (C) 2015-2017 University of Cambridge, Harvard University
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2, as
+ * published by the Free Software Foundation; either version 2 of the License,
+ * or (at your option) any later version.
+ *
+ */
+#ifndef _UAPI_LINUX_PROVENANCE_H
+#define _UAPI_LINUX_PROVENANCE_H
+
+#ifndef __KERNEL__
+#include <linux/limits.h>
+#else
+#include <linux/socket.h>
+#include <linux/limits.h>
+#include <linux/mutex.h>
+#endif
+
+#define PROVENANCE_HASH "sha256"
+
+#define PROV_GOLDEN_RATIO_64 0x61C8864680B583EBUL
+static inline uint32_t prov_hash(uint64_t val)
+{
+	return (val * PROV_GOLDEN_RATIO_64) >> (64 - 8);
+}
+
+#define PROV_K_HASH 7
+#define PROV_M_BITS 256
+#define PROV_N_BYTES (PROV_M_BITS / 8)
+#define PROV_BYTE_INDEX(a) (a / 8)
+#define PROV_BIT_INDEX(a) (a % 8)
+
+static inline void prov_bloom_add(uint8_t bloom[PROV_N_BYTES], uint64_t val)
+{
+	uint8_t i;
+	uint32_t pos;
+
+	for (i = 0; i < PROV_K_HASH; i++) {
+		pos = prov_hash(val + i) % PROV_M_BITS;
+		bloom[PROV_BYTE_INDEX(pos)] |= 1 << PROV_BIT_INDEX(pos);
+	}
+}
+
+// djb2 hash implementation by Dan Bernstein
+static inline uint64_t djb2_hash(const char *str)
+{
+	uint64_t hash = 5381;
+	int c = *str;
+
+	while (c) {
+		hash = ((hash<<5)+hash) + c;
+		c = *++str;
+	}
+	return hash;
+}
+#define generate_label(str) djb2_hash(str)
+
+/* element in set belong to super */
+static inline bool prov_bloom_match(const uint8_t super[PROV_N_BYTES], const uint8_t set[PROV_N_BYTES])
+{
+	uint8_t i;
+
+	for (i = 0; i < PROV_N_BYTES; i++)
+		if ((super[i] & set[i]) != set[i])
+			return false;
+	return true;
+}
+
+static inline bool prov_bloom_in(const uint8_t bloom[PROV_N_BYTES], uint64_t val)
+{
+	uint8_t tmp[PROV_N_BYTES];
+
+	memset(tmp, 0, PROV_N_BYTES);
+	prov_bloom_add(tmp, val);
+	return prov_bloom_match(bloom, tmp);
+}
+
+/* merge src into dest (dest=dest U src) */
+static inline void prov_bloom_merge(uint8_t dest[PROV_N_BYTES], const uint8_t src[PROV_N_BYTES])
+{
+	uint8_t i;
+
+	for (i = 0; i < PROV_N_BYTES; i++)
+		dest[i] |= src[i];
+}
+
+
+static inline bool prov_bloom_empty(const uint8_t bloom[PROV_N_BYTES])
+{
+	uint8_t i;
+
+	for (i = 0; i < PROV_N_BYTES; i++)
+		if (bloom[i] != 0)
+			return false;
+	return true;
+}
+
+#define PROV_ENABLE_FILE                      "/sys/kernel/security/provenance/enable"
+#define PROV_ALL_FILE                         "/sys/kernel/security/provenance/all"
+#define PROV_COMPRESS_NODE_FILE               "/sys/kernel/security/provenance/compress_node"
+#define PROV_COMPRESS_EDGE_FILE               "/sys/kernel/security/provenance/compress_edge"
+#define PROV_NODE_FILE                        "/sys/kernel/security/provenance/node"
+#define PROV_RELATION_FILE                    "/sys/kernel/security/provenance/relation"
+#define PROV_SELF_FILE                        "/sys/kernel/security/provenance/self"
+#define PROV_MACHINE_ID_FILE                  "/sys/kernel/security/provenance/machine_id"
+#define PROV_BOOT_ID_FILE                  		"/sys/kernel/security/provenance/boot_id"
+#define PROV_NODE_FILTER_FILE                 "/sys/kernel/security/provenance/node_filter"
+#define PROV_RELATION_FILTER_FILE             "/sys/kernel/security/provenance/relation_filter"
+#define PROV_PROPAGATE_NODE_FILTER_FILE       "/sys/kernel/security/provenance/propagate_node_filter"
+#define PROV_PROPAGATE_RELATION_FILTER_FILE   "/sys/kernel/security/provenance/propagate_relation_filter"
+#define PROV_FLUSH_FILE                       "/sys/kernel/security/provenance/flush"
+#define PROV_PROCESS_FILE                     "/sys/kernel/security/provenance/process"
+#define PROV_IPV4_INGRESS_FILE                "/sys/kernel/security/provenance/ipv4_ingress"
+#define PROV_IPV4_EGRESS_FILE                 "/sys/kernel/security/provenance/ipv4_egress"
+#define PROV_SECCTX                           "/sys/kernel/security/provenance/secctx"
+#define PROV_SECCTX_FILTER                    "/sys/kernel/security/provenance/secctx_filter"
+#define PROV_NS_FILTER												"/sys/kernel/security/provenance/ns"
+#define PROV_LOG_FILE													"/sys/kernel/security/provenance/log"
+#define PROV_LOGP_FILE												"/sys/kernel/security/provenance/logp"
+#define PROV_POLICY_HASH_FILE									"/sys/kernel/security/provenance/policy_hash"
+#define PROV_UID_FILTER												"/sys/kernel/security/provenance/uid"
+#define PROV_GID_FILTER												"/sys/kernel/security/provenance/gid"
+#define PROV_TYPE															"/sys/kernel/security/provenance/type"
+#define PROV_VERSION													"/sys/kernel/security/provenance/version"
+#define PROV_CHANNEL													"/sys/kernel/security/provenance/channel"
+
+#define PROV_RELAY_NAME                       "/sys/kernel/debug/provenance"
+#define PROV_LONG_RELAY_NAME                  "/sys/kernel/debug/long_provenance"
+#define PROV_CHANNEL_ROOT											"/sys/kernel/debug/"
+
+#define FLOW_ALLOWED        0
+#define FLOW_DISALLOWED     1
+
+#define prov_id_buffer(prov)          ((prov)->node_info.identifier.buffer)
+#define node_identifier(node)         ((node)->node_info.identifier.node_id)
+#define relation_identifier(relation) ((relation)->relation_info.identifier.relation_id)
+#define get_prov_identifier(node)			((node)->node_info.identifier)
+#define packet_identifier(packet)     ((packet)->pck_info.identifier.packet_id)
+#define node_secid(node)              ((node)->node_info.secid)
+#define node_uid(node)              	((node)->node_info.uid)
+#define node_gid(node)              	((node)->node_info.gid)
+
+#define prov_flag(prov) ((prov)->msg_info.flag)
+#define prov_taint(prov) ((prov)->msg_info.taint)
+#define prov_jiffies(prov) ((prov)->msg_info.jiffies)
+
+struct node_identifier {
+	uint64_t type;
+	uint64_t id;
+	uint32_t boot_id;
+	uint32_t machine_id;
+	uint32_t version;
+};
+
+struct relation_identifier {
+	uint64_t type;
+	uint64_t id;
+	uint32_t boot_id;
+	uint32_t machine_id;
+};
+
+struct packet_identifier {
+	uint64_t type;
+	uint16_t id;
+	uint32_t snd_ip;
+	uint32_t rcv_ip;
+	uint16_t snd_port;
+	uint16_t rcv_port;
+	uint8_t protocol;
+	uint32_t seq;
+};
+
+#define PROV_IDENTIFIER_BUFFER_LENGTH sizeof(struct node_identifier)
+
+union prov_identifier {
+	struct node_identifier node_id;
+	struct relation_identifier relation_id;
+	struct packet_identifier packet_id;
+	uint8_t buffer[PROV_IDENTIFIER_BUFFER_LENGTH];
+};
+
+#define prov_set_flag(node, nbit) 	(prov_flag(node) |= 1 << nbit)
+#define prov_clear_flag(node, nbit) (prov_flag(node) &= ~(1 << nbit))
+#define prov_check_flag(node, nbit) ((prov_flag(node) & (1 << nbit)) == (1 << nbit))
+
+#define RECORDED_BIT 0
+#define set_recorded(node)                  prov_set_flag(node, RECORDED_BIT)
+#define clear_recorded(node)                prov_clear_flag(node, RECORDED_BIT)
+#define provenance_is_recorded(node)        prov_check_flag(node, RECORDED_BIT)
+
+#define NAME_RECORDED_BIT 1
+#define set_name_recorded(node)             prov_set_flag(node, NAME_RECORDED_BIT)
+#define clear_name_recorded(node)           prov_clear_flag(node, NAME_RECORDED_BIT)
+#define provenance_is_name_recorded(node)   prov_check_flag(node, NAME_RECORDED_BIT)
+
+#define TRACKED_BIT 2
+#define set_tracked(node)                   prov_set_flag(node, TRACKED_BIT)
+#define clear_tracked(node)                 prov_clear_flag(node, TRACKED_BIT)
+#define provenance_is_tracked(node)         prov_check_flag(node, TRACKED_BIT)
+
+#define OPAQUE_BIT 3
+#define set_opaque(node)                    prov_set_flag(node, OPAQUE_BIT)
+#define clear_opaque(node)                  prov_clear_flag(node, OPAQUE_BIT)
+#define provenance_is_opaque(node)          prov_check_flag(node, OPAQUE_BIT)
+
+#define PROPAGATE_BIT 4
+#define set_propagate(node)                 prov_set_flag(node, PROPAGATE_BIT)
+#define clear_propagate(node)               prov_clear_flag(node, PROPAGATE_BIT)
+#define provenance_does_propagate(node)     prov_check_flag(node, PROPAGATE_BIT)
+
+#define RECORD_PACKET_BIT 5
+#define set_record_packet(node)							prov_set_flag(node, RECORD_PACKET_BIT)
+#define clear_record_packet(node)						prov_clear_flag(node, RECORD_PACKET_BIT)
+#define provenance_records_packet(node)			prov_check_flag(node, RECORD_PACKET_BIT)
+
+#define LONG_BIT 6
+#define set_is_long(node)							prov_set_flag(node, LONG_BIT)
+#define clear_is_long(node)						prov_clear_flag(node, LONG_BIT)
+#define provenance_is_long(node)			prov_check_flag(node, LONG_BIT)
+
+#define basic_elements union prov_identifier identifier; uint8_t flag; uint64_t jiffies; uint32_t secid; uint32_t uid; uint32_t gid; uint8_t taint[PROV_N_BYTES];	void *var_ptr
+
+struct msg_struct {
+	basic_elements;
+};
+
+#define FILE_INFO_SET 0x01
+
+struct relation_struct {
+	basic_elements;
+	uint8_t allowed;
+	union prov_identifier snd;
+	union prov_identifier rcv;
+	uint8_t set;
+	int64_t offset;
+	uint64_t flags;
+};
+
+struct node_struct {
+	basic_elements;
+};
+
+struct task_prov_struct {
+	basic_elements;
+	uint32_t pid;
+	uint32_t vpid;
+	uint32_t ppid;
+	uint32_t tgid;
+	uint32_t utsns;
+	uint32_t ipcns;
+	uint32_t mntns;
+	uint32_t pidns;
+	uint32_t netns;
+	uint32_t cgroupns;
+	/* usec */
+	uint64_t utime;
+	uint64_t stime;
+	/* KB */
+	uint64_t vm;
+	uint64_t rss;
+	uint64_t hw_vm;
+	uint64_t hw_rss;
+	uint64_t rbytes;
+	uint64_t wbytes;
+	uint64_t cancel_wbytes;
+};
+
+struct inode_prov_struct {
+	basic_elements;
+	uint64_t ino;
+	uint16_t mode;
+	uint8_t sb_uuid[16];
+};
+
+struct iattr_prov_struct {
+	basic_elements;
+	uint32_t valid;
+	uint16_t mode;
+	int64_t size;
+	int64_t atime;
+	int64_t ctime;
+	int64_t mtime;
+};
+
+struct msg_msg_struct {
+	basic_elements;
+	long type;
+};
+
+struct shm_struct {
+	basic_elements;
+	uint16_t mode;
+};
+
+struct sb_struct {
+	basic_elements;
+	uint8_t uuid[16];
+};
+
+struct pck_struct {
+	basic_elements;
+	uint16_t length;
+};
+
+union prov_elt {
+	struct msg_struct msg_info;
+	struct relation_struct relation_info;
+	struct node_struct node_info;
+	struct task_prov_struct task_info;
+	struct inode_prov_struct inode_info;
+	struct msg_msg_struct msg_msg_info;
+	struct shm_struct shm_info;
+	struct sb_struct sb_info;
+	struct pck_struct pck_info;
+	struct iattr_prov_struct iattr_info;
+};
+
+struct str_struct {
+	basic_elements;
+	char str[PATH_MAX];
+	size_t length;
+};
+
+struct file_name_struct {
+	basic_elements;
+	char name[PATH_MAX];
+	size_t length;
+};
+
+struct address_struct {
+	basic_elements;
+	struct sockaddr addr;
+	size_t length;
+};
+
+#define PROV_TRUNCATED 1
+struct pckcnt_struct {
+	basic_elements;
+	uint8_t content[PATH_MAX];
+	size_t length;
+	uint8_t truncated;
+};
+
+struct arg_struct {
+	basic_elements;
+	char value[PATH_MAX];
+	size_t length;
+	uint8_t truncated;
+};
+
+#define PROV_XATTR_NAME_SIZE    256
+#define PROV_XATTR_VALUE_SIZE   (PATH_MAX - PROV_XATTR_NAME_SIZE)
+struct xattr_prov_struct {
+	basic_elements;
+	char name[PROV_XATTR_NAME_SIZE]; // max Linux characters
+	uint8_t value[PROV_XATTR_VALUE_SIZE];
+	size_t size;
+};
+
+struct disc_node_struct {
+	basic_elements;
+	size_t length;
+	char content[PATH_MAX];
+	union prov_identifier parent;
+};
+
+union long_prov_elt {
+	struct msg_struct msg_info;
+	struct relation_struct relation_info;
+	struct node_struct node_info;
+	struct task_prov_struct task_info;
+	struct inode_prov_struct inode_info;
+	struct msg_msg_struct msg_msg_info;
+	struct shm_struct shm_info;
+	struct sb_struct sb_info;
+	struct pck_struct pck_info;
+	struct iattr_prov_struct iattr_info;
+	struct str_struct str_info;
+	struct file_name_struct file_name_info;
+	struct arg_struct arg_info;
+	struct address_struct address_info;
+	struct pckcnt_struct pckcnt_info;
+	struct disc_node_struct disc_node_info;
+	struct xattr_prov_struct xattr_info;
+};
+
+typedef union long_prov_elt prov_entry_t;
+
+struct prov_filter {
+	uint64_t filter;
+	uint64_t mask;
+	uint8_t add;
+};
+
+#define PROV_SET_TRACKED      0x01
+#define PROV_SET_OPAQUE       0x02
+#define PROV_SET_PROPAGATE    0x04
+#define PROV_SET_TAINT        0x08
+#define PROV_SET_DELETE       0x10
+#define PROV_SET_RECORD       0x20
+
+struct prov_process_config {
+	union prov_elt prov;
+	uint8_t op;
+	uint32_t vpid;
+};
+
+struct prov_ipv4_filter {
+	uint32_t ip;
+	uint32_t mask;
+	uint16_t port;
+	uint8_t op;
+	uint64_t taint;
+};
+
+struct secinfo {
+	uint32_t secid;
+	char secctx[PATH_MAX];
+	uint32_t len;
+	uint8_t op;
+	uint64_t taint;
+};
+
+struct userinfo {
+	uint32_t uid;
+	uint8_t op;
+	uint64_t taint;
+};
+
+struct groupinfo {
+	uint32_t gid;
+	uint8_t op;
+	uint64_t taint;
+};
+
+#define IGNORE_NS 0
+
+struct nsinfo {
+	uint32_t utsns;
+	uint32_t ipcns;
+	uint32_t mntns;
+	uint32_t pidns;
+	uint32_t netns;
+	uint32_t cgroupns;
+	uint8_t op;
+	uint64_t taint;
+};
+
+#endif
diff -uprN -b -B ./pristine/linux-4.14.9/include/uapi/linux/provenance_types.h ./linux-4.14.9/include/uapi/linux/provenance_types.h
--- ./pristine/linux-4.14.9/include/uapi/linux/provenance_types.h	1970-01-01 01:00:00.000000000 +0100
+++ ./linux-4.14.9/include/uapi/linux/provenance_types.h	2017-12-27 19:40:12.209134652 +0000
@@ -0,0 +1,202 @@
+/*
+ *
+ * Author: Thomas Pasquier <tfjmp@g.harvard.edu>
+ *
+ * Copyright (C) 2015-2017 University of Cambridge, Harvard University
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2, as
+ * published by the Free Software Foundation; either version 2 of the License,
+ * or (at your option) any later version.
+ *
+ */
+#ifndef _UAPI_LINUX_PROVENANCE_TYPES_H
+#define _UAPI_LINUX_PROVENANCE_TYPES_H
+
+#ifndef __KERNEL__
+#include <stdint.h>
+#include <stdbool.h>
+#endif
+
+
+#define TYPE_MASK             0xFFFF000000000000UL
+#define SUBTYPE_MASK          0x0000FFFFFFFFFFFFUL
+
+#define W3C_TYPE(type)        (type & TYPE_MASK)
+#define SUBTYPE(type)         (type & SUBTYPE_MASK)
+
+/* W3C PROV TYPES */
+#define DM_RELATION           0x8000000000000000UL
+#define DM_ACTIVITY           0x4000000000000000UL
+#define DM_ENTITY             0x2000000000000000UL
+#define DM_AGENT              0x1000000000000000UL
+/* ALLOWED/DISALLOWED */
+#define RL_ALLOWED            0x0200000000000000UL
+#define RL_DISALLOWED         0x0100000000000000UL
+/* SUBTYPES */
+/* RELATIONS W3C TYPE*/
+#define RL_DERIVED            (DM_RELATION | 0x0080000000000000ULL)
+#define RL_GENERATED          (DM_RELATION | 0x0040000000000000ULL)
+#define RL_USED               (DM_RELATION | 0x0020000000000000ULL)
+#define RL_INFORMED           (DM_RELATION | 0x0010000000000000ULL)
+/* DERIVED SUBTYPES */
+#define RL_NAMED              (RL_DERIVED   | 0x0000000000000001ULL)
+#define RL_VERSION            (RL_DERIVED   | (0x0000000000000001ULL<<1))
+#define RL_MMAP               (RL_DERIVED   | (0x0000000000000001ULL<<2))
+#define RL_SND_PACKET         (RL_DERIVED   | (0x0000000000000001ULL<<3))
+#define RL_RCV_PACKET         (RL_DERIVED   | (0x0000000000000001ULL<<4))
+#define RL_CLOSED             (RL_DERIVED   | (0x0000000000000001ULL<<5))
+#define RL_SETATTR_INODE      (RL_DERIVED   | (0x0000000000000001ULL<<6))
+#define RL_ACCEPT_SOCKET      (RL_DERIVED   | (0x0000000000000001ULL<<7))
+#define RL_GETXATTR_INODE     (RL_DERIVED   | (0x0000000000000001ULL<<8))
+#define RL_SETXATTR_INODE     (RL_DERIVED   | (0x0000000000000001ULL<<9))
+#define RL_RMVXATTR_INODE     (RL_DERIVED   | (0x0000000000000001ULL<<10))
+#define RL_LINK_INODE         (RL_DERIVED   | (0x0000000000000001ULL<<11))
+/* GENERATED SUBTYPES */
+#define RL_CREATE             (RL_GENERATED | (0x0000000000000001ULL<<12))
+#define RL_WRITE              (RL_GENERATED | (0x0000000000000001ULL<<13))
+#define RL_MMAP_WRITE         (RL_GENERATED | (0x0000000000000001ULL<<14))
+#define RL_SH_WRITE           (RL_GENERATED | (0x0000000000000001ULL<<15))
+#define RL_CONNECT            (RL_GENERATED | (0x0000000000000001ULL<<16))
+#define RL_LISTEN             (RL_GENERATED | (0x0000000000000001ULL<<17))
+#define RL_BIND               (RL_GENERATED | (0x0000000000000001ULL<<18))
+#define RL_SND                (RL_GENERATED | (0x0000000000000001ULL<<19))
+#define RL_SND_UNIX           (RL_GENERATED | (0x0000000000000001ULL<<20))
+#define RL_LINK               (RL_GENERATED | (0x0000000000000001ULL<<21))
+#define RL_SETATTR            (RL_GENERATED | (0x0000000000000001ULL<<22))
+#define RL_SETXATTR           (RL_GENERATED | (0x0000000000000001ULL<<23))
+#define RL_RMVXATTR           (RL_GENERATED | (0x0000000000000001ULL<<24))
+#define RL_MUNMAP          		(RL_GENERATED | (0x0000000000000001ULL<<25))
+/* USED SUBTYPES */
+#define RL_READ               (RL_USED      | (0x0000000000000001ULL<<26))
+#define RL_MMAP_READ          (RL_USED      | (0x0000000000000001ULL<<27))
+#define RL_SH_READ            (RL_USED      | (0x0000000000000001ULL<<28))
+#define RL_EXEC               (RL_USED      | (0x0000000000000001ULL<<29))
+#define RL_MMAP_EXEC          (RL_USED      | (0x0000000000000001ULL<<30))
+#define RL_ACCEPT             (RL_USED      | (0x0000000000000001ULL<<31))
+#define RL_RCV                (RL_USED      | (0x0000000000000001ULL<<32))
+#define RL_RCV_UNIX           (RL_USED      | (0x0000000000000001ULL<<33))
+#define RL_OPEN               (RL_USED      | (0x0000000000000001ULL<<34))
+#define RL_SEARCH             (RL_USED      | (0x0000000000000001ULL<<35))
+#define RL_GETATTR            (RL_USED      | (0x0000000000000001ULL<<36))
+#define RL_READLINK           (RL_USED      | (0x0000000000000001ULL<<37))
+#define RL_GETXATTR           (RL_USED      | (0x0000000000000001ULL<<38))
+#define RL_LSTXATTR           (RL_USED      | (0x0000000000000001ULL<<39))
+#define RL_NAMED_PROCESS      (RL_USED      | (0x0000000000000001ULL<<40))
+#define RL_LOG                (RL_USED      | (0x0000000000000001ULL<<41))
+#define RL_ARG                (RL_USED      | (0x0000000000000001ULL<<42))
+#define RL_ENV                (RL_USED      | (0x0000000000000001ULL<<43))
+#define RL_PERM_READ          (RL_USED      | (0x0000000000000001ULL<<44))
+#define RL_PERM_WRITE         (RL_USED      | (0x0000000000000001ULL<<45))
+#define RL_PERM_EXEC          (RL_USED      | (0x0000000000000001ULL<<46))
+/* INFORMED SUBTYPES */
+#define RL_CLONE              (RL_INFORMED  | (0x0000000000000001ULL<<47))
+#define RL_VERSION_PROCESS    (RL_INFORMED  | (0x0000000000000001ULL<<48))
+#define RL_CHANGE             (RL_INFORMED  | (0x0000000000000001ULL<<49))
+#define RL_EXEC_PROCESS       (RL_INFORMED  | (0x0000000000000001ULL<<50))
+#define RL_TERMINATE_PROCESS  (RL_INFORMED  | (0x0000000000000001ULL<<51))
+
+/* ACTIVITY SUBTYPES */
+#define ACT_TASK              (DM_ACTIVITY  | 0x0000000000000001ULL)
+#define ACT_DISC              (DM_ACTIVITY  | (0x0000000000000001ULL<<1))
+/* AGENT SUBTYPES */
+#define AGT_USR               (DM_AGENT     | 0x0000000000000001ULL<<2))
+#define AGT_GRP               (DM_AGENT     | (0x0000000000000001ULL<<3))
+#define AGT_DISC              (DM_AGENT     | (0x0000000000000001ULL<<4))
+/* ENTITY SUBTYPES */
+#define ENT_STR               (DM_ENTITY    | (0x0000000000000001ULL<<5))
+#define ENT_INODE_UNKNOWN     (DM_ENTITY    | (0x0000000000000001ULL<<6))
+#define ENT_INODE_LINK        (DM_ENTITY    | (0x0000000000000001ULL<<7))
+#define ENT_INODE_FILE        (DM_ENTITY    | (0x0000000000000001ULL<<8))
+#define ENT_INODE_DIRECTORY   (DM_ENTITY    | (0x0000000000000001ULL<<9))
+#define ENT_INODE_CHAR        (DM_ENTITY    | (0x0000000000000001ULL<<10))
+#define ENT_INODE_BLOCK       (DM_ENTITY    | (0x0000000000000001ULL<<11))
+#define ENT_INODE_FIFO        (DM_ENTITY    | (0x0000000000000001ULL<<12))
+#define ENT_INODE_SOCKET      (DM_ENTITY    | (0x0000000000000001ULL<<13))
+#define ENT_INODE_MMAP        (DM_ENTITY    | (0x0000000000000001ULL<<14))
+#define ENT_MSG               (DM_ENTITY    | (0x0000000000000001ULL<<15))
+#define ENT_SHM               (DM_ENTITY    | (0x0000000000000001ULL<<16))
+#define ENT_ADDR              (DM_ENTITY    | (0x0000000000000001ULL<<17))
+#define ENT_SBLCK             (DM_ENTITY    | (0x0000000000000001ULL<<18))
+#define ENT_FILE_NAME         (DM_ENTITY    | (0x0000000000000001ULL<<19))
+#define ENT_PACKET            (DM_ENTITY    | (0x0000000000000001ULL<<20))
+#define ENT_DISC              (DM_ENTITY    | (0x0000000000000001ULL<<21))
+#define ENT_IATTR             (DM_ENTITY    | (0x0000000000000001ULL<<22))
+#define ENT_XATTR             (DM_ENTITY    | (0x0000000000000001ULL<<23))
+#define ENT_PCKCNT            (DM_ENTITY    | (0x0000000000000001ULL<<24))
+#define ENT_ARG               (DM_ENTITY    | (0x0000000000000001ULL<<25))
+#define ENT_ENV               (DM_ENTITY    | (0x0000000000000001ULL<<26))
+
+#define prov_type(prov) ((prov)->node_info.identifier.node_id.type)
+#define node_type(node) prov_type(node)
+#define edge_type(edge) prov_type(edge)
+#define prov_is_relation(prov) ((relation_identifier(prov).type & DM_RELATION) != 0)
+#define prov_is_node(prov) ((node_identifier(prov).type & DM_RELATION) == 0)
+#define prov_is_packet(prov) (node_type(prov) == ENT_PACKET)
+
+#define prov_is_type(val, type) ((val&type)==type)
+#define prov_is_used(val) prov_is_type(type, RL_USED)
+#define prov_is_informed(val) prov_is_type(val, RL_INFORMED)
+#define prov_is_generated(val) prov_is_type(val, RL_GENERATED)
+#define prov_is_derived(val) prov_is_type(val, RL_DERIVED)
+
+static inline bool prov_has_uidgid(uint64_t type)
+{
+	switch (type) {
+  	case ACT_TASK:
+  	case ENT_INODE_UNKNOWN:
+  	case ENT_INODE_LINK:
+  	case ENT_INODE_FILE:
+  	case ENT_INODE_DIRECTORY:
+  	case ENT_INODE_CHAR:
+  	case ENT_INODE_BLOCK:
+  	case ENT_INODE_FIFO:
+  	case ENT_INODE_SOCKET:
+  	case ENT_INODE_MMAP:
+  		return true;
+  	default: return false;
+	}
+}
+
+static inline bool prov_is_inode(uint64_t type)
+{
+	switch (type) {
+  	case ENT_INODE_UNKNOWN:
+  	case ENT_INODE_LINK:
+  	case ENT_INODE_FILE:
+  	case ENT_INODE_DIRECTORY:
+  	case ENT_INODE_CHAR:
+  	case ENT_INODE_BLOCK:
+  	case ENT_INODE_FIFO:
+  	case ENT_INODE_SOCKET:
+  	case ENT_INODE_MMAP:
+  		return true;
+  	default: return false;
+	}
+}
+
+static inline bool prov_has_secid(uint64_t type)
+{
+	switch (type) {
+	case ACT_TASK:
+	case ENT_INODE_UNKNOWN:
+	case ENT_INODE_LINK:
+	case ENT_INODE_FILE:
+	case ENT_INODE_DIRECTORY:
+	case ENT_INODE_CHAR:
+	case ENT_INODE_BLOCK:
+	case ENT_INODE_FIFO:
+	case ENT_INODE_SOCKET:
+	case ENT_INODE_MMAP:
+		return true;
+	default: return false;
+	}
+}
+
+struct prov_type{
+  uint64_t id;
+  char str[256];
+  uint8_t is_relation;
+};
+
+#endif //_UAPI_LINUX_PROVENANCE_TYPES_H
diff -uprN -b -B ./pristine/linux-4.14.9/include/uapi/linux/xattr.h ./linux-4.14.9/include/uapi/linux/xattr.h
--- ./pristine/linux-4.14.9/include/uapi/linux/xattr.h	2017-12-25 13:26:48.000000000 +0000
+++ ./linux-4.14.9/include/uapi/linux/xattr.h	2017-12-27 19:40:12.210134661 +0000
@@ -53,6 +53,9 @@
 #define XATTR_SELINUX_SUFFIX "selinux"
 #define XATTR_NAME_SELINUX XATTR_SECURITY_PREFIX XATTR_SELINUX_SUFFIX

+#define XATTR_PROVENANCE_SUFFIX "provenance"
+#define XATTR_NAME_PROVENANCE XATTR_SECURITY_PREFIX XATTR_PROVENANCE_SUFFIX
+
 #define XATTR_SMACK_SUFFIX "SMACK64"
 #define XATTR_SMACK_IPIN "SMACK64IPIN"
 #define XATTR_SMACK_IPOUT "SMACK64IPOUT"
diff -uprN -b -B ./pristine/linux-4.14.9/ipc/mqueue.c ./linux-4.14.9/ipc/mqueue.c
--- ./pristine/linux-4.14.9/ipc/mqueue.c	2017-12-25 13:26:48.000000000 +0000
+++ ./linux-4.14.9/ipc/mqueue.c	2017-12-27 07:56:41.248544708 +0000
@@ -1019,6 +1019,11 @@ static int do_mq_timedsend(mqd_t mqdes,
 	msg_ptr->m_ts = msg_len;
 	msg_ptr->m_type = msg_prio;

+#ifdef CONFIG_SECURITY_FLOW_FRIENDLY
+	ret = security_mq_timedsend(inode, msg_ptr, msg_len, timeout ? ts : NULL);
+	if (ret)
+		goto out_free;
+#endif
 	/*
 	 * msg_insert really wants us to have a valid, spare node struct so
 	 * it doesn't have to kmalloc a GFP_ATOMIC allocation, but it will
@@ -1166,8 +1171,14 @@ static int do_mq_timedreceive(mqd_t mqde
 		ret = 0;
 	}
 	if (ret == 0) {
+#ifdef CONFIG_SECURITY_FLOW_FRIENDLY
+		ret = security_mq_timedreceive(inode, msg_ptr, msg_len, timeout ? ts : NULL);
+		if(ret) {
+			free_msg(msg_ptr);
+			goto out_fput;
+		}
+#endif
 		ret = msg_ptr->m_ts;
-
 		if ((u_msg_prio && put_user(msg_ptr->m_type, u_msg_prio)) ||
 			store_msg(u_msg_ptr, msg_ptr, msg_ptr->m_ts)) {
 			ret = -EFAULT;
diff -uprN -b -B ./pristine/linux-4.14.9/ipc/shm.c ./linux-4.14.9/ipc/shm.c
--- ./pristine/linux-4.14.9/ipc/shm.c	2017-12-25 13:26:48.000000000 +0000
+++ ./linux-4.14.9/ipc/shm.c	2017-12-27 07:56:41.248544708 +0000
@@ -292,6 +292,14 @@ static void shm_close(struct vm_area_str
 	shp->shm_lprid = task_tgid_vnr(current);
 	shp->shm_dtim = ktime_get_real_seconds();
 	shp->shm_nattch--;
+
+#ifdef CONFIG_SECURITY_FLOW_FRIENDLY
+	/* the security module return value is ignored, the purpose of this hook
+	 * is only to let the module know the memory segment is being detached
+	 */
+	security_shm_shmdt(shp);
+#endif
+
 	if (shm_may_destroy(ns, shp))
 		shm_destroy(ns, shp);
 	else
diff -uprN -b -B ./pristine/linux-4.14.9/Makefile ./linux-4.14.9/Makefile
--- ./pristine/linux-4.14.9/Makefile	2017-12-25 13:26:48.000000000 +0000
+++ ./linux-4.14.9/Makefile	2017-12-27 07:55:47.546000557 +0000
@@ -2,7 +2,7 @@
 VERSION = 4
 PATCHLEVEL = 14
 SUBLEVEL = 9
-EXTRAVERSION =
+EXTRAVERSION = camflow0.3.9
 NAME = Petit Gorille

 # *DOCUMENTATION*
diff -uprN -b -B ./pristine/linux-4.14.9/mm/mmap.c ./linux-4.14.9/mm/mmap.c
--- ./pristine/linux-4.14.9/mm/mmap.c	2017-12-25 13:26:48.000000000 +0000
+++ ./linux-4.14.9/mm/mmap.c	2017-12-27 07:56:41.249544718 +0000
@@ -2666,6 +2666,13 @@ int do_munmap(struct mm_struct *mm, unsi
 		prev = vma;
 	}

+#ifdef CONFIG_SECURITY_FLOW_FRIENDLY
+	/* The return value is ignored, this LSM hook is only used to let the
+	 * security module know that the memory is being unmapped
+	 */
+	security_mmap_munmap(mm, vma, start, end);
+#endif
+
 	/* Does it split the last one? */
 	last = find_vma(mm, end);
 	if (last && end > last->vm_start) {
diff -uprN -b -B ./pristine/linux-4.14.9/net/socket.c ./linux-4.14.9/net/socket.c
--- ./pristine/linux-4.14.9/net/socket.c	2017-12-25 13:26:48.000000000 +0000
+++ ./linux-4.14.9/net/socket.c	2017-12-27 07:56:41.250544728 +0000
@@ -630,7 +630,12 @@ EXPORT_SYMBOL(__sock_tx_timestamp);

 static inline int sock_sendmsg_nosec(struct socket *sock, struct msghdr *msg)
 {
-	int ret = sock->ops->sendmsg(sock, msg, msg_data_left(msg));
+#ifdef CONFIG_SECURITY_FLOW_FRIENDLY
+	int ret = security_socket_sendmsg_always(sock, msg, msg_data_left(msg));
+	if (ret)
+		return ret;
+#endif
+	ret = sock->ops->sendmsg(sock, msg, msg_data_left(msg));
 	BUG_ON(ret == -EIOCBQUEUED);
 	return ret;
 }
@@ -803,6 +808,11 @@ EXPORT_SYMBOL_GPL(__sock_recv_ts_and_dro
 static inline int sock_recvmsg_nosec(struct socket *sock, struct msghdr *msg,
 				     int flags)
 {
+#ifdef CONFIG_SECURITY_FLOW_FRIENDLY
+	int err = security_socket_recvmsg_always(sock, msg, msg_data_left(msg), flags);
+	if (err)
+		return err;
+#endif
 	return sock->ops->recvmsg(sock, msg, msg_data_left(msg), flags);
 }

diff -uprN -b -B ./pristine/linux-4.14.9/security/Kconfig ./linux-4.14.9/security/Kconfig
--- ./pristine/linux-4.14.9/security/Kconfig	2017-12-25 13:26:48.000000000 +0000
+++ ./linux-4.14.9/security/Kconfig	2017-12-27 19:40:12.199134563 +0000
@@ -205,12 +205,21 @@ config STATIC_USERMODEHELPER_PATH
 	  If you wish for all usermode helper programs to be disabled,
 	  specify an empty string here (i.e. "").

+config SECURITY_FLOW_FRIENDLY
+	bool "Security hooks for information flow mechanisms."
+	default y
+	help
+		This option adds hooks to support information flow mechanisms. Some
+		information flow are not captured by LSM as it was designed for access
+		control.
+
 source security/selinux/Kconfig
 source security/smack/Kconfig
 source security/tomoyo/Kconfig
 source security/apparmor/Kconfig
 source security/loadpin/Kconfig
 source security/yama/Kconfig
+source security/provenance/Kconfig

 source security/integrity/Kconfig

diff -uprN -b -B ./pristine/linux-4.14.9/security/Makefile ./linux-4.14.9/security/Makefile
--- ./pristine/linux-4.14.9/security/Makefile	2017-12-25 13:26:48.000000000 +0000
+++ ./linux-4.14.9/security/Makefile	2017-12-27 19:40:12.200134572 +0000
@@ -9,6 +9,7 @@ subdir-$(CONFIG_SECURITY_SMACK)		+= smac
 subdir-$(CONFIG_SECURITY_TOMOYO)        += tomoyo
 subdir-$(CONFIG_SECURITY_APPARMOR)	+= apparmor
 subdir-$(CONFIG_SECURITY_YAMA)		+= yama
+subdir-$(CONFIG_SECURITY_PROVENANCE)	+= provenance
 subdir-$(CONFIG_SECURITY_LOADPIN)	+= loadpin

 # always enable default capabilities
@@ -24,6 +25,7 @@ obj-$(CONFIG_AUDIT)			+= lsm_audit.o
 obj-$(CONFIG_SECURITY_TOMOYO)		+= tomoyo/
 obj-$(CONFIG_SECURITY_APPARMOR)		+= apparmor/
 obj-$(CONFIG_SECURITY_YAMA)		+= yama/
+obj-$(CONFIG_SECURITY_PROVENANCE)		+= provenance/
 obj-$(CONFIG_SECURITY_LOADPIN)		+= loadpin/
 obj-$(CONFIG_CGROUP_DEVICE)		+= device_cgroup.o

diff -uprN -b -B ./pristine/linux-4.14.9/security/provenance/fs.c ./linux-4.14.9/security/provenance/fs.c
--- ./pristine/linux-4.14.9/security/provenance/fs.c	1970-01-01 01:00:00.000000000 +0100
+++ ./linux-4.14.9/security/provenance/fs.c	2017-12-27 19:40:12.200134572 +0000
@@ -0,0 +1,891 @@
+/*
+ *
+ * Author: Thomas Pasquier <thomas.pasquier@cl.cam.ac.uk>
+ *
+ * Copyright (C) 2015-2017 University of Cambridge, Harvard University
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2, as
+ * published by the Free Software Foundation; either version 2 of the License,
+ * or (at your option) any later version.
+ *
+ */
+#include <linux/security.h>
+#include <crypto/hash.h>
+
+#include "provenance.h"
+#include "provenance_record.h"
+#include "provenance_inode.h"
+#include "provenance_net.h"
+#include "provenance_task.h"
+#include "provenance_types.h"
+
+#define TMPBUFLEN       12
+
+#define declare_file_operations(ops_name, write_op, read_op) static const struct file_operations ops_name = { \
+		.write		= write_op, \
+		.read		= read_op, \
+		.llseek		= generic_file_llseek, \
+}
+
+static ssize_t no_read(struct file *filp, char __user *buf, size_t count, loff_t *ppos)
+{
+	return -EPERM; // write only
+}
+
+static ssize_t no_write(struct file *file, const char __user *buf,
+			size_t count, loff_t *ppos)
+{
+	return -EPERM; // read only
+}
+
+static inline void __init_opaque(void)
+{
+	provenance_mark_as_opaque(PROV_ENABLE_FILE);
+	provenance_mark_as_opaque(PROV_ALL_FILE);
+	provenance_mark_as_opaque(PROV_COMPRESS_NODE_FILE);
+	provenance_mark_as_opaque(PROV_COMPRESS_EDGE_FILE);
+	provenance_mark_as_opaque(PROV_NODE_FILE);
+	provenance_mark_as_opaque(PROV_RELATION_FILE);
+	provenance_mark_as_opaque(PROV_SELF_FILE);
+	provenance_mark_as_opaque(PROV_MACHINE_ID_FILE);
+	provenance_mark_as_opaque(PROV_BOOT_ID_FILE);
+	provenance_mark_as_opaque(PROV_NODE_FILTER_FILE);
+	provenance_mark_as_opaque(PROV_RELATION_FILTER_FILE);
+	provenance_mark_as_opaque(PROV_PROPAGATE_NODE_FILTER_FILE);
+	provenance_mark_as_opaque(PROV_PROPAGATE_RELATION_FILTER_FILE);
+	provenance_mark_as_opaque(PROV_FLUSH_FILE);
+	provenance_mark_as_opaque(PROV_PROCESS_FILE);
+	provenance_mark_as_opaque(PROV_IPV4_INGRESS_FILE);
+	provenance_mark_as_opaque(PROV_IPV4_EGRESS_FILE);
+	provenance_mark_as_opaque(PROV_SECCTX);
+	provenance_mark_as_opaque(PROV_SECCTX_FILTER);
+	provenance_mark_as_opaque(PROV_NS_FILTER);
+	provenance_mark_as_opaque(PROV_LOG_FILE);
+	provenance_mark_as_opaque(PROV_LOGP_FILE);
+	provenance_mark_as_opaque(PROV_POLICY_HASH_FILE);
+	provenance_mark_as_opaque(PROV_UID_FILTER);
+	provenance_mark_as_opaque(PROV_GID_FILTER);
+	provenance_mark_as_opaque(PROV_TYPE);
+	provenance_mark_as_opaque(PROV_VERSION);
+	provenance_mark_as_opaque(PROV_CHANNEL);
+}
+
+static inline ssize_t __write_flag(struct file *file, const char __user *buf,
+				   size_t count, loff_t *ppos, bool *flag)
+
+{
+	char *page = NULL;
+	ssize_t length;
+	bool new_value;
+	uint32_t tmp;
+
+	/* no partial write */
+	if (*ppos > 0)
+		return -EINVAL;
+
+	if (!capable(CAP_AUDIT_CONTROL))
+		return -EPERM;
+
+	page = (char*)get_zeroed_page(GFP_KERNEL);
+	if (!page)
+		return -ENOMEM;
+
+	length =  -EFAULT;
+	if (copy_from_user(page, buf, count))
+		goto out;
+
+	length = kstrtouint(page, 2, &tmp);
+	if (length)
+		goto out;
+
+	new_value = tmp;
+	(*flag) = new_value;
+	length = count;
+out:
+	free_page((unsigned long)page);
+	return length;
+}
+
+static ssize_t __read_flag(struct file *filp, char __user *buf,
+			   size_t count, loff_t *ppos, bool flag)
+{
+	char tmpbuf[TMPBUFLEN];
+	ssize_t length;
+	int tmp = flag;
+
+	length = scnprintf(tmpbuf, TMPBUFLEN, "%d", tmp);
+	return simple_read_from_buffer(buf, count, ppos, tmpbuf, length);
+}
+
+#define declare_write_flag_fcn(fcn_name, flag) static ssize_t fcn_name(struct file *file, const char __user *buf, size_t count, loff_t *ppos) \
+	{ \
+		return __write_flag(file, buf, count, ppos, &flag); \
+	}
+#define declare_read_flag_fcn(fcn_name, flag) static ssize_t fcn_name(struct file *filp, char __user *buf, size_t count, loff_t *ppos) \
+	{ \
+		return __read_flag(filp, buf, count, ppos, flag); \
+	}
+
+declare_write_flag_fcn(prov_write_enable, prov_policy.prov_enabled);
+declare_read_flag_fcn(prov_read_enable, prov_policy.prov_enabled);
+declare_file_operations(prov_enable_ops, prov_write_enable, prov_read_enable);
+
+declare_write_flag_fcn(prov_write_all, prov_policy.prov_all);
+declare_read_flag_fcn(prov_read_all, prov_policy.prov_all);
+declare_file_operations(prov_all_ops, prov_write_all, prov_read_all);
+
+declare_write_flag_fcn(prov_write_compress_node, prov_policy.should_compress_node);
+declare_read_flag_fcn(prov_read_compress_node, prov_policy.should_compress_node);
+declare_file_operations(prov_compress_node_ops, prov_write_compress_node, prov_read_compress_node);
+
+declare_write_flag_fcn(prov_write_compress_edge, prov_policy.should_compress_edge);
+declare_read_flag_fcn(prov_read_compress_edge, prov_policy.should_compress_edge);
+declare_file_operations(prov_compress_edge_ops, prov_write_compress_edge, prov_read_compress_edge);
+
+
+static ssize_t prov_write_machine_id(struct file *file, const char __user *buf,
+				     size_t count, loff_t *ppos)
+{
+	uint32_t *tmp = (uint32_t*)buf;
+
+	// ideally should be decoupled from set machine id
+	__init_opaque();
+
+	if (!capable(CAP_AUDIT_CONTROL))
+		return -EPERM;
+
+	if (count < sizeof(uint32_t))
+		return -ENOMEM;
+
+	if (copy_from_user(&prov_machine_id, tmp, sizeof(uint32_t)))
+		return -EAGAIN;
+
+	pr_info("Provenance: machine ID %d\n", prov_machine_id);
+	return count; // read only
+}
+
+static ssize_t prov_read_machine_id(struct file *filp, char __user *buf,
+				    size_t count, loff_t *ppos)
+{
+	if (count < sizeof(uint32_t))
+		return -ENOMEM;
+
+	if (copy_to_user(buf, &prov_machine_id, sizeof(uint32_t)))
+		return -EAGAIN;
+
+	return count;
+}
+declare_file_operations(prov_machine_id_ops, prov_write_machine_id, prov_read_machine_id);
+
+static ssize_t prov_write_boot_id(struct file *file, const char __user *buf,
+				  size_t count, loff_t *ppos)
+{
+	uint32_t *tmp = (uint32_t*)buf;
+
+	if (!capable(CAP_AUDIT_CONTROL))
+		return -EPERM;
+
+	if (count < sizeof(uint32_t))
+		return -ENOMEM;
+
+	if (copy_from_user(&prov_boot_id, tmp, sizeof(uint32_t)))
+		return -EAGAIN;
+
+	pr_info("Provenance: boot ID %d\n", prov_boot_id);
+	return count; // read only
+}
+
+static ssize_t prov_read_boot_id(struct file *filp, char __user *buf,
+				 size_t count, loff_t *ppos)
+{
+	if (count < sizeof(uint32_t))
+		return -ENOMEM;
+
+	if (copy_to_user(buf, &prov_boot_id, sizeof(uint32_t)))
+		return -EAGAIN;
+
+	return count;
+}
+declare_file_operations(prov_boot_id_ops, prov_write_boot_id, prov_read_boot_id);
+
+
+static ssize_t prov_write_node(struct file *file, const char __user *buf,
+			       size_t count, loff_t *ppos)
+
+{
+	struct provenance *cprov = get_current_provenance();
+	union long_prov_elt *node = NULL;
+
+	if (!capable(CAP_AUDIT_WRITE))
+		return -EPERM;
+
+	if (count < sizeof(struct disc_node_struct))
+		return -ENOMEM;
+
+	node = kzalloc(sizeof(union long_prov_elt), GFP_KERNEL);
+	if (!node)
+		return -ENOMEM;
+
+	if (copy_from_user(node, buf, sizeof(struct disc_node_struct))) {
+		count = -ENOMEM;
+		goto out;
+	}
+	if (prov_type(node) == ENT_DISC || prov_type(node) == ACT_DISC || prov_type(node) == AGT_DISC) {
+		spin_lock_nested(prov_lock(cprov), PROVENANCE_LOCK_TASK);
+		__write_node(prov_entry(cprov));
+		copy_identifier(&node->disc_node_info.parent, &prov_elt(cprov)->node_info.identifier);
+		spin_unlock(prov_lock(cprov));
+		node_identifier(node).id = prov_next_id();
+		node_identifier(node).boot_id = prov_boot_id;
+		node_identifier(node).machine_id = prov_machine_id;
+		__write_node(node);
+	} else{ // the node is not of disclosed type
+		count = -EINVAL;
+		goto out;
+	}
+
+	if (copy_to_user((void*)buf, &node, count)) {
+		count = -ENOMEM;
+		goto out;
+	}
+
+out:
+	kfree(node);
+	return count;
+}
+declare_file_operations(prov_node_ops, prov_write_node, no_read);
+
+static ssize_t prov_write_relation(struct file *file, const char __user *buf,
+				   size_t count, loff_t *ppos)
+{
+	union prov_elt relation;
+
+	if (!capable(CAP_AUDIT_WRITE))
+		return -EPERM;
+
+	if (count < sizeof(struct relation_struct))
+		return -ENOMEM;
+
+	if (copy_from_user(&relation, buf, sizeof(struct relation_struct)))
+		return -ENOMEM;
+
+	prov_write(&relation);
+	return count;
+}
+declare_file_operations(prov_relation_ops, prov_write_relation, no_read);
+
+static inline void update_prov_config(union prov_elt *setting, uint8_t op, struct provenance *prov)
+{
+	spin_lock_nested(prov_lock(prov), PROVENANCE_LOCK_TASK);
+	if ((op & PROV_SET_TRACKED) != 0) {
+		if (provenance_is_tracked(setting))
+			set_tracked(prov_elt(prov));
+		else
+			clear_tracked(prov_elt(prov));
+	}
+
+	if ((op & PROV_SET_OPAQUE) != 0) {
+		if (provenance_is_opaque(setting))
+			set_opaque(prov_elt(prov));
+		else
+			clear_opaque(prov_elt(prov));
+	}
+
+	if ((op & PROV_SET_PROPAGATE) != 0) {
+		if (provenance_does_propagate(setting))
+			set_propagate(prov_elt(prov));
+		else
+			clear_propagate(prov_elt(prov));
+	}
+
+	if ((op & PROV_SET_TAINT) != 0)
+		prov_bloom_merge(prov_taint(prov_elt(prov)), prov_taint(setting));
+	spin_unlock(prov_lock(prov));
+}
+
+static ssize_t prov_write_self(struct file *file, const char __user *buf,
+			       size_t count, loff_t *ppos)
+{
+	struct prov_process_config msg;
+	struct provenance *prov = get_current_provenance();
+
+	if (count < sizeof(struct prov_process_config))
+		return -EINVAL;
+
+	if (copy_from_user(&msg, buf, sizeof(struct prov_process_config)))
+		return -ENOMEM;
+
+	update_prov_config(&(msg.prov), msg.op, prov);
+	return sizeof(struct prov_process_config);
+}
+
+static ssize_t prov_read_self(struct file *filp, char __user *buf,
+			      size_t count, loff_t *ppos)
+{
+	struct provenance *cprov = get_current_provenance();
+	union prov_elt *tmp = (union prov_elt*)buf;
+
+	if (count < sizeof(struct task_prov_struct))
+		return -ENOMEM;
+
+	spin_lock_nested(prov_lock(cprov), PROVENANCE_LOCK_TASK);
+	if (copy_to_user(tmp, prov_elt(cprov), sizeof(union prov_elt)))
+		count = -EAGAIN;
+	spin_unlock(prov_lock(cprov));
+	return count; // write only
+}
+declare_file_operations(prov_self_ops, prov_write_self, prov_read_self);
+
+static inline ssize_t __write_filter(struct file *file, const char __user *buf,
+				     size_t count, uint64_t *filter)
+{
+	struct prov_filter *setting;
+
+	if (!capable(CAP_AUDIT_CONTROL))
+		return -EPERM;
+
+	if (count < sizeof(struct prov_filter))
+		return -ENOMEM;
+
+	setting = (struct prov_filter*)buf;
+
+	if (setting->add != 0)
+		(*filter) |= setting->filter & setting->mask;
+	else
+		(*filter) &=  ~(setting->filter & setting->mask);
+
+	return count;
+}
+
+static inline ssize_t __read_filter(struct file *filp, char __user *buf,
+				    size_t count, uint64_t filter)
+{
+	if (count < sizeof(uint64_t))
+		return -ENOMEM;
+
+	if (copy_to_user(buf, &filter, sizeof(uint64_t)))
+		return -EAGAIN;
+
+	return count;
+}
+
+#define declare_write_filter_fcn(fcn_name, filter) static ssize_t fcn_name(struct file *file, const char __user *buf, size_t count, loff_t *ppos) \
+	{ \
+		return __write_filter(file, buf, count, &filter); \
+	}
+#define declare_reader_filter_fcn(fcn_name, filter) static ssize_t fcn_name(struct file *filp, char __user *buf, size_t count, loff_t *ppos) \
+	{ \
+		return __read_filter(filp, buf, count, filter); \
+	}
+
+declare_write_filter_fcn(prov_write_node_filter, prov_policy.prov_node_filter);
+declare_reader_filter_fcn(prov_read_node_filter, prov_policy.prov_node_filter);
+declare_file_operations(prov_node_filter_ops, prov_write_node_filter, prov_read_node_filter);
+
+declare_write_filter_fcn(prov_write_relation_filter, prov_policy.prov_relation_filter);
+declare_reader_filter_fcn(prov_read_relation_filter, prov_policy.prov_relation_filter);
+declare_file_operations(prov_relation_filter_ops, prov_write_relation_filter, prov_read_relation_filter);
+
+declare_write_filter_fcn(prov_write_propagate_node_filter, prov_policy.prov_propagate_node_filter);
+declare_reader_filter_fcn(prov_read_propagate_node_filter, prov_policy.prov_propagate_node_filter);
+declare_file_operations(prov_propagate_node_filter_ops, prov_write_propagate_node_filter, prov_read_propagate_node_filter);
+
+declare_write_filter_fcn(prov_write_propagate_relation_filter, prov_policy.prov_propagate_relation_filter);
+declare_reader_filter_fcn(prov_read_propagate_relation_filter, prov_policy.prov_propagate_relation_filter);
+declare_file_operations(prov_propagate_relation_filter_ops, prov_write_propagate_relation_filter, prov_read_propagate_relation_filter);
+
+static ssize_t prov_write_flush(struct file *file, const char __user *buf,
+				size_t count, loff_t *ppos)
+
+{
+	if (!capable(CAP_AUDIT_CONTROL))
+		return -EPERM;
+
+	prov_flush();
+	return 0;
+}
+declare_file_operations(prov_flush_ops, prov_write_flush, no_read);
+
+static ssize_t prov_write_process(struct file *file, const char __user *buf,
+				  size_t count, loff_t *ppos)
+{
+	struct prov_process_config msg;
+	struct provenance *prov;
+
+	if (!capable(CAP_AUDIT_CONTROL))
+		return -EPERM;
+
+	if (count < sizeof(struct prov_process_config))
+		return -EINVAL;
+
+	if (copy_from_user(&msg, buf, sizeof(struct prov_process_config)))
+		return -ENOMEM;
+
+	prov = prov_from_vpid(msg.vpid);
+	if (!prov)
+		return -EINVAL;
+
+	update_prov_config(&(msg.prov), msg.op, prov);
+	return sizeof(struct prov_process_config);
+}
+
+static ssize_t prov_read_process(struct file *filp, char __user *buf,
+				 size_t count, loff_t *ppos)
+{
+	struct prov_process_config *msg;
+	struct provenance *prov;
+	int rtn = sizeof(struct prov_process_config);
+
+	if (count < sizeof(struct prov_process_config))
+		return -EINVAL;
+
+	msg = (struct prov_process_config*)buf;
+
+	prov = prov_from_vpid(msg->vpid);
+	if (!prov)
+		return -EINVAL;
+
+	spin_lock_nested(prov_lock(prov), PROVENANCE_LOCK_TASK);
+	if (copy_to_user(&msg->prov, prov_elt(prov), sizeof(union prov_elt)))
+		rtn = -ENOMEM;
+	spin_unlock(prov_lock(prov));
+	return rtn;
+}
+declare_file_operations(prov_process_ops, prov_write_process, prov_read_process);
+
+static inline ssize_t __write_ipv4_filter(struct file *file, const char __user *buf,
+					  size_t count, struct list_head *filters)
+{
+	struct ipv4_filters     *f;
+
+	if (!capable(CAP_AUDIT_CONTROL))
+		return -EPERM;
+
+	if (count < sizeof(struct prov_ipv4_filter))
+		return -ENOMEM;
+
+	f = kzalloc(sizeof(struct ipv4_filters), GFP_KERNEL);
+	if (!f)
+		return -ENOMEM;
+
+	if (copy_from_user(&f->filter, buf, sizeof(struct prov_ipv4_filter)))
+		return -EAGAIN;
+	f->filter.ip = f->filter.ip & f->filter.mask;
+
+	// we are not trying to delete something
+	if ((f->filter.op & PROV_SET_DELETE) != PROV_SET_DELETE)
+		prov_ipv4_add_or_update(filters, f);
+	else
+		prov_ipv4_delete(filters, f);
+	return sizeof(struct prov_ipv4_filter);
+}
+
+static inline ssize_t __read_ipv4_filter(struct file *filp, char __user *buf,
+					 size_t count, struct list_head *filters)
+{
+	struct list_head *listentry, *listtmp;
+	struct ipv4_filters *tmp;
+	size_t pos = 0;
+
+	if (count < sizeof(struct prov_ipv4_filter))
+		return -ENOMEM;
+
+	list_for_each_safe(listentry, listtmp, filters) {
+		tmp = list_entry(listentry, struct ipv4_filters, list);
+		if (count < pos + sizeof(struct prov_ipv4_filter))
+			return -ENOMEM;
+
+		if (copy_to_user(buf + pos, &(tmp->filter), sizeof(struct prov_ipv4_filter)))
+			return -EAGAIN;
+
+		pos += sizeof(struct prov_ipv4_filter);
+	}
+	return pos;
+}
+
+#define declare_write_ipv4_filter_fcn(fcn_name, filter) static ssize_t fcn_name(struct file *file, const char __user *buf, size_t count, loff_t *ppos) \
+	{ \
+		return __write_ipv4_filter(file, buf, count, &filter); \
+	}
+#define declare_reader_ipv4_filter_fcn(fcn_name, filter) static ssize_t fcn_name(struct file *filp, char __user *buf, size_t count, loff_t *ppos) \
+	{ \
+		return __read_ipv4_filter(filp, buf, count, &filter); \
+	}
+
+declare_write_ipv4_filter_fcn(prov_write_ipv4_ingress_filter, ingress_ipv4filters);
+declare_reader_ipv4_filter_fcn(prov_read_ipv4_ingress_filter, ingress_ipv4filters);
+declare_file_operations(prov_ipv4_ingress_filter_ops, prov_write_ipv4_ingress_filter, prov_read_ipv4_ingress_filter);
+
+declare_write_ipv4_filter_fcn(prov_write_ipv4_egress_filter, egress_ipv4filters);
+declare_reader_ipv4_filter_fcn(prov_read_ipv4_egress_filter, egress_ipv4filters);
+declare_file_operations(prov_ipv4_egress_filter_ops, prov_write_ipv4_egress_filter, prov_read_ipv4_egress_filter);
+
+static ssize_t prov_read_secctx(struct file *filp, char __user *buf,
+				size_t count, loff_t *ppos)
+{
+	char *ctx = NULL;
+	uint32_t len;
+	struct secinfo *data;
+	int rtn = 0;
+
+	if (count < sizeof(struct secinfo))
+		return -ENOMEM;
+	data = (struct secinfo*)buf;
+
+	rtn = security_secid_to_secctx(data->secid, &ctx, &len); // read secctx
+	if (rtn < 0)
+		return rtn;
+	if (len < PATH_MAX) {
+		if (copy_to_user(data->secctx, ctx, len)) {
+			rtn = -ENOMEM;
+			goto out;
+		}
+		data->secctx[len] = '\0'; // maybe unecessary
+		data->len = len;
+	} else
+		rtn = -ENOMEM;
+out:
+	security_release_secctx(ctx, len); // security module dealloc
+	return rtn;
+}
+declare_file_operations(prov_secctx_ops, no_write, prov_read_secctx);
+
+#define declare_generic_filter_write(function_name, filters, info, add_function, delete_function) \
+	static ssize_t function_name(struct file *file, const char __user *buf, size_t count, loff_t *ppos) \
+	{ \
+		struct filters *s; \
+		if (count < sizeof(struct info)) \
+			return -ENOMEM; \
+		s = kzalloc(sizeof(struct filters), GFP_KERNEL); \
+		if (!s) \
+			return -ENOMEM; \
+		if (copy_from_user(&s->filter, buf, sizeof(struct info))) \
+			return -EAGAIN; \
+		if ((s->filter.op & PROV_SET_DELETE) != PROV_SET_DELETE) \
+			add_function(s); \
+		else \
+			delete_function(s); \
+		return 0; \
+	}
+
+#define declare_generic_filter_read(function_name, filters, info) \
+	static ssize_t function_name(struct file *filp, char __user *buf, size_t count, loff_t *ppos) \
+	{ \
+		struct list_head *listentry, *listtmp; \
+		struct filters *tmp; \
+		size_t pos = 0; \
+		if (count < sizeof(struct info)) \
+			return -ENOMEM; \
+		list_for_each_safe(listentry, listtmp, &filters) { \
+			tmp = list_entry(listentry, struct filters, list); \
+			if (count < pos + sizeof(struct info)) \
+				return -ENOMEM; \
+			if (copy_to_user(buf + pos, &(tmp->filter), sizeof(struct info))) \
+				return -EAGAIN; \
+			pos += sizeof(struct info); \
+		} \
+		return pos; \
+	}
+
+static ssize_t prov_write_secctx_filter(struct file *file, const char __user *buf,
+					size_t count, loff_t *ppos)
+{
+	struct secctx_filters *s;
+
+	if (count < sizeof(struct secinfo))
+		return -ENOMEM;
+
+	s = kzalloc(sizeof(struct secctx_filters), GFP_KERNEL);
+	if (!s)
+		return -ENOMEM;
+
+	if (copy_from_user(&s->filter, buf, sizeof(struct secinfo)))
+		return -EAGAIN;
+
+	security_secctx_to_secid(s->filter.secctx, s->filter.len, &s->filter.secid);
+	if ((s->filter.op & PROV_SET_DELETE) != PROV_SET_DELETE)
+		prov_secctx_add_or_update(s);
+	else
+		prov_secctx_delete(s);
+	return 0;
+}
+
+declare_generic_filter_read(prov_read_secctx_filter, secctx_filters, secinfo);
+declare_file_operations(prov_secctx_filter_ops, prov_write_secctx_filter, prov_read_secctx_filter);
+
+declare_generic_filter_write(prov_write_uid_filter, user_filters, userinfo, prov_uid_add_or_update, prov_uid_delete);
+declare_generic_filter_read(prov_read_uid_filter, user_filters, userinfo);
+declare_file_operations(prov_uid_filter_ops, prov_write_uid_filter, prov_read_uid_filter);
+
+declare_generic_filter_write(prov_write_gid_filter, group_filters, groupinfo, prov_gid_add_or_update, prov_gid_delete);
+declare_generic_filter_read(prov_read_gid_filter, group_filters, groupinfo);
+declare_file_operations(prov_gid_filter_ops, prov_write_gid_filter, prov_read_gid_filter);
+
+static ssize_t prov_write_ns_filter(struct file *file, const char __user *buf,
+				    size_t count, loff_t *ppos)
+{
+	struct ns_filters *s;
+
+	if (count < sizeof(struct nsinfo))
+		return -ENOMEM;
+
+	s = kzalloc(sizeof(struct ns_filters), GFP_KERNEL);
+	if (!s)
+		return -ENOMEM;
+
+	if (copy_from_user(&s->filter, buf, sizeof(struct nsinfo)))
+		return -EAGAIN;
+	if ((s->filter.op & PROV_SET_DELETE) != PROV_SET_DELETE)
+		prov_ns_add_or_update(s);
+	else
+		prov_ns_delete(s);
+	return 0;
+}
+
+static ssize_t prov_read_ns_filter(struct file *filp, char __user *buf,
+				   size_t count, loff_t *ppos)
+{
+	struct list_head *listentry, *listtmp;
+	struct ns_filters *tmp;
+	size_t pos = 0;
+
+	if (count < sizeof(struct nsinfo))
+		return -ENOMEM;
+
+	list_for_each_safe(listentry, listtmp, &ns_filters) {
+		tmp = list_entry(listentry, struct ns_filters, list);
+		if (count < pos + sizeof(struct nsinfo))
+			return -ENOMEM;
+		if (copy_to_user(buf + pos, &(tmp->filter), sizeof(struct nsinfo)))
+			return -EAGAIN;
+		pos += sizeof(struct nsinfo);
+	}
+	return pos;
+}
+declare_file_operations(prov_ns_filter_ops, prov_write_ns_filter, prov_read_ns_filter);
+
+static ssize_t prov_write_log(struct file *file, const char __user *buf,
+			      size_t count, loff_t *ppos)
+{
+	struct provenance *cprov = get_current_provenance();
+
+	if (count <= 0 || count >= PATH_MAX)
+		return -ENOMEM;
+	set_tracked(prov_elt(cprov));
+	return record_log(prov_elt(cprov), buf, count);
+}
+declare_file_operations(prov_log_ops, prov_write_log, no_read);
+
+static ssize_t prov_write_logp(struct file *file, const char __user *buf,
+			       size_t count, loff_t *ppos)
+{
+	struct provenance *cprov = get_current_provenance();
+
+	if (count <= 0 || count >= PATH_MAX)
+		return -ENOMEM;
+	set_tracked(prov_elt(cprov));
+	set_propagate(prov_elt(cprov));
+	return record_log(prov_elt(cprov), buf, count);
+}
+declare_file_operations(prov_logp_ops, prov_write_logp, no_read);
+
+#define hash_filters(filters, filters_type, tmp, tmp_type) \
+	list_for_each_safe(listentry, listtmp, &filters) { \
+		tmp = list_entry(listentry, struct filters_type, list); \
+		rc = crypto_shash_update(hashdesc, (u8*)&tmp->filter, sizeof(struct tmp_type)); \
+		if (rc) { \
+			pr_err("Provenance: error updating hash."); \
+			pos = -EAGAIN; \
+			goto out; \
+		} \
+	}
+
+static ssize_t prov_read_policy_hash(struct file *filp, char __user *buf,
+				     size_t count, loff_t *ppos)
+{
+	size_t pos = 0;
+	size_t size;
+	int rc;
+	struct crypto_shash *policy_shash_tfm;
+	struct shash_desc *hashdesc = NULL;
+	uint8_t *buff = NULL;
+	struct list_head *listentry, *listtmp;
+	struct ipv4_filters *ipv4_tmp;
+	struct ns_filters *ns_tmp;
+	struct secctx_filters *secctx_tmp;
+	struct user_filters *user_tmp;
+	struct group_filters *group_tmp;
+
+	policy_shash_tfm = crypto_alloc_shash(PROVENANCE_HASH, 0, 0);
+	if (IS_ERR(policy_shash_tfm))
+		return -ENOMEM;
+	pos = crypto_shash_digestsize(policy_shash_tfm);
+	if (count < pos)
+		return -ENOMEM;
+	buff = kzalloc(pos, GFP_KERNEL);
+	if (!buff) {
+		pr_err("Provenance: error allocating hash buffer.");
+		pos = -ENOMEM;
+		goto out;
+	}
+	size = sizeof(struct shash_desc) + crypto_shash_descsize(policy_shash_tfm);
+	hashdesc = kzalloc(size, GFP_KERNEL);
+	if (!hashdesc) {
+		pr_err("Provenance: error allocating hash desc.");
+		pos = -ENOMEM;
+		goto out;
+	}
+	hashdesc->tfm = policy_shash_tfm;
+	hashdesc->flags = 0x0;
+	rc = crypto_shash_init(hashdesc);
+	if (rc) {
+		pr_err("Provenance: error initialising hash.");
+		pos = -EAGAIN;
+		goto out;
+	}
+	/* LSM version */
+	rc = crypto_shash_update(hashdesc, (u8*)CAMFLOW_VERSION_STR, strlen(CAMFLOW_VERSION_STR));
+	if (rc) {
+		pr_err("Provenance: error updating hash.");
+		pos = -EAGAIN;
+		goto out;
+	}
+	/* general policy */
+	rc = crypto_shash_update(hashdesc, (u8*)&prov_policy, sizeof(struct capture_policy));
+	if (rc) {
+		pr_err("Provenance: error updating hash.");
+		pos = -EAGAIN;
+		goto out;
+	}
+	/* ingress network policy */
+	hash_filters(ingress_ipv4filters, ipv4_filters, ipv4_tmp, prov_ipv4_filter);
+	/* egress network policy */
+	hash_filters(egress_ipv4filters, ipv4_filters, ipv4_tmp, prov_ipv4_filter);
+	/* namespace policy */
+	hash_filters(ns_filters, ns_filters, ns_tmp, ns_filters);
+	/* secctx policy */
+	hash_filters(secctx_filters, secctx_filters, secctx_tmp, secinfo);
+	/* userid policy */
+	hash_filters(user_filters, user_filters, user_tmp, userinfo);
+	/* groupid policy */
+	hash_filters(group_filters, group_filters, group_tmp, groupinfo);
+
+	rc = crypto_shash_final(hashdesc, buff);
+	if (rc) {
+		pr_err("Provenance: error finialising hash.");
+		pos = -EAGAIN;
+		goto out;
+	}
+	if (copy_to_user(buf, buff, pos)) {
+		pr_err("Provenance: error copying hash to user.");
+		pos = -EAGAIN;
+		goto out;
+	}
+out:
+	if (!buff)
+		kfree(buff);
+	if (!hashdesc)
+		kfree(hashdesc);
+	crypto_free_shash(policy_shash_tfm);
+	return pos;
+}
+declare_file_operations(prov_policy_hash_ops, no_write, prov_read_policy_hash);
+
+static ssize_t prov_read_prov_type(struct file *filp, char __user *buf,
+				   size_t count, loff_t *ppos)
+{
+	struct prov_type type_info;
+
+	if ( count < sizeof(struct prov_type) )
+		return -ENOMEM;
+	if ( copy_from_user(&type_info, buf, sizeof(struct prov_type)) )
+		return -EAGAIN;
+	if (type_info.is_relation) {
+		if (type_info.id)
+			strncpy(type_info.str, relation_str(type_info.id), 256);
+		else
+			type_info.id = relation_id(type_info.str);
+	}else{
+		if (type_info.id)
+			strncpy(type_info.str, node_str(type_info.id), 256);
+		else
+			type_info.id = node_id(type_info.str);
+	}
+	if ( copy_to_user(buf, &type_info, sizeof(struct prov_type)) )
+		return -EAGAIN;
+	return sizeof(struct prov_type);
+}
+declare_file_operations(prov_type_ops, no_write, prov_read_prov_type);
+
+static ssize_t prov_read_version(struct file *filp, char __user *buf,
+				 size_t count, loff_t *ppos)
+{
+	size_t len = strlen(CAMFLOW_VERSION_STR);
+
+	if ( count < len )
+		return -ENOMEM;
+	memset(buf, 0, count);
+	if ( copy_to_user(buf, CAMFLOW_VERSION_STR, len) )
+		return -EAGAIN;
+	return sizeof(struct prov_type);
+}
+declare_file_operations(prov_version, no_write, prov_read_version);
+
+static ssize_t prov_write_channel(struct file *file, const char __user *buf,
+				  size_t count, loff_t *ppos)
+{
+	char *buffer = kzalloc(count, GFP_KERNEL);
+
+	if (count <= 0 || count > PATH_MAX)
+		return -ENOMEM;
+	if (strlen(buf) > count) // null terminated?
+		return -ENOMEM;
+	if (copy_from_user(buffer, buf, count))
+		return -ENOMEM;
+	return prov_create_channel(buffer, strlen(buffer));
+}
+declare_file_operations(prov_channel_ops, prov_write_channel, no_read);
+
+#define prov_create_file(name, perm, fun_ptr) \
+	securityfs_create_file(name, perm, prov_dir, NULL, fun_ptr)
+
+static int __init init_prov_fs(void)
+{
+	struct dentry *prov_dir;
+
+	prov_dir = securityfs_create_dir("provenance", NULL);
+	prov_create_file("enable", 0644, &prov_enable_ops);
+	prov_create_file("all", 0644, &prov_all_ops);
+	prov_create_file("compress_node", 0644, &prov_compress_node_ops);
+	prov_create_file("compress_edge", 0644, &prov_compress_edge_ops);
+	prov_create_file("node", 0666, &prov_node_ops);
+	prov_create_file("relation", 0666, &prov_relation_ops);
+	prov_create_file("self", 0666, &prov_self_ops);
+	prov_create_file("machine_id", 0444, &prov_machine_id_ops);
+	prov_create_file("boot_id", 0444, &prov_boot_id_ops);
+	prov_create_file("node_filter", 0644, &prov_node_filter_ops);
+	prov_create_file("relation_filter", 0644, &prov_relation_filter_ops);
+	prov_create_file("propagate_node_filter", 0644,
+			 &prov_propagate_node_filter_ops);
+	prov_create_file("propagate_relation_filter", 0644,
+			 &prov_propagate_relation_filter_ops);
+	prov_create_file("flush", 0600, &prov_flush_ops);
+	prov_create_file("process", 0644, &prov_process_ops);
+	prov_create_file("ipv4_ingress", 0644, &prov_ipv4_ingress_filter_ops);
+	prov_create_file("ipv4_egress", 0644, &prov_ipv4_egress_filter_ops);
+	prov_create_file("secctx", 0644, &prov_secctx_ops);
+	prov_create_file("secctx_filter", 0644, &prov_secctx_filter_ops);
+	prov_create_file("ns", 0644, &prov_ns_filter_ops);
+	prov_create_file("log", 0666, &prov_log_ops);
+	prov_create_file("logp", 0666, &prov_logp_ops);
+	prov_create_file("policy_hash", 0444, &prov_policy_hash_ops);
+	prov_create_file("uid", 0644, &prov_uid_filter_ops);
+	prov_create_file("gid", 0644, &prov_gid_filter_ops);
+	prov_create_file("type", 0444, &prov_type_ops);
+	prov_create_file("version", 0444, &prov_version);
+	prov_create_file("channel", 0644, &prov_channel_ops);
+	pr_info("Provenance: fs ready.\n");
+	return 0;
+}
+core_initcall(init_prov_fs);
diff -uprN -b -B ./pristine/linux-4.14.9/security/provenance/hooks.c ./linux-4.14.9/security/provenance/hooks.c
--- ./pristine/linux-4.14.9/security/provenance/hooks.c	1970-01-01 01:00:00.000000000 +0100
+++ ./linux-4.14.9/security/provenance/hooks.c	2017-12-27 19:40:12.200134572 +0000
@@ -0,0 +1,1735 @@
+/*
+ *
+ * Author: Thomas Pasquier <thomas.pasquier@cl.cam.ac.uk>
+ *
+ * Copyright (C) 2015-2017 University of Cambridge, Harvard University
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2, as
+ * published by the Free Software Foundation; either version 2 of the License,
+ * or (at your option) any later version.
+ *
+ */
+#include <linux/slab.h>
+#include <linux/lsm_hooks.h>
+#include <linux/msg.h>
+#include <net/sock.h>
+#include <net/af_unix.h>
+#include <linux/binfmts.h>
+#include <linux/random.h>
+#include <linux/xattr.h>
+#include <linux/file.h>
+#include <linux/workqueue.h>
+
+#include "provenance.h"
+#include "provenance_record.h"
+#include "provenance_net.h"
+#include "provenance_inode.h"
+#include "provenance_task.h"
+
+#ifdef CONFIG_SECURITY_PROVENANCE_PERSISTENCE
+struct save_work {
+	struct work_struct work;
+	struct dentry *dentry;
+};
+
+static void __do_prov_save(struct work_struct *pwork)
+{
+	struct save_work *w = container_of(pwork, struct save_work, work);
+	struct dentry *dentry = w->dentry;
+
+	if (!dentry)
+		goto free_work;
+	save_provenance(dentry);
+free_work:
+	kfree(w);
+}
+
+static struct workqueue_struct *prov_queue;
+static inline void queue_save_provenance(struct provenance *provenance,
+					 struct dentry *dentry)
+{
+	struct save_work *work;
+
+	if (!prov_queue)
+		return;
+	// not initialised or already saved
+	if (!provenance->initialised || provenance->saved)
+		return;
+	work = kmalloc(sizeof(struct save_work), GFP_ATOMIC);
+	if (!work)
+		return;
+	work->dentry = dentry;
+	INIT_WORK(&work->work, __do_prov_save);
+	queue_work(prov_queue, &work->work);
+}
+#else
+static inline void queue_save_provenance(struct provenance *provenance,
+					 struct dentry *dentry)
+{
+}
+#endif
+
+/*
+ * initialise the security for the init task
+ */
+static void cred_init_provenance(void)
+{
+	struct cred *cred = (struct cred*)current->real_cred;
+	struct provenance *prov = alloc_provenance(ACT_TASK, GFP_KERNEL);
+
+	if (!prov)
+		panic("Provenance:  Failed to initialize initial task.\n");
+	node_uid(prov_elt(prov)) = __kuid_val(cred->euid);
+	node_gid(prov_elt(prov)) = __kgid_val(cred->egid);
+	cred->provenance = prov;
+}
+
+/*
+ * @cred points to the credentials.
+ * @gfp indicates the atomicity of any memory allocations.
+ * Only allocate sufficient memory and attach to @cred such that
+ * cred_transfer() will not get ENOMEM.
+ */
+static int provenance_cred_alloc_blank(struct cred *cred, gfp_t gfp)
+{
+	struct provenance *prov  = alloc_provenance(ACT_TASK, gfp);
+
+	if (!prov)
+		return -ENOMEM;
+
+	node_uid(prov_elt(prov)) = __kuid_val(cred->euid);
+	node_gid(prov_elt(prov)) = __kgid_val(cred->egid);
+
+	cred->provenance = prov;
+	return 0;
+}
+
+/*
+ * @cred points to the credentials.
+ * Deallocate and clear the cred->security field in a set of credentials.
+ */
+static void provenance_cred_free(struct cred *cred)
+{
+	if (cred->provenance) {
+		terminate_task(cred->provenance);
+		free_provenance(cred->provenance);
+	}
+	cred->provenance = NULL;
+}
+
+/*
+ * @new points to the new credentials.
+ * @old points to the original credentials.
+ * @gfp indicates the atomicity of any memory allocations.
+ * Prepare a new set of credentials by copying the data from the old set.
+ */
+static int provenance_cred_prepare(struct cred *new,
+				   const struct cred *old,
+				   gfp_t gfp)
+{
+	struct provenance *old_prov = old->provenance;
+	struct provenance *prov = alloc_provenance(ACT_TASK, gfp);
+	unsigned long irqflags;
+	int rc;
+
+	if (!prov)
+		return -ENOMEM;
+	//task_config_from_file(current);
+	node_uid(prov_elt(prov)) = __kuid_val(new->euid);
+	node_gid(prov_elt(prov)) = __kgid_val(new->egid);
+	spin_lock_irqsave_nested(prov_lock(old_prov), irqflags, PROVENANCE_LOCK_TASK);
+	prov->has_mmap = old_prov->has_mmap;
+	rc = informs(RL_CLONE, old_prov, prov, NULL, 0);
+	spin_unlock_irqrestore(prov_lock(old_prov), irqflags);
+	new->provenance = prov;
+	return rc;
+}
+
+/*
+ * @new points to the new credentials.
+ * @old points to the original credentials.
+ * Transfer data from original creds to new creds
+ */
+static void provenance_cred_transfer(struct cred *new, const struct cred *old)
+{
+	const struct provenance *old_prov = old->provenance;
+	struct provenance *prov = new->provenance;
+
+	*prov =  *old_prov;
+}
+
+/*
+ * Update the module's state after setting one or more of the user
+ * identity attributes of the current process.  The @flags parameter
+ * indicates which of the set*uid system calls invoked this hook.if
+ * @new is the set of credentials that will be installed.  Modifications
+ * should be made to this rather than to @current->cred.
+ * @old is the set of credentials that are being replaces
+ * @flags contains one of the LSM_SETID_* values.
+ * Return 0 on success.
+ */
+static int provenance_task_fix_setuid(struct cred *new,
+				      const struct cred *old,
+				      int flags)
+{
+	struct provenance *old_prov = old->provenance;
+	struct provenance *prov = new->provenance;
+	unsigned long irqflags;
+	int rc;
+
+	spin_lock_irqsave_nested(prov_lock(old_prov), irqflags, PROVENANCE_LOCK_TASK);
+	rc = informs(RL_CHANGE, old_prov, prov, NULL, flags);
+	spin_unlock_irqrestore(prov_lock(old_prov), irqflags);
+	return rc;
+}
+
+/*
+ * Allocate and attach a security structure to @inode->i_security.  The
+ * i_security field is initialized to NULL when the inode structure is
+ * allocated.
+ * @inode contains the inode structure.
+ * Return 0 if operation was successful.
+ */
+static int provenance_inode_alloc_security(struct inode *inode)
+{
+	struct provenance *iprov = alloc_provenance(ENT_INODE_UNKNOWN, GFP_KERNEL);
+	struct provenance *sprov;
+
+	if (unlikely(!iprov))
+		return -ENOMEM;
+	sprov = inode->i_sb->s_provenance;
+	memcpy(prov_elt(iprov)->inode_info.sb_uuid, prov_elt(sprov)->sb_info.uuid, 16 * sizeof(uint8_t));
+	inode->i_provenance = iprov;
+	refresh_inode_provenance(inode, true);
+	return 0;
+}
+
+/*
+ * @inode contains the inode structure.
+ * Deallocate the inode security structure and set @inode->i_security to
+ * NULL.
+ */
+static void provenance_inode_free_security(struct inode *inode)
+{
+	if (inode->i_provenance) {
+		close_inode(inode->i_provenance);
+		free_provenance(inode->i_provenance);
+	}
+	inode->i_provenance = NULL;
+}
+
+/*
+ * Check permission to create a regular file.
+ * @dir contains inode structure of the parent of the new file.
+ * @dentry contains the dentry structure for the file to be created.
+ * @mode contains the file mode of the file to be created.
+ * Return 0 if permission is granted.
+ */
+static int provenance_inode_create(struct inode *dir,
+				   struct dentry *dentry,
+				   umode_t mode)
+{
+	struct provenance *cprov = get_current_provenance();
+	struct provenance *iprov = inode_provenance(dir, true);
+	unsigned long irqflags;
+	int rc;
+
+	if (!iprov)
+		return -ENOMEM;
+	spin_lock_irqsave_nested(prov_lock(cprov), irqflags, PROVENANCE_LOCK_TASK);
+	spin_lock_nested(prov_lock(iprov), PROVENANCE_LOCK_DIR);
+	rc = generates(RL_WRITE, cprov, iprov, NULL, mode);
+	spin_unlock(prov_lock(iprov));
+	spin_unlock_irqrestore(prov_lock(cprov), irqflags);
+	return rc;
+}
+
+/*
+ * Check permission before accessing an inode.  This hook is called by the
+ * existing Linux permission function, so a security module can use it to
+ * provide additional checking for existing Linux permission checks.
+ * Notice that this hook is called when a file is opened (as well as many
+ * other operations), whereas the file_security_ops permission hook is
+ * called when the actual read/write operations are performed.
+ * @inode contains the inode structure to check.
+ * @mask contains the permission mask.
+ * Return 0 if permission is granted.
+ */
+static int provenance_inode_permission(struct inode *inode, int mask)
+{
+	struct provenance *cprov = get_current_provenance();
+	struct provenance *iprov = NULL;
+	uint32_t perms;
+	unsigned long irqflags;
+	int rc = 0;
+
+	if (!mask)
+		return 0;
+	if (unlikely(IS_PRIVATE(inode)))
+		return 0;
+	iprov = inode_provenance(inode, false);
+	if (!iprov)
+		return -ENOMEM;
+	perms = file_mask_to_perms(inode->i_mode, mask);
+	spin_lock_irqsave_nested(prov_lock(cprov), irqflags, PROVENANCE_LOCK_TASK);
+	spin_lock_nested(prov_lock(iprov), PROVENANCE_LOCK_INODE);
+	if (is_inode_dir(inode)) {
+		if ((perms & (DIR__WRITE)) != 0)
+			rc = uses(RL_PERM_WRITE, iprov, cprov, NULL, mask);
+		if (rc < 0)
+			goto out;
+		if ((perms & (DIR__READ)) != 0)
+			rc = uses(RL_PERM_READ, iprov, cprov, NULL, mask);
+		if (rc < 0)
+			goto out;
+		if ((perms & (DIR__SEARCH)) != 0)
+			rc = uses(RL_PERM_EXEC, iprov, cprov, NULL, mask);
+	} else if (is_inode_socket(inode)) {
+		if ((perms & (FILE__WRITE | FILE__APPEND)) != 0)
+			rc = uses(RL_PERM_WRITE, iprov, cprov, NULL, mask);
+		if (rc < 0)
+			goto out;
+		if ((perms & (FILE__READ)) != 0)
+			rc = uses(RL_PERM_READ, iprov, cprov, NULL, mask);
+	} else {
+		if ((perms & (FILE__WRITE | FILE__APPEND)) != 0)
+			rc = uses(RL_PERM_WRITE, iprov, cprov, NULL, mask);
+		if (rc < 0)
+			goto out;
+		if ((perms & (FILE__READ)) != 0)
+			rc = uses(RL_PERM_READ, iprov, cprov, NULL, mask);
+		if (rc < 0)
+			goto out;
+		if ((perms & (FILE__EXECUTE)) != 0)
+			rc = uses(RL_PERM_EXEC, iprov, cprov, NULL, mask);
+	}
+out:
+	spin_unlock(prov_lock(iprov));
+	spin_unlock_irqrestore(prov_lock(cprov), irqflags);
+	return rc;
+}
+
+/*
+ * Check permission before creating a new hard link to a file.
+ * @old_dentry contains the dentry structure for an existing
+ * link to the file.
+ * @dir contains the inode structure of the parent directory
+ * of the new link.
+ * @new_dentry contains the dentry structure for the new link.
+ * Return 0 if permission is granted.
+ */
+
+static int provenance_inode_link(struct dentry *old_dentry,
+				 struct inode *dir,
+				 struct dentry *new_dentry)
+{
+	struct provenance *cprov = get_current_provenance();
+	struct provenance *dprov = NULL;
+	struct provenance *iprov;
+	unsigned long irqflags;
+	int rc;
+
+	iprov = dentry_provenance(old_dentry, true);
+	if (!iprov)
+		return -ENOMEM;
+
+	dprov = inode_provenance(dir, true);
+	if (!dprov)
+		return -ENOMEM;
+
+	spin_lock_irqsave_nested(prov_lock(cprov), irqflags, PROVENANCE_LOCK_TASK);
+	spin_lock_nested(prov_lock(dprov), PROVENANCE_LOCK_DIR);
+	spin_lock_nested(prov_lock(iprov), PROVENANCE_LOCK_INODE);
+	rc = generates(RL_LINK, cprov, dprov, NULL, 0);
+	if (rc < 0)
+		goto out;
+	rc = generates(RL_LINK, cprov, iprov, NULL, 0);
+	if (rc < 0)
+		goto out;
+	rc = derives(RL_LINK_INODE, dprov, iprov, NULL, 0);
+out:
+	spin_unlock(prov_lock(iprov));
+	spin_unlock(prov_lock(dprov));
+	spin_unlock_irqrestore(prov_lock(cprov), irqflags);
+	return rc;
+}
+
+// TODO probably deal with unlink (useful for stream processing)
+
+/*
+ * Check for permission to rename a file or directory.
+ * @old_dir contains the inode structure for parent of the old link.
+ * @old_dentry contains the dentry structure of the old link.
+ * @new_dir contains the inode structure for parent of the new link.
+ * @new_dentry contains the dentry structure of the new link.
+ * Return 0 if permission is granted.
+ */
+static int provenance_inode_rename(struct inode *old_dir,
+				   struct dentry *old_dentry,
+				   struct inode *new_dir,
+				   struct dentry *new_dentry)
+{
+	return provenance_inode_link(old_dentry, new_dir, new_dentry);
+}
+
+/*
+ * Check permission before setting file attributes.  Note that the kernel
+ * call to notify_change is performed from several locations, whenever
+ * file attributes change (such as when a file is truncated, chown/chmod
+ * operations, transferring disk quotas, etc).
+ * @dentry contains the dentry structure for the file.
+ * @attr is the iattr structure containing the new file attributes.
+ * Return 0 if permission is granted.
+ */
+static int provenance_inode_setattr(struct dentry *dentry, struct iattr *iattr)
+{
+	struct provenance *cprov = get_current_provenance();
+	struct provenance *iprov;
+	struct provenance *iattrprov;
+	unsigned long irqflags;
+	int rc;
+
+	iprov = dentry_provenance(dentry, true);
+	if (!iprov)
+		return -ENOMEM;
+	iattrprov = alloc_provenance(ENT_IATTR, GFP_KERNEL);
+	if (!iattrprov)
+		return -ENOMEM;
+
+	prov_elt(iattrprov)->iattr_info.valid = iattr->ia_valid;
+	prov_elt(iattrprov)->iattr_info.mode = iattr->ia_mode;
+	node_uid(prov_elt(iattrprov)) = __kuid_val(iattr->ia_uid);
+	node_gid(prov_elt(iattrprov)) = __kgid_val(iattr->ia_gid);
+	prov_elt(iattrprov)->iattr_info.size = iattr->ia_size;
+	prov_elt(iattrprov)->iattr_info.atime = iattr->ia_atime.tv_sec;
+	prov_elt(iattrprov)->iattr_info.mtime = iattr->ia_mtime.tv_sec;
+	prov_elt(iattrprov)->iattr_info.ctime = iattr->ia_ctime.tv_sec;
+
+	spin_lock_irqsave_nested(prov_lock(cprov), irqflags, PROVENANCE_LOCK_TASK);
+	spin_lock_nested(prov_lock(iprov), PROVENANCE_LOCK_INODE);
+	rc = generates(RL_SETATTR, cprov, iattrprov, NULL, 0);
+	if (rc < 0)
+		goto out;
+	rc = derives(RL_SETATTR_INODE, iattrprov, iprov, NULL, 0);
+out:
+	queue_save_provenance(iprov, dentry);
+	spin_unlock(prov_lock(iprov));
+	spin_unlock_irqrestore(prov_lock(cprov), irqflags);
+	free_provenance(iattrprov);
+	return rc;
+}
+
+/*
+ * Check permission before obtaining file attributes.
+ * @path contains the path structure for the file.
+ * Return 0 if permission is granted.
+ */
+static int provenance_inode_getattr(const struct path *path)
+{
+	struct provenance *cprov = get_current_provenance();
+	struct provenance *iprov = dentry_provenance(path->dentry, true);
+	unsigned long irqflags;
+	int rc;
+
+	if (!iprov)
+		return -ENOMEM;
+
+	spin_lock_irqsave_nested(prov_lock(cprov), irqflags, PROVENANCE_LOCK_TASK);
+	spin_lock_nested(prov_lock(iprov), PROVENANCE_LOCK_INODE);
+	rc = uses(RL_GETATTR, iprov, cprov, NULL, 0);
+	spin_unlock(prov_lock(iprov));
+	spin_unlock_irqrestore(prov_lock(cprov), irqflags);
+	return rc;
+}
+
+/*
+ * Check the permission to read the symbolic link.
+ * @dentry contains the dentry structure for the file link.
+ * Return 0 if permission is granted.
+ */
+static int provenance_inode_readlink(struct dentry *dentry)
+{
+	struct provenance *cprov = get_current_provenance();
+	struct provenance *iprov = dentry_provenance(dentry, true);
+	unsigned long irqflags;
+	int rc;
+
+	if (!iprov)
+		return -ENOMEM;
+
+	spin_lock_irqsave_nested(prov_lock(cprov), irqflags, PROVENANCE_LOCK_TASK);
+	spin_lock_nested(prov_lock(iprov), PROVENANCE_LOCK_INODE);
+	rc = uses(RL_READLINK, iprov, cprov, NULL, 0);
+	spin_unlock(prov_lock(iprov));
+	spin_unlock_irqrestore(prov_lock(cprov), irqflags);
+	return rc;
+}
+
+static int provenance_inode_setxattr(struct dentry *dentry,
+				     const char *name,
+				     const void *value,
+				     size_t size,
+				     int flags)
+{
+	struct provenance *prov;
+	union prov_elt *setting;
+
+	if (strcmp(name, XATTR_NAME_PROVENANCE) == 0) { // provenance xattr
+		if (size != sizeof(union prov_elt))
+			return -ENOMEM;
+		prov = dentry_provenance(dentry, true);
+		setting = (union prov_elt*)value;
+
+		if (provenance_is_tracked(setting))
+			set_tracked(prov_elt(prov));
+		else
+			clear_tracked(prov_elt(prov));
+
+		if (provenance_is_opaque(setting))
+			set_opaque(prov_elt(prov));
+		else
+			clear_opaque(prov_elt(prov));
+
+		if (provenance_does_propagate(setting))
+			set_propagate(prov_elt(prov));
+		else
+			clear_propagate(prov_elt(prov));
+
+		prov_bloom_merge(prov_taint(prov_elt(prov)), prov_taint(setting));
+	}
+	return 0;
+}
+
+/*
+ * Update inode security field after successful setxattr operation.
+ * @value identified by @name for @dentry.
+ */
+static void provenance_inode_post_setxattr(struct dentry *dentry,
+					   const char *name,
+					   const void *value,
+					   size_t size,
+					   int flags)
+{
+	struct provenance *cprov = get_current_provenance();
+	struct provenance *iprov = dentry_provenance(dentry, true);
+	unsigned long irqflags;
+
+	if (strcmp(name, XATTR_NAME_PROVENANCE) == 0)
+		return;
+
+	if (!iprov)
+		return;
+	spin_lock_irqsave_nested(prov_lock(cprov), irqflags, PROVENANCE_LOCK_TASK);
+	spin_lock_nested(prov_lock(iprov), PROVENANCE_LOCK_INODE);
+	if (provenance_is_opaque(prov_elt(cprov)) || provenance_is_opaque(prov_elt(iprov)))
+		goto out;
+	if (!provenance_is_tracked(prov_elt(cprov)) && !provenance_is_tracked(prov_elt(iprov)))
+		goto out;
+	record_write_xattr(RL_SETXATTR, iprov, cprov, name, value, size, flags);
+out:
+	queue_save_provenance(iprov, dentry);
+	spin_unlock(prov_lock(iprov));
+	spin_unlock_irqrestore(prov_lock(cprov), irqflags);
+}
+
+/*
+ * Check permission before obtaining the extended attributes
+ * identified by @name for @dentry.
+ * Return 0 if permission is granted.
+ */
+static int provenance_inode_getxattr(struct dentry *dentry, const char *name)
+{
+	struct provenance *cprov = get_current_provenance();
+	struct provenance *iprov = dentry_provenance(dentry, true);
+	int rc = 0;
+	unsigned long irqflags;
+
+	if (strcmp(name, XATTR_NAME_PROVENANCE) == 0)
+		return 0;
+
+	if (!iprov)
+		return -ENOMEM;
+	spin_lock_irqsave_nested(prov_lock(cprov), irqflags, PROVENANCE_LOCK_TASK);
+	spin_lock_nested(prov_lock(iprov), PROVENANCE_LOCK_INODE);
+	if (provenance_is_opaque(prov_elt(cprov)) || provenance_is_opaque(prov_elt(iprov)))
+		goto out;
+	if (!provenance_is_tracked(prov_elt(cprov)) && !provenance_is_tracked(prov_elt(iprov)))
+		goto out;
+	rc = record_read_xattr(cprov, iprov, name);
+out:
+	spin_unlock(prov_lock(iprov));
+	spin_unlock_irqrestore(prov_lock(cprov), irqflags);
+	return rc;
+}
+
+/*
+ * Check permission before obtaining the list of extended attribute
+ * names for @dentry.
+ * Return 0 if permission is granted.
+ */
+static int provenance_inode_listxattr(struct dentry *dentry)
+{
+	struct provenance *cprov = get_current_provenance();
+	struct provenance *iprov = dentry_provenance(dentry, true);
+	unsigned long irqflags;
+	int rc;
+
+	if (!iprov)
+		return -ENOMEM;
+	spin_lock_irqsave_nested(prov_lock(cprov), irqflags, PROVENANCE_LOCK_TASK);
+	spin_lock_nested(prov_lock(iprov), PROVENANCE_LOCK_INODE);
+	rc = uses(RL_LSTXATTR, iprov, cprov, NULL, 0);
+	spin_unlock(prov_lock(iprov));
+	spin_unlock_irqrestore(prov_lock(cprov), irqflags);
+	return rc;
+}
+
+/*
+ * Check permission before removing the extended attribute
+ * identified by @name for @dentry.
+ * Return 0 if permission is granted.
+ */
+static int provenance_inode_removexattr(struct dentry *dentry, const char *name)
+{
+	struct provenance *cprov = get_current_provenance();
+	struct provenance *iprov = dentry_provenance(dentry, true);
+	unsigned long irqflags;
+	int rc = 0;
+
+	if (strcmp(name, XATTR_NAME_PROVENANCE) == 0)
+		return -EPERM;
+
+	if (!iprov)
+		return -ENOMEM;
+
+	spin_lock_irqsave_nested(prov_lock(cprov), irqflags, PROVENANCE_LOCK_TASK);
+	spin_lock_nested(prov_lock(iprov), PROVENANCE_LOCK_INODE);
+	if (provenance_is_opaque(prov_elt(cprov)) || provenance_is_opaque(prov_elt(iprov)))
+		goto out;
+	if (!provenance_is_tracked(prov_elt(cprov)) && !provenance_is_tracked(prov_elt(iprov)))
+		goto out;
+	rc = record_write_xattr(RL_RMVXATTR, iprov, cprov, name, NULL, 0, 0);
+out:
+	queue_save_provenance(iprov, dentry);
+	spin_unlock(prov_lock(iprov));
+	spin_unlock_irqrestore(prov_lock(cprov), irqflags);
+	return rc;
+}
+
+static int provenance_inode_getsecurity(struct inode *inode,
+					const char *name,
+					void **buffer,
+					bool alloc)
+{
+	struct provenance *iprov = inode_provenance(inode, true);
+
+	if (unlikely(!iprov))
+		return -ENOMEM;
+	if (strcmp(name, XATTR_PROVENANCE_SUFFIX))
+		return -EOPNOTSUPP;
+	if (!alloc)
+		goto out;
+	*buffer = kmalloc(sizeof(union prov_elt), GFP_KERNEL);
+	memcpy(*buffer, prov_elt(iprov), sizeof(union prov_elt));
+out:
+	return sizeof(union prov_elt);
+}
+
+static int provenance_inode_listsecurity(struct inode *inode,
+					 char *buffer,
+					 size_t buffer_size)
+{
+	const int len = sizeof(XATTR_NAME_PROVENANCE);
+
+	if (buffer && len <= buffer_size)
+		memcpy(buffer, XATTR_NAME_PROVENANCE, len);
+	return len;
+}
+
+/*
+ * Check file permissions before accessing an open file.  This hook is
+ * called by various operations that read or write files.  A security
+ * module can use this hook to perform additional checking on these
+ * operations, e.g.  to revalidate permissions on use to support privilege
+ * bracketing or policy changes.  Notice that this hook is used when the
+ * actual read/write operations are performed, whereas the
+ * inode_security_ops hook is called when a file is opened (as well as
+ * many other operations).
+ * Caveat:  Although this hook can be used to revalidate permissions for
+ * various system call operations that read or write files, it does not
+ * address the revalidation of permissions for memory-mapped files.
+ * Security modules must handle this separately if they need such
+ * revalidation.
+ * @file contains the file structure being accessed.
+ * @mask contains the requested permissions.
+ * Return 0 if permission is granted.
+ */
+static int provenance_file_permission(struct file *file, int mask)
+{
+	struct provenance *cprov = get_current_provenance();
+	struct provenance *iprov = file_provenance(file, true);
+	struct inode *inode = file_inode(file);
+	uint32_t perms;
+	unsigned long irqflags;
+	int rc = 0;
+
+	if (!iprov)
+		return -ENOMEM;
+	perms = file_mask_to_perms(inode->i_mode, mask);
+	spin_lock_irqsave_nested(prov_lock(cprov), irqflags, PROVENANCE_LOCK_TASK);
+	spin_lock_nested(prov_lock(iprov), PROVENANCE_LOCK_INODE);
+	if (is_inode_dir(inode)) {
+		if ((perms & (DIR__WRITE)) != 0)
+			rc = generates(RL_WRITE, cprov, iprov, file, mask);
+		if (rc < 0)
+			goto out;
+		if ((perms & (DIR__READ)) != 0)
+			rc = uses(RL_READ, iprov, cprov, file, mask);
+		if (rc < 0)
+			goto out;
+		if ((perms & (DIR__SEARCH)) != 0)
+			rc = uses(RL_SEARCH, iprov, cprov, file, mask);
+	} else if (is_inode_socket(inode)) {
+		if ((perms & (FILE__WRITE | FILE__APPEND)) != 0)
+			rc = generates(RL_SND, cprov, iprov, file, mask);
+		if (rc < 0)
+			goto out;
+		if ((perms & (FILE__READ)) != 0)
+			rc = uses(RL_RCV, iprov, cprov, file, mask);
+	} else{
+		if ((perms & (FILE__WRITE | FILE__APPEND)) != 0)
+			rc = generates(RL_WRITE, cprov, iprov, file, mask);
+		if (rc < 0)
+			goto out;
+		if ((perms & (FILE__READ)) != 0)
+			rc = uses(RL_READ, iprov, cprov, file, mask);
+		if (rc < 0)
+			goto out;
+		if ((perms & (FILE__EXECUTE)) != 0) {
+			if (provenance_is_opaque(prov_elt(iprov)))
+				set_opaque(prov_elt(cprov));
+			else
+				rc = uses(RL_EXEC, iprov, cprov, file, mask);
+		}
+	}
+out:
+	queue_save_provenance(iprov, file_dentry(file));
+	spin_unlock(prov_lock(iprov));
+	spin_unlock_irqrestore(prov_lock(cprov), irqflags);
+	return rc;
+}
+
+/*
+ * Save open-time permission checking state for later use upon
+ * file_permission, and recheck access if anything has changed
+ * since inode_permission.
+ */
+static int provenance_file_open(struct file *file, const struct cred *cred)
+{
+	struct provenance *cprov = get_current_provenance();
+	struct provenance *iprov = file_provenance(file, true);
+	unsigned long irqflags;
+	int rc;
+
+	if (!iprov)
+		return -ENOMEM;
+	spin_lock_irqsave_nested(prov_lock(cprov), irqflags, PROVENANCE_LOCK_TASK);
+	spin_lock_nested(prov_lock(iprov), PROVENANCE_LOCK_INODE);
+	rc = uses(RL_OPEN, iprov, cprov, file, 0);
+	spin_unlock(prov_lock(iprov));
+	spin_unlock_irqrestore(prov_lock(cprov), irqflags);
+	return rc;
+}
+
+/*
+ * Check permissions for a mmap operation.  The @file may be NULL, e.g.
+ * if mapping anonymous memory.
+ * @file contains the file structure for file to map (may be NULL).
+ * @reqprot contains the protection requested by the application.
+ * @prot contains the protection that will be applied by the kernel.
+ * @flags contains the operational flags.
+ * Return 0 if permission is granted.
+ */
+static int provenance_mmap_file(struct file *file,
+				unsigned long reqprot,
+				unsigned long prot,
+				unsigned long flags)
+{
+	struct provenance *cprov = get_current_provenance();
+	struct provenance *iprov = NULL;
+	struct provenance *bprov = NULL;
+	unsigned long irqflags;
+	int rc = 0;
+
+	if (unlikely(!file))
+		return 0;
+	iprov = file_provenance(file, true);
+	if (!iprov)
+		return -ENOMEM;
+	spin_lock_irqsave_nested(prov_lock(cprov), irqflags, PROVENANCE_LOCK_TASK);
+	spin_lock_nested(prov_lock(iprov), PROVENANCE_LOCK_INODE);
+	if (rc < 0)
+		goto out;
+	if ((flags & MAP_TYPE) == MAP_SHARED) {
+		cprov->has_mmap = true;
+		if ((prot & (PROT_WRITE)) != 0)
+			rc = generates(RL_MMAP_WRITE, cprov, iprov, file, flags);
+		if (rc < 0)
+			goto out;
+		if ((prot & (PROT_READ)) != 0)
+			rc = uses(RL_MMAP_READ, iprov, cprov, file, flags);
+		if (rc < 0)
+			goto out;
+		if ((prot & (PROT_EXEC)) != 0)
+			rc = uses(RL_MMAP_EXEC, iprov, cprov, file, flags);
+	} else{
+		bprov = branch_mmap(iprov, cprov);
+		if (!bprov)
+			goto out;
+		rc = derives(RL_MMAP, iprov, bprov, file, flags);
+		if (rc < 0)
+			goto out;
+		if ((prot & (PROT_WRITE)) != 0)
+			rc = generates(RL_MMAP_WRITE, cprov, bprov, file, flags);
+		if (rc < 0)
+			goto out;
+		if ((prot & (PROT_READ)) != 0)
+			rc = uses(RL_MMAP_READ, bprov, cprov, file, flags);
+		if (rc < 0)
+			goto out;
+		if ((prot & (PROT_EXEC)) != 0)
+			rc = uses(RL_MMAP_EXEC, bprov, cprov, file, flags);
+	}
+out:
+	spin_unlock(prov_lock(iprov));
+	spin_unlock_irqrestore(prov_lock(cprov), irqflags);
+	if (bprov) {
+		close_inode(bprov);
+		free_provenance(bprov);
+	}
+	return rc;
+}
+
+#ifdef CONFIG_SECURITY_FLOW_FRIENDLY
+static void provenance_mmap_munmap(struct mm_struct *mm,
+				struct vm_area_struct *vma,
+			  unsigned long start,
+				unsigned long end) {
+	struct provenance *cprov = get_current_provenance();
+	struct provenance *iprov = NULL;
+	struct file *mmapf;
+	unsigned long irqflags;
+	vm_flags_t flags = vma->vm_flags;
+
+	// it is a shared mmap
+	if ( vm_mayshare(flags) ) {
+		mmapf = vma->vm_file;
+		if (mmapf) {
+			iprov = file_provenance(mmapf, false);
+			spin_lock_irqsave_nested(prov_lock(cprov), irqflags, PROVENANCE_LOCK_TASK);
+			spin_lock_nested(prov_lock(iprov), PROVENANCE_LOCK_INODE);
+			generates(RL_MUNMAP, cprov, iprov, mmapf, flags);
+			spin_unlock(prov_lock(iprov));
+			spin_unlock_irqrestore(prov_lock(cprov), irqflags);
+		}
+	}
+}
+#endif
+
+/*
+ * @file contains the file structure.
+ * @cmd contains the operation to perform.
+ * @arg contains the operational arguments.
+ * Check permission for an ioctl operation on @file.  Note that @arg
+ * sometimes represents a user space pointer; in other cases, it may be a
+ * simple integer value.  When @arg represents a user space pointer, it
+ * should never be used by the security module.
+ * Return 0 if permission is granted.
+ */
+static int provenance_file_ioctl(struct file *file,
+				 unsigned int cmd,
+				 unsigned long arg)
+{
+	struct provenance *cprov = get_current_provenance();
+	struct provenance *iprov = file_provenance(file, true);
+	unsigned long irqflags;
+	int rc;
+
+	if (!iprov)
+		return -ENOMEM;
+	spin_lock_irqsave_nested(prov_lock(cprov), irqflags, PROVENANCE_LOCK_TASK);
+	spin_lock_nested(prov_lock(iprov), PROVENANCE_LOCK_INODE);
+	rc = generates(RL_WRITE, cprov, iprov, NULL, 0);
+	if (rc < 0)
+		goto out;
+	rc = uses(RL_READ, iprov, cprov, NULL, 0);
+out:
+	queue_save_provenance(iprov, file_dentry(file));
+	spin_unlock(prov_lock(iprov));
+	spin_unlock_irqrestore(prov_lock(cprov), irqflags);
+	return rc;
+}
+
+/* msg */
+
+/*
+ * Allocate and attach a security structure to the msg->security field.
+ * The security field is initialized to NULL when the structure is first
+ * created.
+ * @msg contains the message structure to be modified.
+ * Return 0 if operation was successful and permission is granted.
+ */
+static int provenance_msg_msg_alloc_security(struct msg_msg *msg)
+{
+	struct provenance *cprov = get_current_provenance();
+	struct provenance *mprov;
+	unsigned long irqflags;
+	int rc;
+
+	/* alloc new prov struct with generated id */
+	mprov = alloc_provenance(ENT_MSG, GFP_KERNEL);
+
+	if (!mprov)
+		return -ENOMEM;
+	prov_elt(mprov)->msg_msg_info.type = msg->m_type;
+	msg->provenance = mprov;
+	spin_lock_irqsave_nested(prov_lock(cprov), irqflags, PROVENANCE_LOCK_TASK);
+	rc = generates(RL_CREATE, cprov, mprov, NULL, 0);
+	spin_unlock_irqrestore(prov_lock(cprov), irqflags);
+	return rc;
+}
+
+/*
+ * Deallocate the security structure for this message.
+ * @msg contains the message structure to be modified.
+ */
+static void provenance_msg_msg_free_security(struct msg_msg *msg)
+{
+	if (msg->provenance)
+		free_provenance(msg->provenance);
+	msg->provenance = NULL;
+}
+
+
+static inline int __mq_msgsnd(struct msg_msg *msg)
+{
+	struct provenance *cprov = get_current_provenance();
+	struct provenance *mprov = msg->provenance;
+	unsigned long irqflags;
+	int rc;
+
+	spin_lock_irqsave_nested(prov_lock(cprov), irqflags, PROVENANCE_LOCK_TASK);
+	spin_lock_nested(prov_lock(mprov), PROVENANCE_LOCK_MSG);
+	rc = generates(RL_CREATE, cprov, mprov, NULL, 0);
+	spin_unlock(prov_lock(mprov));
+	spin_unlock_irqrestore(prov_lock(cprov), irqflags);
+	return rc;
+}
+
+/*
+ * Check permission before a message, @msg, is enqueued on the message
+ * queue, @msq.
+ * @msq contains the message queue to send message to.
+ * @msg contains the message to be enqueued.
+ * @msqflg contains operational flags.
+ * Return 0 if permission is granted.
+ */
+static int provenance_msg_queue_msgsnd(struct msg_queue *msq,
+				       struct msg_msg *msg,
+				       int msqflg)
+{
+	return __mq_msgsnd(msg);
+}
+
+#ifdef CONFIG_SECURITY_FLOW_FRIENDLY
+static int provenance_mq_timedsend(struct inode *inode, struct msg_msg *msg,
+				   struct timespec *ts)
+{
+	return __mq_msgsnd(msg);
+}
+#endif
+
+static inline int __mq_msgrcv(struct provenance *cprov, struct msg_msg *msg)
+{
+	struct provenance *mprov = msg->provenance;
+	unsigned long irqflags;
+	int rc;
+
+	spin_lock_irqsave_nested(prov_lock(cprov), irqflags, PROVENANCE_LOCK_TASK);
+	spin_lock_nested(prov_lock(mprov), PROVENANCE_LOCK_MSG);
+	rc = uses(RL_READ, mprov, cprov, NULL, 0);
+	spin_unlock(prov_lock(mprov));
+	spin_unlock_irqrestore(prov_lock(cprov), irqflags);
+	return rc;
+}
+
+/*
+ * Check permission before a message, @msg, is removed from the message
+ * queue, @msq.  The @target task structure contains a pointer to the
+ * process that will be receiving the message (not equal to the current
+ * process when inline receives are being performed).
+ * @msq contains the message queue to retrieve message from.
+ * @msg contains the message destination.
+ * @target contains the task structure for recipient process.
+ * @type contains the type of message requested.
+ * @mode contains the operational flags.
+ * Return 0 if permission is granted.
+ */
+static int provenance_msg_queue_msgrcv(struct msg_queue *msq,
+				       struct msg_msg *msg,
+				       struct task_struct *target,
+				       long type,
+				       int mode)
+{
+	struct provenance *cprov = target->cred->provenance;
+
+	return __mq_msgrcv(cprov, msg);
+}
+
+#ifdef CONFIG_SECURITY_FLOW_FRIENDLY
+static int provenance_mq_timedreceive(struct inode *inode, struct msg_msg *msg,
+				      struct timespec *ts)
+{
+	struct provenance *cprov = get_current_provenance();
+
+	return __mq_msgrcv(cprov, msg);
+}
+#endif
+
+/*
+ * Allocate and attach a security structure to the shp->shm_perm.security
+ * field.  The security field is initialized to NULL when the structure is
+ * first created.
+ * @shp contains the shared memory structure to be modified.
+ * Return 0 if operation was successful and permission is granted.
+ */
+static int provenance_shm_alloc_security(struct shmid_kernel *shp)
+{
+	struct provenance *cprov = get_current_provenance();
+	struct provenance *sprov = alloc_provenance(ENT_SHM, GFP_KERNEL);
+	unsigned long irqflags;
+	int rc;
+
+	if (!sprov)
+		return -ENOMEM;
+	prov_elt(sprov)->shm_info.mode = shp->shm_perm.mode;
+	shp->shm_perm.provenance = sprov;
+	spin_lock_irqsave_nested(prov_lock(cprov), irqflags, PROVENANCE_LOCK_TASK);
+	rc = uses(RL_READ, sprov, cprov, NULL, 0);
+	if (rc < 0)
+		goto out;
+	rc = generates(RL_WRITE, cprov, sprov, NULL, 0);
+out:
+	spin_unlock_irqrestore(prov_lock(cprov), irqflags);
+	return 0;
+}
+
+/*
+ * Deallocate the security struct for this memory segment.
+ * @shp contains the shared memory structure to be modified.
+ */
+static void provenance_shm_free_security(struct shmid_kernel *shp)
+{
+	if (shp->shm_perm.provenance)
+		free_provenance(shp->shm_perm.provenance);
+	shp->shm_perm.provenance = NULL;
+}
+
+/*
+ * Check permissions prior to allowing the shmat system call to attach the
+ * shared memory segment @shp to the data segment of the calling process.
+ * The attaching address is specified by @shmaddr.
+ * @shp contains the shared memory structure to be modified.
+ * @shmaddr contains the address to attach memory region to.
+ * @shmflg contains the operational flags.
+ * Return 0 if permission is granted.
+ */
+static int provenance_shm_shmat(struct shmid_kernel *shp, char __user *shmaddr, int shmflg)
+{
+	struct provenance *cprov = get_current_provenance();
+	struct provenance *sprov = shp->shm_perm.provenance;
+	unsigned long irqflags;
+	int rc = 0;
+
+	if (!sprov)
+		return -ENOMEM;
+	spin_lock_irqsave_nested(prov_lock(cprov), irqflags, PROVENANCE_LOCK_TASK);
+	spin_lock_nested(prov_lock(sprov), PROVENANCE_LOCK_SHM);
+	if (shmflg & SHM_RDONLY)
+		rc = uses(RL_READ, sprov, cprov, NULL, shmflg);
+	else {
+		rc = uses(RL_READ, sprov, cprov, NULL, shmflg);
+		if (rc < 0)
+			goto out;
+		rc = generates(RL_WRITE, cprov, sprov, NULL, shmflg);
+	}
+out:
+	spin_unlock(prov_lock(sprov));
+	spin_unlock_irqrestore(prov_lock(cprov), irqflags);
+	return rc;
+}
+
+/*
+ * Allocate and attach a security structure to the sk->sk_security field,
+ * which is used to copy security attributes between local stream sockets.
+ */
+static int provenance_sk_alloc_security(struct sock *sk,
+					int family,
+					gfp_t priority)
+{
+	struct provenance *skprov = get_current_provenance();
+
+	if (!skprov)
+		return -ENOMEM;
+	sk->sk_provenance = skprov;
+	return 0;
+}
+
+/*
+ * This hook allows a module to update or allocate a per-socket security
+ * structure. Note that the security field was not added directly to the
+ * socket structure, but rather, the socket security information is stored
+ * in the associated inode.  Typically, the inode alloc_security hook will
+ * allocate and and attach security information to
+ * sock->inode->i_security.  This hook may be used to update the
+ * sock->inode->i_security field with additional information that wasn't
+ * available when the inode was allocated.
+ * @sock contains the newly created socket structure.
+ * @family contains the requested protocol family.
+ * @type contains the requested communications type.
+ * @protocol contains the requested protocol.
+ * @kern set to 1 if a kernel socket.
+ */
+static int provenance_socket_post_create(struct socket *sock,
+					 int family,
+					 int type,
+					 int protocol,
+					 int kern)
+{
+	struct provenance *cprov  = get_current_provenance();
+	struct provenance *iprov = socket_inode_provenance(sock);
+	unsigned long irqflags;
+	int rc;
+
+	if (kern)
+		return 0;
+	spin_lock_irqsave_nested(prov_lock(cprov), irqflags, PROVENANCE_LOCK_TASK);
+	spin_lock_nested(prov_lock(iprov), PROVENANCE_LOCK_INODE);
+	rc = generates(RL_CREATE, cprov, iprov, NULL, 0);
+	spin_unlock(prov_lock(iprov));
+	spin_unlock_irqrestore(prov_lock(cprov), irqflags);
+	return rc;
+}
+
+/*
+ * Check permission before socket protocol layer bind operation is
+ * performed and the socket @sock is bound to the address specified in the
+ * @address parameter.
+ * @sock contains the socket structure.
+ * @address contains the address to bind to.
+ * @addrlen contains the length of address.
+ * Return 0 if permission is granted.
+ */
+static int provenance_socket_bind(struct socket *sock,
+				  struct sockaddr *address,
+				  int addrlen)
+{
+	struct provenance *cprov  = get_current_provenance();
+	struct provenance *iprov = socket_inode_provenance(sock);
+	struct sockaddr_in *ipv4_addr;
+	uint8_t op;
+	int rc;
+
+	if (!iprov)
+		return -ENOMEM;
+
+	if (provenance_is_opaque(prov_elt(cprov)))
+		return 0;
+
+	/* should we start tracking this socket */
+	if (address->sa_family == PF_INET) {
+		if (addrlen < sizeof(struct sockaddr_in))
+			return -EINVAL;
+		ipv4_addr = (struct sockaddr_in*)address;
+		op = prov_ipv4_ingressOP(ipv4_addr->sin_addr.s_addr, ipv4_addr->sin_port);
+		if ((op & PROV_SET_TRACKED) != 0) {
+			set_tracked(prov_elt(iprov));
+			set_tracked(prov_elt(cprov));
+		}
+		if ((op & PROV_SET_PROPAGATE) != 0) {
+			set_propagate(prov_elt(iprov));
+			set_propagate(prov_elt(cprov));
+		}
+		if ((op & PROV_SET_RECORD) != 0)
+			set_record_packet(prov_elt(iprov));
+	}
+	rc = provenance_record_address(address, addrlen, iprov);
+	if (rc < 0)
+		return rc;
+	rc = generates(RL_BIND, cprov, iprov, NULL, 0);
+	return rc;
+}
+
+/*
+ * Check permission before socket protocol layer connect operation
+ * attempts to connect socket @sock to a remote address, @address.
+ * @sock contains the socket structure.
+ * @address contains the address of remote endpoint.
+ * @addrlen contains the length of address.
+ * Return 0 if permission is granted.
+ */
+static int provenance_socket_connect(struct socket *sock,
+				     struct sockaddr *address,
+				     int addrlen)
+{
+	struct provenance *cprov  = get_current_provenance();
+	struct provenance *iprov = socket_inode_provenance(sock);
+	struct sockaddr_in *ipv4_addr;
+	unsigned long irqflags;
+	uint8_t op;
+	int rc = 0;
+
+	if (!iprov)
+		return -ENOMEM;
+
+	spin_lock_irqsave_nested(prov_lock(cprov), irqflags, PROVENANCE_LOCK_TASK);
+	spin_lock_nested(prov_lock(iprov), PROVENANCE_LOCK_INODE);
+	if (provenance_is_opaque(prov_elt(cprov)))
+		goto out;
+
+	/* should we start tracking this socket */
+	if (address->sa_family == PF_INET) {
+		if (addrlen < sizeof(struct sockaddr_in)) {
+			rc = -EINVAL;
+			goto out;
+		}
+		ipv4_addr = (struct sockaddr_in*)address;
+		op = prov_ipv4_egressOP(ipv4_addr->sin_addr.s_addr, ipv4_addr->sin_port);
+		if ((op & PROV_SET_TRACKED) != 0) {
+			set_tracked(prov_elt(iprov));
+			set_tracked(prov_elt(cprov));
+		}
+		if ((op & PROV_SET_PROPAGATE) != 0) {
+			set_propagate(prov_elt(iprov));
+			set_propagate(prov_elt(cprov));
+		}
+		if ((op & PROV_SET_RECORD) != 0)
+			set_record_packet(prov_elt(iprov));
+	}
+	rc = provenance_record_address(address, addrlen, iprov);
+	if (rc < 0)
+		return rc;
+	rc = generates(RL_CONNECT, cprov, iprov, NULL, 0);
+out:
+	spin_unlock(prov_lock(iprov));
+	spin_unlock_irqrestore(prov_lock(cprov), irqflags);
+	return rc;
+}
+
+/*
+ * Check permission before socket protocol layer listen operation.
+ * @sock contains the socket structure.
+ * @backlog contains the maximum length for the pending connection queue.
+ * Return 0 if permission is granted.
+ */
+static int provenance_socket_listen(struct socket *sock, int backlog)
+{
+	struct provenance *cprov  = get_current_provenance();
+	struct provenance *iprov = socket_inode_provenance(sock);
+	unsigned long irqflags;
+	int rc;
+
+	if (!iprov)
+		return -ENOMEM;
+	spin_lock_irqsave_nested(prov_lock(cprov), irqflags, PROVENANCE_LOCK_TASK);
+	spin_lock_nested(prov_lock(iprov), PROVENANCE_LOCK_INODE);
+	rc = generates(RL_LISTEN, cprov, iprov, NULL, 0);
+	spin_unlock(prov_lock(iprov));
+	spin_unlock_irqrestore(prov_lock(cprov), irqflags);
+	return rc;
+}
+
+/*
+ * Check permission before accepting a new connection.  Note that the new
+ * socket, @newsock, has been created and some information copied to it,
+ * but the accept operation has not actually been performed.
+ * @sock contains the listening socket structure.
+ * @newsock contains the newly created server socket for connection.
+ * Return 0 if permission is granted.
+ */
+static int provenance_socket_accept(struct socket *sock, struct socket *newsock)
+{
+	struct provenance *cprov  = get_current_provenance();
+	struct provenance *iprov = socket_inode_provenance(sock);
+	struct provenance *niprov = socket_inode_provenance(newsock);
+	unsigned long irqflags;
+	int rc;
+
+	spin_lock_irqsave_nested(prov_lock(cprov), irqflags, PROVENANCE_LOCK_TASK);
+	spin_lock_nested(prov_lock(iprov), PROVENANCE_LOCK_INODE);
+	rc = derives(RL_ACCEPT_SOCKET, iprov, niprov, NULL, 0);
+	if (rc < 0)
+		goto out;
+	rc = uses(RL_ACCEPT, niprov, cprov, NULL, 0);
+out:
+	spin_unlock(prov_lock(iprov));
+	spin_unlock_irqrestore(prov_lock(cprov), irqflags);
+	return rc;
+}
+
+/*
+ * Check permission before transmitting a message to another socket.
+ * @sock contains the socket structure.
+ * @msg contains the message to be transmitted.
+ * @size contains the size of message.
+ * Return 0 if permission is granted.
+ */
+#ifdef CONFIG_SECURITY_FLOW_FRIENDLY
+static int provenance_socket_sendmsg_always(struct socket *sock,
+					    struct msghdr *msg,
+					    int size)
+#else /* CONFIG_SECURITY_FLOW_FRIENDLY */
+static int provenance_socket_sendmsg(struct socket *sock,
+				     struct msghdr *msg,
+				     int size)
+#endif /* CONFIG_SECURITY_FLOW_FRIENDLY */
+{
+	struct provenance *cprov = get_current_provenance();
+	struct provenance *iprov = socket_inode_provenance(sock);
+	struct provenance *pprov = NULL;
+	struct sock *peer = NULL;
+	unsigned long irqflags;
+	int rc;
+
+	if (!iprov)
+		return -ENOMEM;
+	if (sock->sk->sk_family == PF_UNIX &&
+	    sock->sk->sk_type != SOCK_DGRAM) {             // datagran handled by unix_may_send
+		peer = unix_peer_get(sock->sk);
+		if (peer) {
+			pprov = sk_provenance(peer);
+			if (pprov == cprov)
+				pprov = NULL;
+		}
+	}
+	spin_lock_irqsave_nested(prov_lock(cprov), irqflags, PROVENANCE_LOCK_TASK);
+	spin_lock_nested(prov_lock(iprov), PROVENANCE_LOCK_INODE);
+	rc = generates(RL_SND, cprov, iprov, NULL, 0);
+	if (pprov)
+		rc = uses(RL_RCV_UNIX, iprov, pprov, NULL, 0);
+	spin_unlock(prov_lock(iprov));
+	spin_unlock_irqrestore(prov_lock(cprov), irqflags);
+	if (peer)
+		sock_put(peer);
+	return rc;
+}
+
+/*
+ * Check permission before receiving a message from a socket.
+ * @sock contains the socket structure.
+ * @msg contains the message structure.
+ * @size contains the size of message structure.
+ * @flags contains the operational flags.
+ * Return 0 if permission is granted.
+ */
+#ifdef CONFIG_SECURITY_FLOW_FRIENDLY
+static int provenance_socket_recvmsg_always(struct socket *sock,
+					    struct msghdr *msg,
+					    int size,
+					    int flags)
+#else /* CONFIG_SECURITY_FLOW_FRIENDLY */
+static int provenance_socket_recvmsg(struct socket *sock,
+				     struct msghdr *msg,
+				     int size,
+				     int flags)
+#endif /* CONFIG_SECURITY_FLOW_FRIENDLY */
+{
+	struct provenance *cprov = get_current_provenance();
+	struct provenance *iprov = socket_inode_provenance(sock);
+	struct provenance *pprov = NULL;
+	struct sock *peer = NULL;
+	unsigned long irqflags;
+	int rc;
+
+	if (!iprov)
+		return -ENOMEM;
+	if (sock->sk->sk_family == PF_UNIX &&
+	    sock->sk->sk_type != SOCK_DGRAM) {             // datagran handled by unix_may_send
+		peer = unix_peer_get(sock->sk);
+		if (peer) {
+			pprov = sk_provenance(peer);
+			if (pprov == cprov)
+				pprov = NULL;
+		}
+	}
+	spin_lock_irqsave_nested(prov_lock(cprov), irqflags, PROVENANCE_LOCK_TASK);
+	spin_lock_nested(prov_lock(iprov), PROVENANCE_LOCK_INODE);
+	if (pprov)
+		rc = generates(RL_SND_UNIX, pprov, iprov, NULL, flags);
+	rc = uses(RL_RCV, iprov, cprov, NULL, flags);
+	spin_unlock(prov_lock(iprov));
+	spin_unlock_irqrestore(prov_lock(cprov), irqflags);
+	if (peer)
+		sock_put(peer);
+	return rc;
+}
+
+/*
+ * Check permissions on incoming network packets.  This hook is distinct
+ * from Netfilter's IP input hooks since it is the first time that the
+ * incoming sk_buff @skb has been associated with a particular socket, @sk.
+ * Must not sleep inside this hook because some callers hold spinlocks.
+ * @sk contains the sock (not socket) associated with the incoming sk_buff.
+ * @skb contains the incoming network data.
+ */
+static int provenance_socket_sock_rcv_skb(struct sock *sk, struct sk_buff *skb)
+{
+	struct provenance *cprov = sk_provenance(sk);
+	struct provenance *iprov;
+	union prov_elt pckprov;
+	uint16_t family = sk->sk_family;
+	unsigned long irqflags;
+	int rc = 0;
+
+	if (!cprov)
+		return 0;
+	if (family != PF_INET)
+		return 0;
+	iprov = sk_inode_provenance(sk);
+	if (!iprov)
+		return 0;
+	if (provenance_is_tracked(prov_elt(iprov)) ||
+	    provenance_is_tracked(prov_elt(cprov))) {
+		provenance_parse_skb_ipv4(skb, &pckprov);
+		spin_lock_irqsave_nested(prov_lock(cprov), irqflags, PROVENANCE_LOCK_TASK);
+		spin_lock_nested(prov_lock(iprov), PROVENANCE_LOCK_INODE);
+		rc = record_pck_to_inode(&pckprov, iprov);
+		if (rc < 0)
+			goto out;
+		if (provenance_is_tracked(prov_elt(cprov)))
+			rc = uses(RL_RCV, iprov, cprov, NULL, 0);
+		if (rc < 0)
+			goto out;
+		if (provenance_records_packet(prov_elt(iprov)))
+			rc = record_packet_content(&pckprov, skb);
+out:
+		spin_unlock(prov_lock(iprov));
+		spin_unlock_irqrestore(prov_lock(cprov), irqflags);
+	}
+	return rc;
+}
+
+/*
+ * Check permissions before establishing a Unix domain stream connection
+ * between @sock and @other.
+ * @sock contains the sock structure.
+ * @other contains the peer sock structure.
+ * @newsk contains the new sock structure.
+ * Return 0 if permission is granted.
+ */
+static int provenance_unix_stream_connect(struct sock *sock,
+					  struct sock *other,
+					  struct sock *newsk)
+{
+	struct provenance *cprov = get_current_provenance();
+	struct provenance *iprov = sk_inode_provenance(sock);
+	unsigned long irqflags;
+
+	spin_lock_irqsave_nested(prov_lock(cprov), irqflags, PROVENANCE_LOCK_TASK);
+	spin_lock_nested(prov_lock(iprov), PROVENANCE_LOCK_INODE);
+	generates(RL_CONNECT, cprov, iprov, NULL, 0);
+	spin_unlock(prov_lock(iprov));
+	spin_unlock_irqrestore(prov_lock(cprov), irqflags);
+	return 0;
+}
+
+/*
+ * Check permissions before connecting or sending datagrams from @sock to
+ * @other.
+ * @sock contains the socket structure.
+ * @other contains the peer socket structure.
+ * Return 0 if permission is granted.
+ */
+static int provenance_unix_may_send(struct socket *sock,
+				    struct socket *other)
+{
+	struct provenance *sprov = socket_provenance(sock);
+	struct provenance *oprov = socket_inode_provenance(other);
+	unsigned long irqflags;
+	int rc;
+
+	spin_lock_irqsave_nested(prov_lock(sprov), irqflags, PROVENANCE_LOCK_SOCKET);
+	spin_lock_nested(prov_lock(oprov), PROVENANCE_LOCK_SOCK);
+	rc = generates(RL_SND_UNIX, sprov, oprov, NULL, 0);
+	spin_unlock(prov_lock(oprov));
+	spin_unlock_irqrestore(prov_lock(sprov), irqflags);
+	return rc;
+}
+
+/* outdated description */
+/*
+ * Save security information in the bprm->security field, typically based
+ * on information about the bprm->file, for later use by the apply_creds
+ * hook.  This hook may also optionally check permissions (e.g. for
+ * transitions between security domains).
+ * This hook may be called multiple times during a single execve, e.g. for
+ * interpreters.  The hook can tell whether it has already been called by
+ * checking to see if @bprm->security is non-NULL.if so, then the hook
+ * may decide either to retain the security information saved earlier or
+ * to replace it.
+ * @bprm contains the linux_binprm structure.
+ * Return 0 if the hook is successful and permission is granted.
+ */
+static int provenance_bprm_set_creds(struct linux_binprm *bprm)
+{
+	struct provenance *nprov = bprm->cred->provenance;
+	struct provenance *iprov = file_provenance(bprm->file, true);
+	unsigned long irqflags;
+	int rc;
+
+	if (!nprov)
+		return -ENOMEM;
+
+	if (provenance_is_opaque(prov_elt(iprov))) {
+		set_opaque(prov_elt(nprov));
+		return 0;
+	}
+	spin_lock_irqsave_nested(prov_lock(iprov), irqflags, PROVENANCE_LOCK_INODE);
+	rc = uses(RL_EXEC, iprov, nprov, NULL, 0);
+	spin_unlock_irqrestore(prov_lock(iprov), irqflags);
+	return rc;
+}
+
+/*
+ *	This hook mediates the point when a search for a binary handler will
+ *	begin.  It allows a check the @bprm->security value which is set in the
+ *	preceding set_creds call.  The primary difference from set_creds is
+ *	that the argv list and envp list are reliably available in @bprm.  This
+ *	hook may be called multiple times during a single execve; and in each
+ *	pass set_creds is called first.
+ *	@bprm contains the linux_binprm structure.
+ *	Return 0 if the hook is successful and permission is granted.
+ */
+static int provenance_bprm_check(struct linux_binprm *bprm)
+{
+	struct provenance *nprov = bprm->cred->provenance;
+	struct provenance *iprov = file_provenance(bprm->file, true);
+
+	if (!nprov)
+		return -ENOMEM;
+
+	if (provenance_is_opaque(prov_elt(iprov))) {
+		set_opaque(prov_elt(nprov));
+		return 0;
+	}
+	return prov_record_args(nprov, bprm);
+}
+
+/*
+ * Prepare to install the new security attributes of a process being
+ * transformed by an execve operation, based on the old credentials
+ * pointed to by @current->cred and the information set in @bprm->cred by
+ * the bprm_set_creds hook.  @bprm points to the linux_binprm structure.
+ * This hook is a good place to perform state changes on the process such
+ * as closing open file descriptors to which access will no longer be
+ * granted when the attributes are changed.  This is called immediately
+ * before commit_creds().
+ */
+static void provenance_bprm_committing_creds(struct linux_binprm *bprm)
+{
+	struct provenance *cprov  = get_current_provenance();
+	struct provenance *nprov = bprm->cred->provenance;
+	struct provenance *iprov = file_provenance(bprm->file, true);
+	unsigned long irqflags;
+
+	if (provenance_is_opaque(prov_elt(iprov))) {
+		set_opaque(prov_elt(nprov));
+		return;
+	}
+	record_node_name(cprov, bprm->interp);
+	spin_lock_irqsave_nested(prov_lock(cprov), irqflags, PROVENANCE_LOCK_TASK);
+	spin_lock_nested(prov_lock(iprov), PROVENANCE_LOCK_INODE);
+	informs(RL_EXEC_PROCESS, cprov, nprov, NULL, 0);
+	uses(RL_EXEC, iprov, nprov, NULL, 0);
+	spin_unlock(prov_lock(iprov));
+	spin_unlock_irqrestore(prov_lock(cprov), irqflags);
+}
+
+/*
+ * Allocate and attach a security structure to the sb->s_security field.
+ * The s_security field is initialized to NULL when the structure is
+ * allocated.
+ * @sb contains the super_block structure to be modified.
+ * Return 0 if operation was successful.
+ */
+static int provenance_sb_alloc_security(struct super_block *sb)
+{
+	struct provenance *sbprov  = alloc_provenance(ENT_SBLCK, GFP_KERNEL);
+
+	if (!sbprov)
+		return -ENOMEM;
+	sb->s_provenance = sbprov;
+	return 0;
+}
+
+/*
+ * Deallocate and clear the sb->s_security field.
+ * @sb contains the super_block structure to be modified.
+ */
+static void provenance_sb_free_security(struct super_block *sb)
+{
+	if (sb->s_provenance)
+		free_provenance(sb->s_provenance);
+	sb->s_provenance = NULL;
+}
+
+static int provenance_sb_kern_mount(struct super_block *sb,
+				    int flags,
+				    void *data)
+{
+	int i;
+	uint8_t c = 0;
+	struct provenance *sbprov = sb->s_provenance;
+
+	for (i = 0; i < 16; i++) {
+		prov_elt(sbprov)->sb_info.uuid[i] = sb->s_uuid.b[i];
+		c |= sb->s_uuid.b[i];
+	}
+	if (c == 0) // no uuid defined, generate random one
+		get_random_bytes(prov_elt(sbprov)->sb_info.uuid, 16 * sizeof(uint8_t));
+	return 0;
+}
+
+static struct security_hook_list provenance_hooks[] __lsm_ro_after_init = {
+	/* task related hooks */
+	LSM_HOOK_INIT(cred_alloc_blank,	      provenance_cred_alloc_blank),
+	LSM_HOOK_INIT(cred_free,	      provenance_cred_free),
+	LSM_HOOK_INIT(cred_prepare,	      provenance_cred_prepare),
+	LSM_HOOK_INIT(cred_transfer,	      provenance_cred_transfer),
+	LSM_HOOK_INIT(task_fix_setuid,	      provenance_task_fix_setuid),
+
+	/* inode related hooks */
+	LSM_HOOK_INIT(inode_alloc_security,   provenance_inode_alloc_security),
+	LSM_HOOK_INIT(inode_create,	      provenance_inode_create),
+	LSM_HOOK_INIT(inode_free_security,    provenance_inode_free_security),
+	LSM_HOOK_INIT(inode_permission,	      provenance_inode_permission),
+	LSM_HOOK_INIT(inode_link,	      provenance_inode_link),
+	LSM_HOOK_INIT(inode_rename,	      provenance_inode_rename),
+	LSM_HOOK_INIT(inode_setattr,	      provenance_inode_setattr),
+	LSM_HOOK_INIT(inode_getattr,	      provenance_inode_getattr),
+	LSM_HOOK_INIT(inode_readlink,	      provenance_inode_readlink),
+	LSM_HOOK_INIT(inode_setxattr,	      provenance_inode_setxattr),
+	LSM_HOOK_INIT(inode_post_setxattr,    provenance_inode_post_setxattr),
+	LSM_HOOK_INIT(inode_getxattr,	      provenance_inode_getxattr),
+	LSM_HOOK_INIT(inode_listxattr,	      provenance_inode_listxattr),
+	LSM_HOOK_INIT(inode_removexattr,      provenance_inode_removexattr),
+	LSM_HOOK_INIT(inode_getsecurity,      provenance_inode_getsecurity),
+	LSM_HOOK_INIT(inode_listsecurity,     provenance_inode_listsecurity),
+
+	/* file related hooks */
+	LSM_HOOK_INIT(file_permission,	      provenance_file_permission),
+	LSM_HOOK_INIT(mmap_file,	      provenance_mmap_file),
+#ifdef CONFIG_SECURITY_FLOW_FRIENDLY
+	LSM_HOOK_INIT(mmap_munmap,	      provenance_mmap_munmap),
+#endif
+	LSM_HOOK_INIT(file_ioctl,	      provenance_file_ioctl),
+	LSM_HOOK_INIT(file_open,	      provenance_file_open),
+
+	/* msg related hooks */
+	LSM_HOOK_INIT(msg_msg_alloc_security, provenance_msg_msg_alloc_security),
+	LSM_HOOK_INIT(msg_msg_free_security,  provenance_msg_msg_free_security),
+	LSM_HOOK_INIT(msg_queue_msgsnd,	      provenance_msg_queue_msgsnd),
+	LSM_HOOK_INIT(msg_queue_msgrcv,	      provenance_msg_queue_msgrcv),
+
+	/* shared memory related hooks */
+	LSM_HOOK_INIT(shm_alloc_security,     provenance_shm_alloc_security),
+	LSM_HOOK_INIT(shm_free_security,      provenance_shm_free_security),
+	LSM_HOOK_INIT(shm_shmat,	      provenance_shm_shmat),
+
+	/* socket related hooks */
+	LSM_HOOK_INIT(sk_alloc_security,      provenance_sk_alloc_security),
+	LSM_HOOK_INIT(socket_post_create,     provenance_socket_post_create),
+	LSM_HOOK_INIT(socket_bind,	      provenance_socket_bind),
+	LSM_HOOK_INIT(socket_connect,	      provenance_socket_connect),
+	LSM_HOOK_INIT(socket_listen,	      provenance_socket_listen),
+	LSM_HOOK_INIT(socket_accept,	      provenance_socket_accept),
+#ifdef CONFIG_SECURITY_FLOW_FRIENDLY
+	LSM_HOOK_INIT(socket_sendmsg_always,  provenance_socket_sendmsg_always),
+	LSM_HOOK_INIT(socket_recvmsg_always,  provenance_socket_recvmsg_always),
+	LSM_HOOK_INIT(mq_timedreceive,	      provenance_mq_timedreceive),
+	LSM_HOOK_INIT(mq_timedsend,	      provenance_mq_timedsend),
+#else   /* CONFIG_SECURITY_FLOW_FRIENDLY */
+	LSM_HOOK_INIT(socket_sendmsg,	      provenance_socket_sendmsg),
+	LSM_HOOK_INIT(socket_recvmsg,	      provenance_socket_recvmsg),
+#endif  /* CONFIG_SECURITY_FLOW_FRIENDLY */
+	LSM_HOOK_INIT(socket_sock_rcv_skb,    provenance_socket_sock_rcv_skb),
+	LSM_HOOK_INIT(unix_stream_connect,    provenance_unix_stream_connect),
+	LSM_HOOK_INIT(unix_may_send,	      provenance_unix_may_send),
+
+	/* exec related hooks */
+	LSM_HOOK_INIT(bprm_check_security,    provenance_bprm_check),
+	LSM_HOOK_INIT(bprm_set_creds,	      provenance_bprm_set_creds),
+	LSM_HOOK_INIT(bprm_committing_creds,  provenance_bprm_committing_creds),
+
+	/* file system related hooks */
+	LSM_HOOK_INIT(sb_alloc_security,      provenance_sb_alloc_security),
+	LSM_HOOK_INIT(sb_free_security,	      provenance_sb_free_security),
+	LSM_HOOK_INIT(sb_kern_mount,	      provenance_sb_kern_mount)
+};
+
+struct kmem_cache *provenance_cache;
+struct kmem_cache *long_provenance_cache;
+
+struct prov_boot_buffer         *boot_buffer;
+struct prov_long_boot_buffer    *long_boot_buffer;
+
+LIST_HEAD(ingress_ipv4filters);
+LIST_HEAD(egress_ipv4filters);
+LIST_HEAD(secctx_filters);
+LIST_HEAD(user_filters);
+LIST_HEAD(group_filters);
+LIST_HEAD(ns_filters);
+LIST_HEAD(provenance_query_hooks);
+LIST_HEAD(relay_list);
+
+struct capture_policy prov_policy;
+
+uint32_t prov_machine_id;
+uint32_t prov_boot_id;
+
+void __init provenance_add_hooks(void)
+{
+	prov_policy.prov_enabled = true;
+#ifdef CONFIG_SECURITY_PROVENANCE_WHOLE_SYSTEM
+	prov_policy.prov_all = true;
+#else
+	prov_policy.prov_all = false;
+#endif
+	prov_machine_id = 1;
+	prov_boot_id = 0;
+	provenance_cache = kmem_cache_create("provenance_struct",
+					     sizeof(struct provenance),
+					     0, SLAB_PANIC, NULL);
+	long_provenance_cache = kmem_cache_create("long_provenance_struct",
+						  sizeof(union long_prov_elt),
+						  0, SLAB_PANIC, NULL);
+	/* init relay buffers, to deal with provenance before FS is ready */
+	boot_buffer = kzalloc(sizeof(struct prov_boot_buffer), GFP_KERNEL);
+	if (unlikely(!boot_buffer))
+		panic("Provenance: could not allocate boot_buffer.");
+	long_boot_buffer = kzalloc(sizeof(struct prov_long_boot_buffer), GFP_KERNEL);
+	if (unlikely(!long_boot_buffer))
+		panic("Provenance: could not allocate long_boot_buffer.");
+#ifdef CONFIG_SECURITY_PROVENANCE_PERSISTENCE
+	prov_queue = alloc_workqueue("prov_queue", 0, 0);
+	if (!prov_queue)
+		pr_err("Provenance: could not initialise work queue.");
+#endif
+	relay_ready = false;
+	cred_init_provenance();
+	/* register the provenance security hooks */
+	security_add_hooks(provenance_hooks, ARRAY_SIZE(provenance_hooks), "provenance");
+	pr_info("Provenance: version %s\n", CAMFLOW_VERSION_STR);
+	pr_info("Provenance: hooks ready.\n");
+}
diff -uprN -b -B ./pristine/linux-4.14.9/security/provenance/include/provenance_filter.h ./linux-4.14.9/security/provenance/include/provenance_filter.h
--- ./pristine/linux-4.14.9/security/provenance/include/provenance_filter.h	1970-01-01 01:00:00.000000000 +0100
+++ ./linux-4.14.9/security/provenance/include/provenance_filter.h	2017-12-27 19:40:12.201134581 +0000
@@ -0,0 +1,174 @@
+/*
+ *
+ * Author: Thomas Pasquier <tfjmp@seas.harvard.edu>
+ *
+ * Copyright (C) 2015-2017 University of Cambridge, Harvard University
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2, as
+ * published by the Free Software Foundation; either version 2 of the License,
+ * or (at your option) any later version.
+ *
+ */
+#ifndef _PROVENANCE_FILTER_H
+#define _PROVENANCE_FILTER_H
+
+#include <uapi/linux/provenance.h>
+
+#include "provenance_policy.h"
+#include "provenance_ns.h"
+
+#define HIT_FILTER(filter, data) ((filter & data) != 0)
+
+#define filter_node(node) __filter_node(prov_policy.prov_node_filter, node)
+#define filter_propagate_node(node) __filter_node(prov_policy.prov_propagate_node_filter, node)
+
+/* return either or not the node should be filtered out */
+static inline bool __filter_node(uint64_t filter, prov_entry_t *node)
+{
+	if (!prov_policy.prov_enabled)
+		return true;
+	if (provenance_is_opaque(node))
+		return true;
+	// we hit an element of the black list ignore
+	if (HIT_FILTER(filter, node_identifier(node).type))
+		return true;
+	return false;
+}
+
+#define UPDATE_FILTER (SUBTYPE(RL_VERSION_PROCESS) | SUBTYPE(RL_VERSION) | SUBTYPE(RL_NAMED))
+static inline bool filter_update_node(const uint64_t relation_type)
+{
+	if (HIT_FILTER(UPDATE_FILTER, relation_type)) // not update if relation is of above type
+		return true;
+	return false;
+}
+
+/* return either or not the relation should be filtered out */
+static inline bool filter_relation(const uint64_t type)
+{
+	// we hit an element of the black list ignore
+	if (HIT_FILTER(prov_policy.prov_relation_filter, type))
+		return true;
+	return false;
+}
+
+/* return either or not tracking should propagate */
+static inline bool filter_propagate_relation(uint64_t type)
+{
+	// the relation does not allow tracking propagation
+	if (HIT_FILTER(prov_policy.prov_propagate_relation_filter, type))
+		return true;
+	return false;
+}
+
+static inline bool should_record_relation(const uint64_t type,
+					  prov_entry_t *from,
+					  prov_entry_t *to)
+{
+	if (filter_relation(type))
+		return false;
+	// one of the node should not appear in the record, ignore the relation
+	if (filter_node(from) || filter_node(to))
+		return false;
+	return true;
+}
+
+#define declare_filter_list(filter_name, type) \
+	struct filter_name { \
+		struct list_head list; \
+		struct type filter; \
+	}; \
+	extern struct list_head filter_name;
+
+#define declare_filter_whichOP(function_name, type, variable) \
+	static inline uint8_t function_name(uint32_t variable) \
+	{ \
+		struct list_head *listentry, *listtmp; \
+		struct type *tmp; \
+		list_for_each_safe(listentry, listtmp, &type) { \
+			tmp = list_entry(listentry, struct type, list); \
+			if (tmp->filter.variable == variable) \
+				return tmp->filter.op; \
+		} \
+		return 0; \
+	}
+
+#define declare_filter_delete(function_name, type, variable) \
+	static inline uint8_t function_name(struct type *f) \
+	{ \
+		struct list_head *listentry, *listtmp; \
+		struct type *tmp; \
+		list_for_each_safe(listentry, listtmp, &type) { \
+			tmp = list_entry(listentry, struct type, list); \
+			if (tmp->filter.variable == f->filter.variable) { \
+				list_del(listentry); \
+				kfree(tmp); \
+				return 0; \
+			} \
+		} \
+		return 0; \
+	}
+
+#define declare_filter_add_or_update(function_name, type, variable) \
+	static inline uint8_t function_name(struct type *f) \
+	{ \
+		struct list_head *listentry, *listtmp; \
+		struct type *tmp; \
+		list_for_each_safe(listentry, listtmp, &type) { \
+			tmp = list_entry(listentry, struct type, list); \
+			if (tmp->filter.variable == f->filter.variable) { \
+				tmp->filter.op = f->filter.op; \
+				return 0; \
+			} \
+		} \
+		list_add_tail(&(f->list), &type); \
+		return 0; \
+	}
+
+declare_filter_list(secctx_filters, secinfo);
+declare_filter_whichOP(prov_secctx_whichOP, secctx_filters, secid);
+declare_filter_delete(prov_secctx_delete, secctx_filters, secid);
+declare_filter_add_or_update(prov_secctx_add_or_update, secctx_filters, secid);
+
+declare_filter_list(user_filters, userinfo);
+declare_filter_whichOP(prov_uid_whichOP, user_filters, uid);
+declare_filter_delete(prov_uid_delete, user_filters, uid);
+declare_filter_add_or_update(prov_uid_add_or_update, user_filters, uid);
+
+declare_filter_list(group_filters, groupinfo);
+declare_filter_whichOP(prov_gid_whichOP, group_filters, gid);
+declare_filter_delete(prov_gid_delete, group_filters, gid);
+declare_filter_add_or_update(prov_gid_add_or_update, group_filters, gid);
+
+static inline void apply_target(union prov_elt *prov)
+{
+	uint8_t op = 0;
+
+	// track based on ns
+	if (prov_type(prov) == ACT_TASK)
+		op |= prov_ns_whichOP(prov->task_info.utsns,
+				      prov->task_info.ipcns,
+				      prov->task_info.mntns,
+				      prov->task_info.pidns,
+				      prov->task_info.netns,
+				      prov->task_info.cgroupns);
+
+	if (prov_has_secid(node_type(prov)))
+		op |= prov_secctx_whichOP(node_secid(prov));
+
+	if (prov_has_uidgid(node_type(prov))) {
+		op |= prov_uid_whichOP(node_uid(prov));
+		op |= prov_gid_whichOP(node_gid(prov));
+	}
+
+	if (unlikely(op != 0)) {
+		if ((op & PROV_SET_TRACKED) != 0)
+			set_tracked(prov);
+		if ((op & PROV_SET_PROPAGATE) != 0)
+			set_propagate(prov);
+		if ((op & PROV_SET_OPAQUE) != 0)
+			set_opaque(prov);
+	}
+}
+#endif
diff -uprN -b -B ./pristine/linux-4.14.9/security/provenance/include/provenance.h ./linux-4.14.9/security/provenance/include/provenance.h
--- ./pristine/linux-4.14.9/security/provenance/include/provenance.h	1970-01-01 01:00:00.000000000 +0100
+++ ./linux-4.14.9/security/provenance/include/provenance.h	2017-12-27 19:40:12.200134572 +0000
@@ -0,0 +1,106 @@
+/*
+ *
+ * Author: Thomas Pasquier <thomas.pasquier@cl.cam.ac.uk>
+ *
+ * Copyright (C) 2015-2017 University of Cambridge, Harvard University
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2, as
+ * published by the Free Software Foundation; either version 2 of the License,
+ * or (at your option) any later version.
+ *
+ */
+#ifndef _PROVENANCE_H
+#define _PROVENANCE_H
+
+#include <linux/slab.h>
+#include <linux/types.h>
+#include <linux/bug.h>
+#include <linux/socket.h>
+#include <uapi/linux/mman.h>
+#include <uapi/linux/camflow.h>
+#include <uapi/linux/provenance.h>
+#include <uapi/linux/provenance_types.h>
+#include <uapi/linux/stat.h>
+#include <linux/fs.h>
+#include <linux/mm.h>
+#include <linux/xattr.h>
+
+#include "provenance_policy.h"
+#include "provenance_filter.h"
+
+extern atomic64_t prov_id;
+extern uint32_t prov_machine_id;
+extern uint32_t prov_boot_id;
+
+#define prov_next_id() ((uint64_t)atomic64_inc_return(&prov_id))
+
+enum {
+	PROVENANCE_LOCK_TASK,
+	PROVENANCE_LOCK_DIR,
+	PROVENANCE_LOCK_INODE,
+	PROVENANCE_LOCK_MSG,
+	PROVENANCE_LOCK_SHM,
+	PROVENANCE_LOCK_SOCKET,
+	PROVENANCE_LOCK_SOCK
+};
+
+struct provenance {
+	union prov_elt msg;
+	spinlock_t lock;
+	bool has_mmap;
+	bool updt_mmap;
+	bool has_outgoing;
+	bool initialised;
+	bool saved;
+	uint64_t previous_id;
+	uint64_t previous_type;
+};
+
+#define prov_elt(provenance) (&(provenance->msg))
+#define prov_lock(provenance) (&(provenance->lock))
+#define prov_entry(provenance) ((prov_entry_t*)prov_elt(provenance))
+
+#define ASSIGN_NODE_ID 0
+
+extern struct kmem_cache *provenance_cache;
+extern struct kmem_cache *long_provenance_cache;
+
+static inline struct provenance *alloc_provenance(uint64_t ntype, gfp_t gfp)
+{
+	struct provenance *prov =  kmem_cache_zalloc(provenance_cache, gfp);
+
+	if (!prov)
+		return NULL;
+	spin_lock_init(prov_lock(prov));
+	prov_type(prov_elt(prov)) = ntype;
+	node_identifier(prov_elt(prov)).id = prov_next_id();
+	node_identifier(prov_elt(prov)).boot_id = prov_boot_id;
+	node_identifier(prov_elt(prov)).machine_id = prov_machine_id;
+	return prov;
+}
+
+static inline void free_provenance(struct provenance *prov)
+{
+	kmem_cache_free(provenance_cache, prov);
+}
+
+static inline union long_prov_elt *alloc_long_provenance(uint64_t ntype)
+{
+	union long_prov_elt *tmp = kmem_cache_zalloc(long_provenance_cache, GFP_ATOMIC);
+
+	if (!tmp)
+		return NULL;
+	prov_type(tmp) = ntype;
+	node_identifier(tmp).id = prov_next_id();
+	node_identifier(tmp).boot_id = prov_boot_id;
+	node_identifier(tmp).machine_id = prov_machine_id;
+	set_is_long(tmp);
+	return tmp;
+}
+
+static inline void free_long_provenance(union long_prov_elt *prov)
+{
+	kmem_cache_free(long_provenance_cache, prov);
+}
+#endif
diff -uprN -b -B ./pristine/linux-4.14.9/security/provenance/include/provenance_inode.h ./linux-4.14.9/security/provenance/include/provenance_inode.h
--- ./pristine/linux-4.14.9/security/provenance/include/provenance_inode.h	1970-01-01 01:00:00.000000000 +0100
+++ ./linux-4.14.9/security/provenance/include/provenance_inode.h	2017-12-27 19:40:12.201134581 +0000
@@ -0,0 +1,388 @@
+/*
+ *
+ * Author: Thomas Pasquier <tfjmp@seas.harvard.edu>
+ *
+ * Copyright (C) 2015-2017 University of Cambridge, Harvard University
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2, as
+ * published by the Free Software Foundation; either version 2 of the License,
+ * or (at your option) any later version.
+ *
+ */
+#ifndef _PROVENANCE_INODE_H
+#define _PROVENANCE_INODE_H
+
+#include <linux/file.h>
+#include <linux/fs.h>
+#include <linux/namei.h>
+#include <linux/xattr.h>
+
+#include "provenance_record.h"
+#include "provenance_policy.h"
+#include "provenance_filter.h"
+
+#define is_inode_dir(inode) S_ISDIR(inode->i_mode)
+#define is_inode_socket(inode) S_ISSOCK(inode->i_mode)
+#define is_inode_file(inode) S_ISREG(inode->i_mode)
+
+static inline void update_inode_type(uint16_t mode, struct provenance *prov)
+{
+	union prov_elt old_prov;
+	uint64_t type = ENT_INODE_UNKNOWN;
+	unsigned long irqflags;
+
+	if (S_ISBLK(mode))
+		type = ENT_INODE_BLOCK;
+	else if (S_ISCHR(mode))
+		type = ENT_INODE_CHAR;
+	else if (S_ISDIR(mode))
+		type = ENT_INODE_DIRECTORY;
+	else if (S_ISFIFO(mode))
+		type = ENT_INODE_FIFO;
+	else if (S_ISLNK(mode))
+		type = ENT_INODE_LINK;
+	else if (S_ISREG(mode))
+		type = ENT_INODE_FILE;
+	else if (S_ISSOCK(mode))
+		type = ENT_INODE_SOCKET;
+	spin_lock_irqsave_nested(prov_lock(prov), irqflags, PROVENANCE_LOCK_INODE);
+	if (prov_elt(prov)->inode_info.mode != 0
+	    && prov_elt(prov)->inode_info.mode != mode
+	    && provenance_is_recorded(prov_elt(prov))) {
+		if (filter_update_node(type))
+			goto out;
+		memcpy(&old_prov, prov_elt(prov), sizeof(old_prov));
+		/* we update the info of the new version and record it */
+		prov_elt(prov)->inode_info.mode = mode;
+		prov_type(prov_elt(prov)) = type;
+		node_identifier(prov_elt(prov)).version++;
+		clear_recorded(prov_elt(prov));
+
+		/* we record a version edge */
+		write_relation(RL_VERSION, &old_prov, prov_elt(prov), NULL, 0);
+		prov->has_outgoing = false; // we update there is no more outgoing edge
+		prov->saved = false;
+	}
+out:
+	prov_elt(prov)->inode_info.mode = mode;
+	prov_type(prov_elt(prov)) = type;
+	spin_unlock_irqrestore(prov_lock(prov), irqflags);
+}
+
+static inline void provenance_mark_as_opaque(const char *name)
+{
+	struct path path;
+	struct provenance *prov;
+
+	if (kern_path(name, LOOKUP_FOLLOW, &path)) {
+		pr_err("Provenance: Failed file look up (%s).", name);
+		return;
+	}
+	prov = path.dentry->d_inode->i_provenance;
+	if (prov)
+		set_opaque(prov_elt(prov));
+}
+
+static inline int record_inode_name_from_dentry(struct dentry *dentry, struct provenance *prov)
+{
+	char *buffer;
+	char *ptr;
+	int rc;
+
+	if (provenance_is_name_recorded(prov_elt(prov)) ||
+	    !provenance_is_recorded(prov_elt(prov)))
+		return 0;
+	// should not sleep
+	buffer = kcalloc(PATH_MAX, sizeof(char), GFP_ATOMIC);
+	if (!buffer)
+		return -ENOMEM;
+	ptr = dentry_path_raw(dentry, buffer, PATH_MAX);
+	if (IS_ERR(ptr))
+		return PTR_ERR(ptr);
+	rc = record_node_name(prov, ptr);
+	kfree(buffer);
+	return rc;
+}
+
+static inline int record_inode_name(struct inode *inode, struct provenance *prov)
+{
+	struct dentry *dentry;
+	int rc;
+
+	if (provenance_is_name_recorded(prov_elt(prov)) || !provenance_is_recorded(prov_elt(prov)))
+		return 0;
+	dentry = d_find_alias(inode);
+	if (!dentry) // we did not find a dentry, not sure if it should ever happen
+		return 0;
+	rc = record_inode_name_from_dentry(dentry, prov);
+	dput(dentry);
+	return rc;
+}
+
+static inline void refresh_inode_provenance(struct inode *inode, bool may_sleep)
+{
+	struct provenance *prov = inode->i_provenance;
+
+	// will not be recorded
+	if (provenance_is_opaque(prov_elt(prov)))
+		return;
+	if (may_sleep)
+		record_inode_name(inode, prov);
+	prov_elt(prov)->inode_info.ino = inode->i_ino;
+	node_uid(prov_elt(prov)) = __kuid_val(inode->i_uid);
+	node_gid(prov_elt(prov)) = __kgid_val(inode->i_gid);
+	security_inode_getsecid(inode, &(prov_elt(prov)->inode_info.secid));
+	update_inode_type(inode->i_mode, prov);
+}
+
+static inline struct provenance *branch_mmap(struct provenance *iprov, struct provenance *cprov)
+{
+	struct provenance *prov;
+
+	if (!provenance_is_tracked(prov_elt(iprov)) && !provenance_is_tracked(prov_elt(cprov)) && !prov_policy.prov_all)
+		return NULL;
+	prov = alloc_provenance(ENT_INODE_MMAP, GFP_ATOMIC);
+	if (!prov)
+		return NULL;
+	set_tracked(prov_elt(prov));
+	node_uid(prov_elt(prov)) = prov_elt(iprov)->inode_info.uid;
+	node_gid(prov_elt(prov)) = prov_elt(iprov)->inode_info.gid;
+	prov_elt(prov)->inode_info.mode = prov_elt(iprov)->inode_info.mode;
+	prov_elt(prov)->inode_info.ino = prov_elt(iprov)->inode_info.ino;
+	memcpy(prov_elt(prov)->inode_info.sb_uuid, prov_elt(iprov)->inode_info.sb_uuid, 16 * sizeof(uint8_t));
+	return prov;
+}
+
+static inline int inode_init_provenance(struct inode *inode, struct dentry *opt_dentry)
+{
+	struct provenance *prov = inode->i_provenance;
+	union prov_elt *buf;
+	struct dentry *dentry;
+	int rc = 0;
+
+	if (prov->initialised)
+		return 0;
+	spin_lock_nested(prov_lock(prov), PROVENANCE_LOCK_INODE);
+	if (prov->initialised) {
+		spin_unlock(prov_lock(prov));
+		return 0;
+	}       else
+		prov->initialised = true;
+	spin_unlock(prov_lock(prov));
+	update_inode_type(inode->i_mode, prov);
+	if (!(inode->i_opflags & IOP_XATTR)) // xattr not supported on this inode
+		return 0;
+	if (opt_dentry)
+		dentry = dget(opt_dentry);
+	else
+		dentry = d_find_alias(inode);
+	if (!dentry)
+		return 0;
+	buf = kmalloc(sizeof(union prov_elt), GFP_NOFS);
+	if (!buf) {
+		prov->initialised = false;
+		dput(dentry);
+		return -ENOMEM;
+	}
+	rc = __vfs_getxattr(dentry, inode, XATTR_NAME_PROVENANCE, buf, sizeof(union prov_elt));
+	dput(dentry);
+	if (rc < 0) {
+		if (rc != -ENODATA && rc != -EOPNOTSUPP) {
+			prov->initialised = false;
+			goto free_buf;
+		} else {
+			rc = 0;
+			goto free_buf;
+		}
+	}
+	memcpy(prov_elt(prov), buf, sizeof(union prov_elt));
+	rc = 0;
+free_buf:
+	kfree(buf);
+	return rc;
+}
+
+static inline struct provenance *inode_provenance(struct inode *inode, bool may_sleep)
+{
+	struct provenance *prov = inode->i_provenance;
+
+	might_sleep_if(may_sleep);
+	if (!prov->initialised && may_sleep)
+		inode_init_provenance(inode, NULL);
+	refresh_inode_provenance(inode, may_sleep);
+	return prov;
+}
+
+static inline struct provenance *dentry_provenance(struct dentry *dentry, bool may_sleep)
+{
+	struct inode *inode = d_backing_inode(dentry);
+
+	if (!inode)
+		return NULL;
+	return inode_provenance(inode, may_sleep);
+}
+
+static inline struct provenance *file_provenance(struct file *file, bool may_sleep)
+{
+	struct inode *inode = file_inode(file);
+
+	if (!inode)
+		return NULL;
+	return inode_provenance(inode, may_sleep);
+}
+
+static inline void save_provenance(struct dentry *dentry)
+{
+	struct provenance *prov;
+	union prov_elt buf;
+
+	if (!dentry)
+		return;
+	prov = dentry_provenance(dentry, false);
+	if (!prov)
+		return;
+	spin_lock(prov_lock(prov));
+	if (!prov->initialised || prov->saved) { // not initialised or already saved
+		spin_unlock(prov_lock(prov));
+		return;
+	}
+	memcpy(&buf, prov_elt(prov), sizeof(union prov_elt));
+	prov->saved = true;
+	spin_unlock(prov_lock(prov));
+	clear_recorded(&buf);
+	clear_name_recorded(&buf);
+	if (!dentry)
+		return;
+	__vfs_setxattr_noperm(dentry, XATTR_NAME_PROVENANCE, &buf, sizeof(union prov_elt), 0);
+}
+
+static inline int record_write_xattr(uint64_t type,
+				     struct provenance *iprov,
+				     struct provenance *cprov,
+				     const char *name,
+				     const void *value,
+				     size_t size,
+				     const uint64_t flags)
+{
+	union long_prov_elt *xattr;
+	int rc = 0;
+
+	if (!should_record_relation(type, prov_entry(cprov), prov_entry(iprov)))
+		return 0;
+	xattr = alloc_long_provenance(ENT_XATTR);
+	if (!xattr)
+		return -ENOMEM;
+	memcpy(xattr->xattr_info.name, name, PROV_XATTR_NAME_SIZE - 1);
+	xattr->xattr_info.name[PROV_XATTR_NAME_SIZE - 1] = '\0';
+	if (value) {
+		if (size < PROV_XATTR_VALUE_SIZE) {
+			xattr->xattr_info.size = size;
+			memcpy(xattr->xattr_info.value, value, size);
+		} else{
+			xattr->xattr_info.size = PROV_XATTR_VALUE_SIZE;
+			memcpy(xattr->xattr_info.value, value, PROV_XATTR_VALUE_SIZE);
+		}
+	}
+
+	rc = write_relation(type, prov_elt(cprov), xattr, NULL, flags);
+	if (rc < 0)
+		goto out;
+	rc = __update_version(type, iprov);
+	if (rc < 0)
+		goto out;
+
+	if (type == RL_SETXATTR)
+		rc = write_relation(RL_SETXATTR_INODE, xattr, prov_elt(iprov), NULL, flags);
+	else
+		rc = write_relation(RL_RMVXATTR_INODE, xattr, prov_elt(iprov), NULL, flags);
+	cprov->has_outgoing = true;
+out:
+	free_long_provenance(xattr);
+	return rc;
+}
+
+static inline int record_read_xattr(struct provenance *cprov,
+				    struct provenance *iprov,
+				    const char *name)
+{
+	union long_prov_elt *xattr;
+	int rc = 0;
+
+	if (!should_record_relation(RL_GETXATTR, prov_entry(iprov), prov_entry(cprov)))
+		return 0;
+	xattr = alloc_long_provenance(ENT_XATTR);
+	if (!xattr)
+		goto out;
+	memcpy(xattr->xattr_info.name, name, PROV_XATTR_NAME_SIZE - 1);
+	xattr->xattr_info.name[PROV_XATTR_NAME_SIZE - 1] = '\0';
+
+	rc = write_relation(RL_GETXATTR_INODE, prov_elt(iprov), xattr, NULL, 0);
+	if (rc < 0)
+		goto out;
+	rc = __update_version(RL_GETXATTR, cprov);
+	if (rc < 0)
+		goto out;
+
+	rc = write_relation(RL_GETXATTR, xattr, prov_elt(cprov), NULL, 0);
+	iprov->has_outgoing = true;
+out:
+	free_long_provenance(xattr);
+	return rc;
+}
+
+static inline int close_inode(struct provenance *iprov)
+{
+	union prov_elt old_prov;
+	int rc;
+
+	if (!provenance_is_tracked(prov_elt(iprov)) && !prov_policy.prov_all)
+		return 0;
+	if (filter_node(prov_entry(iprov)))
+		return 0;
+	// persistent
+	if (prov_type(prov_entry(iprov)) == ENT_INODE_FILE ||
+	    prov_type(prov_entry(iprov)) == ENT_INODE_DIRECTORY)
+		return 0;
+	memcpy(&old_prov, prov_elt(iprov), sizeof(old_prov));
+	node_identifier(prov_elt(iprov)).version++;
+	clear_recorded(prov_elt(iprov));
+
+	rc = write_relation(RL_CLOSED, &old_prov, prov_elt(iprov), NULL, 0);
+	iprov->has_outgoing = false;
+	return rc;
+}
+
+#define FILE__EXECUTE   0x00000001UL
+#define FILE__READ      0x00000002UL
+#define FILE__APPEND    0x00000004UL
+#define FILE__WRITE     0x00000008UL
+#define DIR__SEARCH     0x00000010UL
+#define DIR__WRITE      0x00000020UL
+#define DIR__READ       0x00000040UL
+
+static inline uint32_t file_mask_to_perms(int mode, unsigned int mask)
+{
+	uint32_t av = 0;
+
+	if (!S_ISDIR(mode)) {
+		if (mask & MAY_EXEC)
+			av |= FILE__EXECUTE;
+		if (mask & MAY_READ)
+			av |= FILE__READ;
+		if (mask & MAY_APPEND)
+			av |= FILE__APPEND;
+		else if (mask & MAY_WRITE)
+			av |= FILE__WRITE;
+	} else {
+		if (mask & MAY_EXEC)
+			av |= DIR__SEARCH;
+		if (mask & MAY_WRITE)
+			av |= DIR__WRITE;
+		if (mask & MAY_READ)
+			av |= DIR__READ;
+	}
+
+	return av;
+}
+#endif
diff -uprN -b -B ./pristine/linux-4.14.9/security/provenance/include/provenance_net.h ./linux-4.14.9/security/provenance/include/provenance_net.h
--- ./pristine/linux-4.14.9/security/provenance/include/provenance_net.h	1970-01-01 01:00:00.000000000 +0100
+++ ./linux-4.14.9/security/provenance/include/provenance_net.h	2017-12-27 19:40:12.201134581 +0000
@@ -0,0 +1,290 @@
+/*
+ *
+ * Author: Thomas Pasquier <tfjmp@seas.harvard.edu>
+ *
+ * Copyright (C) 2015-2017 University of Cambridge, Harvard University
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2, as
+ * published by the Free Software Foundation; either version 2 of the License,
+ * or (at your option) any later version.
+ *
+ */
+#ifndef _PROVENANCE_NET_H
+#define _PROVENANCE_NET_H
+
+#include <net/sock.h>
+#include <net/ip.h>
+#include <linux/netfilter_ipv4.h>
+#include <linux/netfilter_ipv6.h>
+#include <linux/ip.h>
+#include <linux/tcp.h>
+#include <linux/udp.h>
+#include <linux/skbuff.h>
+
+#include "provenance.h"
+#include "provenance_policy.h"
+#include "provenance_inode.h"
+
+static inline struct provenance *socket_inode_provenance(struct socket *sock)
+{
+	struct inode *inode = SOCK_INODE(sock);
+	struct provenance *iprov = NULL;
+
+	if (inode)
+		iprov = inode_provenance(SOCK_INODE(sock), false);
+	return iprov;
+}
+
+static inline struct provenance *sk_inode_provenance(struct sock *sk)
+{
+	struct socket *sock = sk->sk_socket;
+
+	if (!sock)
+		return NULL;
+	return socket_inode_provenance(sock);
+}
+
+static inline struct provenance *sk_provenance(struct sock *sk)
+{
+	struct provenance *prov = sk->sk_provenance;
+
+	return prov;
+}
+
+static inline struct provenance *socket_provenance(struct socket *sock)
+{
+	struct sock *sk = sock->sk;
+
+	if (!sk)
+		return NULL;
+	return sk_provenance(sk);
+}
+
+#define ihlen(ih) (ih->ihl * 4)
+
+static inline void __extract_tcp_info(struct sk_buff *skb,
+				      struct iphdr *ih,
+				      int offset,
+				      struct packet_identifier *id)
+{
+	struct tcphdr _tcph;
+	struct tcphdr *th;
+	int tcpoff;
+
+	if (ntohs(ih->frag_off) & IP_OFFSET)
+		return;
+	tcpoff = offset + ihlen(ih); //point to tcp packet
+	th = skb_header_pointer(skb, tcpoff, sizeof(_tcph), &_tcph);
+	if (!th)
+		return;
+	id->snd_port = th->source;
+	id->rcv_port = th->dest;
+	id->seq = th->seq;
+}
+
+static inline void __extract_udp_info(struct sk_buff *skb,
+				      struct iphdr *ih,
+				      int offset,
+				      struct packet_identifier *id)
+{
+	struct udphdr _udph;
+	struct udphdr   *uh;
+	int udpoff;
+
+	if (ntohs(ih->frag_off) & IP_OFFSET)
+		return;
+	udpoff = offset + ihlen(ih); //point to udp packet
+	uh = skb_header_pointer(skb, udpoff, sizeof(_udph), &_udph);
+	if (!uh)
+		return;
+	id->snd_port = uh->source;
+	id->rcv_port = uh->dest;
+}
+
+static inline unsigned int provenance_parse_skb_ipv4(struct sk_buff *skb, union prov_elt *prov)
+{
+	struct packet_identifier *id;
+	int offset;
+	struct iphdr _iph;
+	struct iphdr *ih;
+
+	offset = skb_network_offset(skb);
+	ih = skb_header_pointer(skb, offset, sizeof(_iph), &_iph); // we obtain the ip header
+	if (!ih)
+		return -EINVAL;
+
+	if (ihlen(ih) < sizeof(_iph))
+		return -EINVAL;
+
+	memset(prov, 0, sizeof(union prov_elt));
+	id = &packet_identifier(prov); // we are going fo fill this
+
+	id->type = ENT_PACKET;
+	// collect IP element of prov identifier
+	id->id = ih->id;
+	id->snd_ip = ih->saddr;
+	id->rcv_ip = ih->daddr;
+	id->protocol = ih->protocol;
+	prov->pck_info.length = ih->tot_len;
+
+	// now we collect
+	switch (ih->protocol) {
+	case IPPROTO_TCP:
+		__extract_tcp_info(skb, ih, offset, id);
+		break;
+	case IPPROTO_UDP:
+		__extract_udp_info(skb, ih, offset, id);
+		break;
+	default:
+		break;
+	}
+	return 0;
+}
+
+struct ipv4_filters {
+	struct list_head list;
+	struct prov_ipv4_filter filter;
+};
+
+extern struct list_head ingress_ipv4filters;
+extern struct list_head egress_ipv4filters;
+
+#define prov_ipv4_ingressOP(ip, port) prov_ipv4_whichOP(&ingress_ipv4filters, ip, port)
+#define prov_ipv4_egressOP(ip, port) prov_ipv4_whichOP(&egress_ipv4filters, ip, port)
+
+static inline uint8_t prov_ipv4_whichOP(struct list_head *filters, uint32_t ip, uint32_t port)
+{
+	struct list_head *listentry, *listtmp;
+	struct ipv4_filters *tmp;
+
+	list_for_each_safe(listentry, listtmp, filters) {
+		tmp = list_entry(listentry, struct ipv4_filters, list);
+		if ((tmp->filter.mask & ip) == (tmp->filter.mask & tmp->filter.ip))     // ip match filter
+			if (tmp->filter.port == 0 || tmp->filter.port == port)          // any port or match
+				return tmp->filter.op;
+	}
+	return 0; // do nothing
+}
+
+static inline uint8_t prov_ipv4_delete(struct list_head *filters, struct ipv4_filters *f)
+{
+	struct list_head *listentry, *listtmp;
+	struct ipv4_filters *tmp;
+
+	list_for_each_safe(listentry, listtmp, filters) {
+		tmp = list_entry(listentry, struct ipv4_filters, list);
+		if (tmp->filter.mask == f->filter.mask &&
+		    tmp->filter.ip == f->filter.ip &&
+		    tmp->filter.port == f->filter.port) {
+			list_del(listentry);
+			kfree(tmp);
+			return 0; // you should only get one
+		}
+	}
+	return 0; // do nothing
+}
+
+static inline uint8_t prov_ipv4_add_or_update(struct list_head *filters, struct ipv4_filters *f)
+{
+	struct list_head *listentry, *listtmp;
+	struct ipv4_filters *tmp;
+
+	list_for_each_safe(listentry, listtmp, filters) {
+		tmp = list_entry(listentry, struct ipv4_filters, list);
+		if (tmp->filter.mask == f->filter.mask &&
+		    tmp->filter.ip == f->filter.ip &&
+		    tmp->filter.port == f->filter.port) {
+			tmp->filter.op |= f->filter.op;
+			return 0; // you should only get one
+		}
+	}
+	list_add_tail(&(f->list), filters); // not already on the list, we add it
+	return 0;
+}
+
+// TODO record_pck_to_inode and record_inode_to_pck need a rewrite
+
+// incoming packet
+static inline int record_pck_to_inode(union prov_elt *pck, struct provenance *inode)
+{
+	int rc = 0;
+
+	if (unlikely(!pck || !inode)) // should not occur
+		return 0;
+
+	apply_target(prov_elt(inode));
+	apply_target(pck);
+
+	if (!provenance_is_tracked(prov_elt(inode)) && !prov_policy.prov_all)
+		return 0;
+	if (!should_record_relation(RL_RCV_PACKET, (prov_entry_t*)pck, prov_entry(inode)))
+		return 0;
+	rc = __update_version(RL_RCV_PACKET, inode);
+	if (rc < 0)
+		return rc;
+
+	rc = write_relation(RL_RCV_PACKET, pck, prov_elt(inode), NULL, 0);
+	return rc;
+}
+
+// outgoing packet
+static inline int record_inode_to_pck(struct provenance *inode, union prov_elt *pck)
+{
+	int rc = 0;
+
+	if (unlikely(!pck || !inode)) // should not occur
+		return 0;
+
+	apply_target(prov_elt(inode));
+	apply_target(pck);
+
+	if (!provenance_is_tracked(prov_elt(inode)) && !prov_policy.prov_all)
+		return 0;
+	if (!should_record_relation(RL_SND_PACKET, prov_entry(inode), (prov_entry_t*)pck))
+		return 0;
+
+	rc = write_relation(RL_SND_PACKET, prov_elt(inode), pck, NULL, 0);
+	inode->has_outgoing = true;
+	return rc;
+}
+
+static inline int provenance_record_address(struct sockaddr *address, int addrlen, struct provenance *prov)
+{
+	union long_prov_elt *addr_info;
+	int rc = 0;
+
+	if (provenance_is_name_recorded(prov_elt(prov)) || !provenance_is_recorded(prov_elt(prov)))
+		return 0;
+	addr_info = alloc_long_provenance(ENT_ADDR);
+	if (!addr_info) {
+		rc = -ENOMEM;
+		goto out;
+	}
+	addr_info->address_info.length = addrlen;
+	memcpy(&(addr_info->address_info.addr), address, addrlen);
+
+	rc = write_relation(RL_NAMED, addr_info, prov_elt(prov), NULL, 0);
+	set_name_recorded(prov_elt(prov));
+out:
+	free_long_provenance(addr_info);
+	return rc;
+}
+
+static inline int record_packet_content(union prov_elt *pck, const struct sk_buff *skb)
+{
+	union long_prov_elt *cnt = alloc_long_provenance(ENT_PCKCNT);
+	int rc;
+
+	cnt->pckcnt_info.length = skb_end_offset(skb);
+	if (cnt->pckcnt_info.length > PATH_MAX) {
+		cnt->pckcnt_info.truncated = PROV_TRUNCATED;
+		memcpy(cnt->pckcnt_info.content, skb->head, PATH_MAX);
+	} else
+		memcpy(cnt->pckcnt_info.content, skb->head, cnt->pckcnt_info.length);
+
+	rc = write_relation(RL_READ, cnt, pck, NULL, 0);
+	free_long_provenance(cnt);
+	return rc;
+}
+#endif
diff -uprN -b -B ./pristine/linux-4.14.9/security/provenance/include/provenance_ns.h ./linux-4.14.9/security/provenance/include/provenance_ns.h
--- ./pristine/linux-4.14.9/security/provenance/include/provenance_ns.h	1970-01-01 01:00:00.000000000 +0100
+++ ./linux-4.14.9/security/provenance/include/provenance_ns.h	2017-12-27 19:40:12.202134590 +0000
@@ -0,0 +1,89 @@
+/*
+ *
+ * Author: Thomas Pasquier <tfjmp@seas.harvard.edu>
+ *
+ * Copyright (C) 2015-2017 University of Cambridge, Harvard University
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2, as
+ * published by the Free Software Foundation; either version 2 of the License,
+ * or (at your option) any later version.
+ *
+ */
+#ifndef _PROVENANCE_NS_H
+#define _PROVENANCE_NS_H
+
+struct ns_filters {
+	struct list_head list;
+	struct nsinfo filter;
+};
+
+extern struct list_head ns_filters;
+
+static inline uint8_t prov_ns_whichOP(uint32_t utsns,
+				      uint32_t ipcns,
+				      uint32_t mntns,
+				      uint32_t pidns,
+				      uint32_t netns,
+				      uint32_t cgroupns)
+{
+	struct list_head *listentry, *listtmp;
+	struct ns_filters *tmp;
+
+	list_for_each_safe(listentry, listtmp, &ns_filters) {
+		tmp = list_entry(listentry, struct ns_filters, list);
+		if ((tmp->filter.cgroupns == cgroupns || tmp->filter.cgroupns == IGNORE_NS)
+		    && (tmp->filter.utsns == utsns || tmp->filter.utsns == IGNORE_NS)
+		    && (tmp->filter.ipcns == ipcns || tmp->filter.ipcns == IGNORE_NS)
+		    && (tmp->filter.mntns == mntns || tmp->filter.mntns == IGNORE_NS)
+		    && (tmp->filter.pidns == pidns || tmp->filter.pidns == IGNORE_NS)
+		    && (tmp->filter.netns == netns || tmp->filter.netns == IGNORE_NS))
+			return tmp->filter.op;
+	}
+	return 0; // do nothing
+}
+
+static inline uint8_t prov_ns_delete(struct ns_filters *f)
+{
+	struct list_head *listentry, *listtmp;
+	struct ns_filters *tmp;
+
+	list_for_each_safe(listentry, listtmp, &ns_filters) {
+		tmp = list_entry(listentry, struct ns_filters, list);
+		if (tmp->filter.cgroupns == f->filter.cgroupns
+		    && tmp->filter.utsns == f->filter.utsns
+		    && tmp->filter.ipcns == f->filter.ipcns
+		    && tmp->filter.mntns == f->filter.mntns
+		    && tmp->filter.pidns == f->filter.pidns
+		    && tmp->filter.netns == f->filter.netns
+		    ) {
+			list_del(listentry);
+			kfree(tmp);
+			return 0; // you should only get one
+		}
+	}
+	return 0; // do nothing
+}
+
+static inline uint8_t prov_ns_add_or_update(struct ns_filters *f)
+{
+	struct list_head *listentry, *listtmp;
+	struct ns_filters *tmp;
+
+	list_for_each_safe(listentry, listtmp, &ns_filters) {
+		tmp = list_entry(listentry, struct ns_filters, list);
+		if (tmp->filter.cgroupns == f->filter.cgroupns
+		    && tmp->filter.utsns == f->filter.utsns
+		    && tmp->filter.ipcns == f->filter.ipcns
+		    && tmp->filter.mntns == f->filter.mntns
+		    && tmp->filter.pidns == f->filter.pidns
+		    && tmp->filter.netns == f->filter.netns
+		    ) {
+			tmp->filter.op = f->filter.op;
+			return 0; // you should only get one
+		}
+	}
+	list_add_tail(&(f->list), &ns_filters); // not already on the list, we add it
+	return 0;
+}
+#endif
diff -uprN -b -B ./pristine/linux-4.14.9/security/provenance/include/provenance_policy.h ./linux-4.14.9/security/provenance/include/provenance_policy.h
--- ./pristine/linux-4.14.9/security/provenance/include/provenance_policy.h	1970-01-01 01:00:00.000000000 +0100
+++ ./linux-4.14.9/security/provenance/include/provenance_policy.h	2017-12-27 19:40:12.202134590 +0000
@@ -0,0 +1,29 @@
+/*
+ *
+ * Author: Thomas Pasquier <tfjmp@seas.harvard.edu>
+ *
+ * Copyright (C) 2015-2017 University of Cambridge, Harvard University
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2, as
+ * published by the Free Software Foundation; either version 2 of the License,
+ * or (at your option) any later version.
+ *
+ */
+#ifndef _PROVENANCE_POLICY_H
+#define _PROVENANCE_POLICY_H
+
+struct capture_policy {
+	bool prov_enabled;
+	bool prov_all;
+	bool should_compress_node;
+	bool should_compress_edge;
+	uint64_t prov_node_filter;
+	uint64_t prov_propagate_node_filter;
+	uint64_t prov_relation_filter;
+	uint64_t prov_propagate_relation_filter;
+};
+
+extern struct capture_policy prov_policy;
+
+#endif
diff -uprN -b -B ./pristine/linux-4.14.9/security/provenance/include/provenance_query.h ./linux-4.14.9/security/provenance/include/provenance_query.h
--- ./pristine/linux-4.14.9/security/provenance/include/provenance_query.h	1970-01-01 01:00:00.000000000 +0100
+++ ./linux-4.14.9/security/provenance/include/provenance_query.h	2017-12-27 19:40:12.202134590 +0000
@@ -0,0 +1,72 @@
+/*
+ *
+ * Author: Thomas Pasquier <tfjmp@g.harvard.edu>
+ *
+ * Copyright (C) 2015-2017 University of Cambridge, Harvard University
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2, as
+ * published by the Free Software Foundation; either version 2 of the License,
+ * or (at your option) any later version.
+ *
+ */
+#ifndef _PROVENANCE_QUERY_H
+#define _PROVENANCE_QUERY_H
+
+#include <linux/provenance_query.h>
+
+static inline int call_provenance_out_edge(prov_entry_t *node,
+					   prov_entry_t *edge)
+{
+	int rc = 0;
+	struct list_head *listentry, *listtmp;
+	struct provenance_query_hooks *fcn;
+
+	list_for_each_safe(listentry, listtmp, &provenance_query_hooks) {
+		fcn = list_entry(listentry, struct provenance_query_hooks, list);
+		if (fcn->out_edge)
+			rc |= fcn->out_edge(node, edge);
+	}
+	return rc;
+}
+
+static inline int call_provenance_in_edge(prov_entry_t *edge,
+					  prov_entry_t *node)
+{
+	int rc = 0;
+	struct list_head *listentry, *listtmp;
+	struct provenance_query_hooks *fcn;
+
+	list_for_each_safe(listentry, listtmp, &provenance_query_hooks) {
+		fcn = list_entry(listentry, struct provenance_query_hooks, list);
+		if (fcn->in_edge)
+			rc |= fcn->in_edge(edge, node);
+	}
+	return rc;
+}
+
+static inline int call_query_hooks(prov_entry_t *from,
+				   prov_entry_t *to,
+				   prov_entry_t *edge)
+{
+	int rc = 0;
+
+	rc = call_provenance_out_edge(from, edge);
+	if ((rc & PROVENANCE_RAISE_WARNING) == PROVENANCE_RAISE_WARNING)
+		pr_warning("Provenance: warning raised.\n");
+	if ((rc & PROVENANCE_PREVENT_FLOW) == PROVENANCE_PREVENT_FLOW) {
+		pr_err("Provenance: error raised.\n");
+		edge->relation_info.allowed = FLOW_DISALLOWED;
+		return -EPERM;
+	}
+	rc = call_provenance_in_edge(edge, to);
+	if ((rc & PROVENANCE_RAISE_WARNING) == PROVENANCE_RAISE_WARNING)
+		pr_warning("Provenance: warning raised.\n");
+	if ((rc & PROVENANCE_PREVENT_FLOW) == PROVENANCE_PREVENT_FLOW) {
+		pr_err("Provenance: error raised.\n");
+		edge->relation_info.allowed = FLOW_DISALLOWED;
+		return -EPERM;
+	}
+	return 0;
+}
+#endif
diff -uprN -b -B ./pristine/linux-4.14.9/security/provenance/include/provenance_record.h ./linux-4.14.9/security/provenance/include/provenance_record.h
--- ./pristine/linux-4.14.9/security/provenance/include/provenance_record.h	1970-01-01 01:00:00.000000000 +0100
+++ ./linux-4.14.9/security/provenance/include/provenance_record.h	2017-12-27 19:40:12.202134590 +0000
@@ -0,0 +1,186 @@
+/*
+ *
+ * Author: Thomas Pasquier <thomas.pasquier@cl.cam.ac.uk>
+ *
+ * Copyright (C) 2015-2017 University of Cambridge, Harvard University
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2, as
+ * published by the Free Software Foundation; either version 2 of the License,
+ * or (at your option) any later version.
+ *
+ */
+#ifndef _PROVENANCE_RECORD_H
+#define _PROVENANCE_RECORD_H
+
+#include "provenance.h"
+#include "provenance_relay.h"
+
+static inline int record_node_name(struct provenance *node, const char *name)
+{
+	union long_prov_elt *fname_prov;
+	int rc;
+
+	if (provenance_is_name_recorded(prov_elt(node)) || !provenance_is_recorded(prov_elt(node)))
+		return 0;
+
+	fname_prov = alloc_long_provenance(ENT_FILE_NAME);
+	if (!fname_prov)
+		return -ENOMEM;
+
+	strlcpy(fname_prov->file_name_info.name, name, PATH_MAX);
+	fname_prov->file_name_info.length = strnlen(fname_prov->file_name_info.name, PATH_MAX);
+
+	// record the relation
+	spin_lock(prov_lock(node));
+	if (prov_type(prov_elt(node)) == ACT_TASK) {
+		rc = write_relation(RL_NAMED_PROCESS, fname_prov, prov_elt(node), NULL, 0);
+		set_name_recorded(prov_elt(node));
+	} else{
+		rc = write_relation(RL_NAMED, fname_prov, prov_elt(node), NULL, 0);
+		set_name_recorded(prov_elt(node));
+	}
+	spin_unlock(prov_lock(node));
+	free_long_provenance(fname_prov);
+	return rc;
+}
+
+static inline int record_log(union prov_elt *cprov, const char __user *buf, size_t count)
+{
+	union long_prov_elt *str;
+	int rc = 0;
+
+	str = alloc_long_provenance(ENT_STR);
+	if (!str) {
+		rc = -ENOMEM;
+		goto out;
+	}
+	if (copy_from_user(str->str_info.str, buf, count)) {
+		rc = -EAGAIN;
+		goto out;
+	}
+	str->str_info.str[count] = '\0'; // make sure the string is null terminated
+	str->str_info.length = count;
+
+	rc = write_relation(RL_LOG, str, cprov, NULL, 0);
+out:
+	free_long_provenance(str);
+	if (rc < 0)
+		return rc;
+	return count;
+}
+
+static inline int __update_version(const uint64_t type, struct provenance *prov)
+{
+	union prov_elt old_prov;
+	int rc = 0;
+
+	// there is no outgoing edge and we are compressing
+	if (!prov->has_outgoing && prov_policy.should_compress_node)
+		return 0;
+	// are we recording this type
+	if (filter_update_node(type))
+		return 0;
+	// copy provenance to old
+	memcpy(&old_prov, prov_elt(prov), sizeof(old_prov));
+	// update version
+	node_identifier(prov_elt(prov)).version++;
+	clear_recorded(prov_elt(prov));
+
+	// record version relation between version
+	if (node_identifier(prov_elt(prov)).type == ACT_TASK)
+		rc = write_relation(RL_VERSION_PROCESS, &old_prov, prov_elt(prov), NULL, 0);
+	else
+		rc = write_relation(RL_VERSION, &old_prov, prov_elt(prov), NULL, 0);
+	prov->has_outgoing = false; // we update there is no more outgoing edge
+	prov->saved = false; // for inode prov persistance
+	return rc;
+}
+
+static inline int record_relation(const uint64_t type,
+				  struct provenance *from,
+				  struct provenance *to,
+				  const struct file *file,
+				  const uint64_t flags)
+{
+	int rc = 0;
+
+	// check if the nodes match some capture options
+	apply_target(prov_elt(from));
+	apply_target(prov_elt(to));
+
+	if (!provenance_is_tracked(prov_elt(from)) && !provenance_is_tracked(prov_elt(to)) && !prov_policy.prov_all)
+		return 0;
+	if (!should_record_relation(type, prov_entry(from), prov_entry(to)))
+		return 0;
+
+	if (prov_policy.should_compress_edge){
+		// we compress edges, do not record same edge type twice
+		if(to->previous_id == node_identifier(prov_entry(from)).id
+				&& to->previous_type == type){
+			return 0;
+		} else { // if not we save those information
+			to->previous_id = node_identifier(prov_entry(from)).id;
+			to->previous_type = type;
+		}
+	}
+
+	rc = __update_version(type, to);
+	if (rc < 0)
+		return rc;
+
+	rc = write_relation(type, prov_elt(from), prov_elt(to), file, flags);
+	from->has_outgoing = true; // there is an outgoing edge
+	return rc;
+}
+
+static inline void current_update_shst(struct provenance *cprov);
+
+// from (entity) to (activity)
+static __always_inline int uses(const uint64_t type,
+				struct provenance *from,
+				struct provenance *to,
+				const struct file *file,
+				const uint64_t flags)
+{
+	int rc;
+	BUILD_BUG_ON(!prov_is_used(type));
+	rc = record_relation(type, from, to, file, flags);
+	if (should_record_relation(type, prov_entry(from), prov_entry(to)))
+		to->updt_mmap = true;
+	return rc;
+}
+
+// from (activity) to (entity)
+static __always_inline int generates(const uint64_t type,
+				     struct provenance *from,
+				     struct provenance *to,
+				     const struct file *file,
+				     const uint64_t flags)
+{
+	BUILD_BUG_ON(!prov_is_generated(type));
+	return record_relation(type, from, to, file, flags);
+}
+
+// from (entity) to (entity)
+static __always_inline int derives(const uint64_t type,
+				   struct provenance *from,
+				   struct provenance *to,
+				   const struct file *file,
+				   const uint64_t flags)
+{
+	BUILD_BUG_ON(!prov_is_derived(type));
+	return record_relation(type, from, to, file, flags);
+}
+
+// from (activity) to (activity)
+static __always_inline int informs(const uint64_t type,
+				   struct provenance *from,
+				   struct provenance *to,
+				   const struct file *file,
+				   const uint64_t flags)
+{
+	BUILD_BUG_ON(!prov_is_informed(type));
+	return record_relation(type, from, to, file, flags);
+}
+#endif
diff -uprN -b -B ./pristine/linux-4.14.9/security/provenance/include/provenance_relay.h ./linux-4.14.9/security/provenance/include/provenance_relay.h
--- ./pristine/linux-4.14.9/security/provenance/include/provenance_relay.h	1970-01-01 01:00:00.000000000 +0100
+++ ./linux-4.14.9/security/provenance/include/provenance_relay.h	2017-12-27 19:40:12.202134590 +0000
@@ -0,0 +1,172 @@
+/*
+ *
+ * Author: Thomas Pasquier <tfjmp@seas.harvard.edu>
+ *
+ * Copyright (C) 2015-2017 University of Cambridge, Harvard University
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2, as
+ * published by the Free Software Foundation; either version 2 of the License,
+ * or (at your option) any later version.
+ *
+ */
+#ifndef _PROVENANCE_RELAY_H
+#define _PROVENANCE_RELAY_H
+
+#include <linux/relay.h>
+#include <linux/spinlock.h>
+#include <linux/jiffies.h>
+
+#include "provenance_filter.h"
+#include "provenance_query.h"
+
+#define PROV_RELAY_BUFF_EXP         22 // 4MB
+#define PROV_RELAY_BUFF_SIZE        ((1 << PROV_RELAY_BUFF_EXP) * sizeof(uint8_t))
+#define PROV_NB_SUBBUF              32
+#define PROV_INITIAL_BUFF_SIZE      (1024 * 4)
+#define PROV_INITIAL_LONG_BUFF_SIZE 256
+
+extern bool relay_ready;
+
+struct relay_list {
+	struct list_head list;
+	char *name;
+	struct rchan *prov;
+	struct rchan *long_prov;
+};
+
+extern struct list_head relay_list;
+
+int prov_create_channel(char *buffer, size_t len);
+
+static inline void prov_add_relay(char *name, struct rchan *prov, struct rchan *long_prov)
+{
+	struct relay_list *list;
+
+	list = kzalloc(sizeof(struct relay_list), GFP_KERNEL);
+	list->name = name;
+	list->prov = prov;
+	list->long_prov = long_prov;
+	list_add_tail(&(list->list), &relay_list);
+}
+
+struct prov_boot_buffer {
+	union prov_elt buffer[PROV_INITIAL_BUFF_SIZE];
+	uint32_t nb_entry;
+};
+
+struct prov_long_boot_buffer {
+	union long_prov_elt buffer[PROV_INITIAL_LONG_BUFF_SIZE];
+	uint32_t nb_entry;
+};
+
+extern struct prov_boot_buffer *boot_buffer;
+
+static inline void prov_write(union prov_elt *msg)
+{
+	struct relay_list *tmp;
+	union prov_elt *provtmp;
+
+	prov_jiffies(msg) = get_jiffies_64();
+	if (unlikely(!relay_ready)) {
+		if (likely(boot_buffer->nb_entry < PROV_INITIAL_BUFF_SIZE)) {
+			provtmp = &(boot_buffer->buffer[boot_buffer->nb_entry]);
+			memcpy(provtmp, msg, sizeof(union prov_elt));
+			boot_buffer->nb_entry++;
+		} else
+			pr_err("Provenance: boot buffer is full.\n");
+	} else {
+		list_for_each_entry(tmp, &relay_list, list) {
+			relay_write(tmp->prov, msg, sizeof(union prov_elt));
+		}
+	}
+}
+
+
+extern struct prov_long_boot_buffer *long_boot_buffer;
+
+static inline void long_prov_write(union long_prov_elt *msg)
+{
+	struct relay_list *tmp;
+	union long_prov_elt *provtmp;
+
+	prov_jiffies(msg) = get_jiffies_64();
+	if (unlikely(!relay_ready)) {
+		if (likely(long_boot_buffer->nb_entry < PROV_INITIAL_LONG_BUFF_SIZE)) {
+			provtmp = &(long_boot_buffer->buffer[long_boot_buffer->nb_entry]);
+			memcpy(provtmp, msg, sizeof(union long_prov_elt));
+			long_boot_buffer->nb_entry++;
+		} else
+			pr_err("Provenance: long boot buffer is full.\n");
+	} else {
+		list_for_each_entry(tmp, &relay_list, list) {
+			relay_write(tmp->long_prov, msg, sizeof(union long_prov_elt));
+		}
+	}
+}
+
+/* force sub-buffer switch */
+static inline void prov_flush(void)
+{
+	struct relay_list *tmp;
+
+	if (unlikely(!relay_ready)) {
+		list_for_each_entry(tmp, &relay_list, list) {
+			relay_flush(tmp->prov);
+			relay_flush(tmp->long_prov);
+		}
+	}
+}
+
+static inline void __write_node(prov_entry_t *node)
+{
+	if (filter_node(node) || provenance_is_recorded(node))   // filtered or already recorded
+		return;
+	set_recorded(node);
+	if ( provenance_is_long(node) ) {
+		long_prov_write(node);
+	} else {
+		if(!prov_is_packet(node))
+			node_identifier(node).machine_id = prov_machine_id;
+		prov_write((union prov_elt*)node);
+	}
+}
+
+static inline void copy_identifier(union prov_identifier *dest, union prov_identifier *src)
+{
+	memcpy(dest, src, sizeof(union prov_identifier));
+}
+
+static inline int write_relation(const uint64_t type,
+				 void *from,
+				 void *to,
+				 const struct file *file,
+				 const uint64_t flags)
+{
+	union prov_elt relation;
+	prov_entry_t *f = from;
+	prov_entry_t *t = to;
+	int rc = 0;
+
+	if (!should_record_relation(type, f, t))
+		return 0;
+
+	memset(&relation, 0, sizeof(union prov_elt));
+	prov_type(&relation) = type;
+	relation_identifier(&relation).id = prov_next_id();
+	relation_identifier(&relation).boot_id = prov_boot_id;
+	relation_identifier(&relation).machine_id = prov_machine_id;
+	copy_identifier(&relation.relation_info.snd, &get_prov_identifier(f));
+	copy_identifier(&relation.relation_info.rcv, &get_prov_identifier(t));
+	if (file) {
+		relation.relation_info.set = FILE_INFO_SET;
+		relation.relation_info.offset = file->f_pos;
+	}
+	relation.relation_info.flags = flags;
+	rc = call_query_hooks(f, t, (prov_entry_t*)&relation);
+	__write_node(f);
+	__write_node(t);
+	prov_write(&relation);
+	return rc;
+}
+#endif
diff -uprN -b -B ./pristine/linux-4.14.9/security/provenance/include/provenance_task.h ./linux-4.14.9/security/provenance/include/provenance_task.h
--- ./pristine/linux-4.14.9/security/provenance/include/provenance_task.h	1970-01-01 01:00:00.000000000 +0100
+++ ./linux-4.14.9/security/provenance/include/provenance_task.h	2017-12-27 19:40:12.203134599 +0000
@@ -0,0 +1,521 @@
+/*
+ *
+ * Author: Thomas Pasquier <tfjmp@seas.harvard.edu>
+ *
+ * Copyright (C) 2015-2017 University of Cambridge, Harvard University
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2, as
+ * published by the Free Software Foundation; either version 2 of the License,
+ * or (at your option) any later version.
+ *
+ */
+#ifndef _PROVENANCE_TASK_H
+#define _PROVENANCE_TASK_H
+
+#include <linux/cred.h>
+#include <linux/binfmts.h>
+#include <linux/sched.h>
+#include <linux/sched/task.h>
+#include <linux/sched/mm.h>
+#include <linux/sched/signal.h>
+#include <linux/utsname.h>
+#include <linux/ipc_namespace.h>
+#include <linux/mnt_namespace.h>
+#include <linux/mm.h> // used for get_page
+#include <net/net_namespace.h>
+#include <linux/pid_namespace.h>
+#include <linux/sched/cputime.h>
+#include "../../../fs/mount.h" // nasty
+
+#include "provenance_relay.h"
+#include "provenance_inode.h"
+#include "provenance_policy.h"
+
+#define KB 1024
+#define MB (1024 * KB)
+#define KB_MASK (~(KB - 1))
+
+#define current_pid() (current->pid)
+static inline uint32_t current_cgroupns(void)
+{
+	uint32_t id = 0;
+	struct cgroup_namespace *cns;
+
+	task_lock(current);
+	if (current->nsproxy) {
+		cns = current->nsproxy->cgroup_ns;
+		if (cns) {
+			get_cgroup_ns(cns);
+			id = cns->ns.inum;
+			put_cgroup_ns(cns);
+		}
+	}
+	task_unlock(current);
+	return id;
+}
+
+static inline uint32_t current_utsns(void)
+{
+	uint32_t id = 0;
+	struct uts_namespace *ns;
+
+	task_lock(current);
+	if (current->nsproxy) {
+		ns = current->nsproxy->uts_ns;
+		if (ns) {
+			get_uts_ns(ns);
+			id = ns->ns.inum;
+			put_uts_ns(ns);
+		}
+	}
+	task_unlock(current);
+	return id;
+}
+
+static inline uint32_t current_ipcns(void)
+{
+	uint32_t id = 0;
+	struct ipc_namespace *ns;
+
+	task_lock(current);
+	if (current->nsproxy) {
+		ns = current->nsproxy->ipc_ns;
+		if (ns) {
+			get_ipc_ns(ns);
+			id = ns->ns.inum;
+			put_ipc_ns(ns);
+		}
+	}
+	task_unlock(current);
+	return id;
+}
+
+static inline uint32_t current_mntns(void)
+{
+	uint32_t id = 0;
+	struct mnt_namespace *ns;
+
+	task_lock(current);
+	if (current->nsproxy) {
+		ns = current->nsproxy->mnt_ns;
+		if (ns) {
+			get_mnt_ns(ns);
+			id = ns->ns.inum;
+			put_mnt_ns(ns);
+		}
+	}
+	task_unlock(current);
+	return id;
+}
+
+static inline uint32_t current_netns(void)
+{
+	uint32_t id = 0;
+	struct net *ns;
+
+	task_lock(current);
+	if (current->nsproxy) {
+		ns = current->nsproxy->net_ns;
+		if (ns) {
+			get_net(ns);
+			id = ns->ns.inum;
+			put_net(ns);
+		}
+	}
+	task_unlock(current);
+	return id;
+}
+
+static inline uint32_t current_pidns(void)
+{
+	uint32_t id = 0;
+	struct pid_namespace *ns;
+
+	task_lock(current);
+	ns = task_active_pid_ns(current);
+	if (ns)
+		id = ns->ns.inum;
+	task_unlock(current);
+	return id;
+}
+
+#define vm_write(flags)   ((flags & VM_WRITE) == VM_WRITE)
+#define vm_read(flags)    ((flags & VM_READ) == VM_READ)
+#define vm_exec(flags)    ((flags & VM_EXEC) == VM_EXEC)
+#define vm_mayshare(flags) ((flags & (VM_SHARED | VM_MAYSHARE)) != 0)
+#define vm_write_mayshare(flags) (vm_write(flags) && vm_mayshare(flags))
+#define vm_read_exec_mayshare(flags) ((vm_write(flags) || vm_exec(flags)) && vm_mayshare(flags))
+
+// write <- are we reading or writting from shared state
+static inline void current_update_shst(struct provenance *cprov)
+{
+	struct mm_struct *mm = get_task_mm(current);
+	struct vm_area_struct *vma;
+	struct file *mmapf;
+	vm_flags_t flags;
+	struct provenance *mmprov;
+
+	if (!mm)
+		return;
+	cprov->has_mmap = false;
+	vma = mm->mmap;
+	while (vma) { // we go through mmaped files
+		mmapf = vma->vm_file;
+		if (mmapf) {
+			flags = vma->vm_flags;
+			mmprov = file_provenance(mmapf, false);
+			if (mmprov) {
+				cprov->has_mmap = true;
+				spin_lock_nested(prov_lock(mmprov), PROVENANCE_LOCK_INODE);
+				if (vm_read_exec_mayshare(flags))
+					record_relation(RL_SH_READ, mmprov, cprov, mmapf, flags);
+				if (vm_write_mayshare(flags))
+					record_relation(RL_SH_WRITE, cprov, mmprov, mmapf, flags);
+				spin_unlock(prov_lock(mmprov));
+			}
+		}
+		vma = vma->vm_next;
+	}
+	mmput_async(mm);
+}
+
+static inline int record_task_name(struct task_struct *task,
+				   struct provenance *prov)
+{
+	const struct cred *cred;
+	struct provenance *fprov;
+	struct mm_struct *mm;
+	struct file *exe_file;
+	char *buffer;
+	char *ptr;
+	int rc = 0;
+
+	if (provenance_is_name_recorded(prov_elt(prov)) ||
+	    !provenance_is_recorded(prov_elt(prov)))
+		return 0;
+	cred = get_task_cred(task);
+	if (!cred)
+		return rc;
+	mm = get_task_mm(task);
+	if (!mm)
+		goto out;
+	exe_file = get_mm_exe_file(mm);
+	mmput_async(mm);
+	if (exe_file) {
+		fprov = file_provenance(exe_file, false);
+		if (provenance_is_opaque(prov_elt(fprov))) {
+			set_opaque(prov_elt(prov));
+			goto out;
+		}
+		// should not sleep
+		buffer = kcalloc(PATH_MAX, sizeof(char), GFP_ATOMIC);
+		if (!buffer) {
+			pr_err("Provenance: could not allocate memory\n");
+			fput(exe_file);
+			goto out;
+		}
+		ptr = file_path(exe_file, buffer, PATH_MAX);
+		fput(exe_file);
+		rc = record_node_name(prov, ptr);
+		kfree(buffer);
+	}
+out:
+	put_cred(cred);
+	return rc;
+}
+
+static inline void update_task_perf(struct task_struct *task,
+				    struct provenance *prov)
+{
+	struct mm_struct *mm;
+	uint64_t utime;
+	uint64_t stime;
+
+	/* time */
+	/* usec */
+	task_cputime_adjusted(task, &utime, &stime);
+	prov_elt(prov)->task_info.utime = div_u64(utime, NSEC_PER_USEC);
+	prov_elt(prov)->task_info.stime = div_u64(stime, NSEC_PER_USEC);
+
+	/* memory */
+	mm = get_task_mm(current);
+	if (mm) {
+		/* KB */
+		prov_elt(prov)->task_info.vm =  mm->total_vm  * PAGE_SIZE / KB;
+		prov_elt(prov)->task_info.rss = get_mm_rss(mm) * PAGE_SIZE / KB;
+		prov_elt(prov)->task_info.hw_vm = get_mm_hiwater_vm(mm) * PAGE_SIZE / KB;
+		prov_elt(prov)->task_info.hw_rss = get_mm_hiwater_rss(mm) * PAGE_SIZE / KB;
+		mmput_async(mm);
+	}
+	/* IO */
+#ifdef CONFIG_TASK_IO_ACCOUNTING
+	/* KB */
+	prov_elt(prov)->task_info.rbytes = task->ioac.read_bytes & KB_MASK;
+	prov_elt(prov)->task_info.wbytes = task->ioac.write_bytes & KB_MASK;
+	prov_elt(prov)->task_info.cancel_wbytes =
+		task->ioac.cancelled_write_bytes & KB_MASK;
+#else
+	/* KB */
+	prov_elt(prov)->task_info.rbytes = task->ioac.rchar & KB_MASK;
+	prov_elt(prov)->task_info.wbytes = task->ioac.wchar & KB_MASK;
+	prov_elt(prov)->task_info.cancel_wbytes = 0;
+#endif
+}
+
+static inline struct provenance *get_current_provenance(void)
+{
+	struct provenance *prov = current_provenance();
+	unsigned long irqflags;
+
+	// will not be recorded
+	if (provenance_is_opaque(prov_elt(prov)))
+		goto out;
+	record_task_name(current, prov);
+	spin_lock_irqsave_nested(prov_lock(prov), irqflags, PROVENANCE_LOCK_TASK);
+	prov_elt(prov)->task_info.pid = task_pid_nr(current);
+	prov_elt(prov)->task_info.vpid = task_pid_vnr(current);
+	prov_elt(prov)->task_info.ppid = task_ppid_nr(current);
+	prov_elt(prov)->task_info.tgid = task_tgid_nr(current);
+	prov_elt(prov)->task_info.utsns = current_utsns();
+	prov_elt(prov)->task_info.ipcns = current_ipcns();
+	prov_elt(prov)->task_info.mntns = current_mntns();
+	prov_elt(prov)->task_info.pidns = current_pidns();
+	prov_elt(prov)->task_info.netns = current_netns();
+	prov_elt(prov)->task_info.cgroupns = current_cgroupns();
+	security_task_getsecid(current, &(prov_elt(prov)->task_info.secid));
+	update_task_perf(current, prov);
+	if (prov->updt_mmap && prov->has_mmap) {
+		current_update_shst(prov);
+		prov->updt_mmap = false;
+	}
+	spin_unlock_irqrestore(prov_lock(prov), irqflags);
+out:
+	return prov;
+}
+
+static inline struct provenance *prov_from_vpid(pid_t pid)
+{
+	struct provenance *tprov;
+	struct task_struct *dest = find_task_by_vpid(pid);
+
+	if (!dest)
+		return NULL;
+
+	tprov = __task_cred(dest)->provenance;
+	if (!tprov)
+		return NULL;
+	return tprov;
+}
+
+static inline int terminate_task(struct provenance *tprov)
+{
+	union prov_elt old_prov;
+	int rc;
+
+	if (!provenance_is_tracked(prov_elt(tprov)) && !prov_policy.prov_all)
+		return 0;
+	if (filter_node(prov_entry(tprov)))
+		return 0;
+	memcpy(&old_prov, prov_elt(tprov), sizeof(old_prov));
+	node_identifier(prov_elt(tprov)).version++;
+	clear_recorded(prov_elt(tprov));
+
+	rc = write_relation(RL_TERMINATE_PROCESS, &old_prov, prov_elt(tprov), NULL, 0);
+	tprov->has_outgoing = false;
+	return rc;
+}
+
+/* see fs/exec.c */
+static inline void acct_arg_size(struct linux_binprm *bprm, unsigned long pages)
+{
+	struct mm_struct *mm = current->mm;
+	long diff = (long)(pages - bprm->vma_pages);
+
+	if (!mm || !diff)
+		return;
+
+	bprm->vma_pages = pages;
+	add_mm_counter(mm, MM_ANONPAGES, diff);
+}
+
+/* see fs/exec.c */
+static inline struct page *get_arg_page(struct linux_binprm *bprm,
+					unsigned long pos,
+					int write)
+{
+	struct page *page;
+	int ret;
+	unsigned int gup_flags = FOLL_FORCE;
+
+#ifdef CONFIG_STACK_GROWSUP
+	if (write) {
+		ret = expand_downwards(bprm->vma, pos);
+		if (ret < 0)
+			return NULL;
+	}
+#endif
+
+	if (write)
+		gup_flags |= FOLL_WRITE;
+
+	/*
+	 * We are doing an exec().  'current' is the process
+	 * doing the exec and bprm->mm is the new process's mm.
+	 */
+	ret = get_user_pages_remote(current, bprm->mm, pos, 1, gup_flags,
+				    &page, NULL, NULL);
+	if (ret <= 0)
+		return NULL;
+
+	if (write) {
+		unsigned long size = bprm->vma->vm_end - bprm->vma->vm_start;
+		unsigned long ptr_size;
+		struct rlimit *rlim;
+
+		/*
+		 * Since the stack will hold pointers to the strings, we
+		 * must account for them as well.
+		 *
+		 * The size calculation is the entire vma while each arg page is
+		 * built, so each time we get here it's calculating how far it
+		 * is currently (rather than each call being just the newly
+		 * added size from the arg page).  As a result, we need to
+		 * always add the entire size of the pointers, so that on the
+		 * last call to get_arg_page() we'll actually have the entire
+		 * correct size.
+		 */
+		ptr_size = (bprm->argc + bprm->envc) * sizeof(void *);
+		if (ptr_size > ULONG_MAX - size)
+			goto fail;
+		size += ptr_size;
+
+		acct_arg_size(bprm, size / PAGE_SIZE);
+
+		/*
+		 * We've historically supported up to 32 pages (ARG_MAX)
+		 * of argument strings even with small stacks
+		 */
+		if (size <= ARG_MAX)
+			return page;
+
+		/*
+		 * Limit to 1/4-th the stack size for the argv+env strings.
+		 * This ensures that:
+		 *  - the remaining binfmt code will not run out of stack space,
+		 *  - the program will have a reasonable amount of stack left
+		 *    to work from.
+		 */
+		rlim = current->signal->rlim;
+		if (size > READ_ONCE(rlim[RLIMIT_STACK].rlim_cur) / 4)
+			goto fail;
+	}
+
+	return page;
+
+fail:
+	put_page(page);
+	return NULL;
+}
+
+/* see fs/exec.c */
+static inline int copy_argv_bprm(struct linux_binprm *bprm, char *buff,
+				 unsigned long len)
+{
+	int rv = 0;
+	unsigned long ofs, bytes;
+	struct page *page = NULL, *new_page;
+	const char *kaddr;
+	unsigned long src;
+
+	src = bprm->p;
+	ofs = src % PAGE_SIZE;
+	while (len) {
+		new_page = get_arg_page(bprm, src, 0);
+		if (!new_page) {
+			rv = -E2BIG;
+			goto out;
+		}
+		if (page) {
+			kunmap(page);
+			put_page(page);
+		}
+		page = new_page;
+		kaddr = kmap(page);
+		flush_cache_page(bprm->vma, ofs, page_to_pfn(page));
+		bytes = min_t(unsigned int, len, PAGE_SIZE - ofs);
+		memcpy(buff, kaddr + ofs, bytes);
+		src += bytes;
+		buff += bytes;
+		len -= bytes;
+		ofs = 0;
+	}
+	rv = src - bprm->p;
+out:
+	if (page) {
+		kunmap(page);
+		put_page(page);
+	}
+	return rv;
+}
+
+static inline int prov_record_arg(struct provenance *prov,
+				  uint64_t vtype,
+				  uint64_t etype,
+				  const char *arg,
+				  size_t len)
+{
+	union long_prov_elt *aprov;
+	int rc = 0;
+
+	aprov  = alloc_long_provenance(vtype);
+	if (!aprov)
+		return -ENOMEM;
+	aprov->arg_info.length = len;
+	if ( len >= PATH_MAX)
+		aprov->arg_info.truncated = PROV_TRUNCATED;
+	strlcpy(aprov->arg_info.value, arg, PATH_MAX - 1);
+
+	rc = write_relation(etype, aprov, prov_elt(prov), NULL, 0);
+	free_long_provenance(aprov);
+	return rc;
+}
+
+static inline int prov_record_args(struct provenance *prov,
+				   struct linux_binprm *bprm)
+{
+	char* argv;
+	char* ptr;
+	unsigned long len;
+	size_t size;
+	int rc = 0;
+	int argc;
+	int envc;
+
+	// we are not tracked, no need to register parameters
+	if (!provenance_is_tracked(prov_elt(prov)) && !prov_policy.prov_all)
+		return 0;
+	len = bprm->exec - bprm->p;
+	argv = kzalloc(len, GFP_KERNEL);
+	if (!argv)
+		return -ENOMEM;
+	rc = copy_argv_bprm(bprm, argv, len);
+	if (rc < 0)
+		return -ENOMEM;
+	argc = bprm->argc;
+	envc = bprm->envc;
+	ptr = argv;
+	while (argc-- > 0) {
+		size = strnlen(ptr, len);
+		prov_record_arg(prov, ENT_ARG, RL_ARG, ptr, size);
+		ptr += size + 1;
+	}
+	while (envc-- > 0) {
+		size = strnlen(ptr, len);
+		prov_record_arg(prov, ENT_ENV, RL_ENV, ptr, size);
+		ptr += size + 1;
+	}
+	kfree(argv);
+	return 0;
+}
+#endif
diff -uprN -b -B ./pristine/linux-4.14.9/security/provenance/include/provenance_types.h ./linux-4.14.9/security/provenance/include/provenance_types.h
--- ./pristine/linux-4.14.9/security/provenance/include/provenance_types.h	1970-01-01 01:00:00.000000000 +0100
+++ ./linux-4.14.9/security/provenance/include/provenance_types.h	2017-12-27 19:40:12.203134599 +0000
@@ -0,0 +1,21 @@
+/*
+ *
+ * Author: Thomas Pasquier <tfjmp@g.harvard.edu>
+ *
+ * Copyright (C) 2015-2017 University of Cambridge, Harvard University
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2, as
+ * published by the Free Software Foundation; either version 2 of the License,
+ * or (at your option) any later version.
+ *
+ */
+#ifndef _PROVENANCE_TYPES_H
+#define _PROVENANCE_TYPES_H
+
+const char* relation_str(uint64_t type);
+uint64_t relation_id(const char* str);
+const char* node_str(uint64_t type);
+uint64_t node_id(const char* str);
+
+#endif /* _PROVENANCE_TYPES_H */
diff -uprN -b -B ./pristine/linux-4.14.9/security/provenance/Kconfig ./linux-4.14.9/security/provenance/Kconfig
--- ./pristine/linux-4.14.9/security/provenance/Kconfig	1970-01-01 01:00:00.000000000 +0100
+++ ./linux-4.14.9/security/provenance/Kconfig	2017-12-27 19:40:12.200134572 +0000
@@ -0,0 +1,29 @@
+config SECURITY_PROVENANCE
+         bool "CamFlow - Provenance"
+         depends on SECURITY
+         select RELAY
+         select SECURITYFS
+         select NETFILTER
+         select CRYPTO_SHA256
+         default y
+         help
+          This selects CamFlow provenance modules. It captures provenance through
+          a Linux Security Module.
+
+config SECURITY_PROVENANCE_WHOLE_SYSTEM
+	bool "CamFlow - Whole system provenance"
+	depends on SECURITY_PROVENANCE
+	default n
+	help
+	  This option activate whole system provenance capture from boot.
+
+	  If you are unsure how to answer this question, answer N.
+
+config SECURITY_PROVENANCE_PERSISTENCE
+	bool "CamFlow - Persistence"
+	depends on SECURITY_PROVENANCE
+	default n
+	help
+	  This option persist inode provenance state across reboot.
+
+	  If you are unsure how to answer this question, answer N.
diff -uprN -b -B ./pristine/linux-4.14.9/security/provenance/Makefile ./linux-4.14.9/security/provenance/Makefile
--- ./pristine/linux-4.14.9/security/provenance/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ ./linux-4.14.9/security/provenance/Makefile	2017-12-27 19:40:12.200134572 +0000
@@ -0,0 +1,8 @@
+#
+# Makefile for Provenance LSM
+#
+obj-$(CONFIG_SECURITY_PROVENANCE) := provenance.o
+
+provenance-y := relay.o hooks.o query.o fs.o netfilter.o propagate.o type.o
+
+ccflags-y := -I$(srctree)/security/provenance/include
diff -uprN -b -B ./pristine/linux-4.14.9/security/provenance/netfilter.c ./linux-4.14.9/security/provenance/netfilter.c
--- ./pristine/linux-4.14.9/security/provenance/netfilter.c	1970-01-01 01:00:00.000000000 +0100
+++ ./linux-4.14.9/security/provenance/netfilter.c	2017-12-27 19:40:12.203134599 +0000
@@ -0,0 +1,88 @@
+/*
+ *
+ * Author: Thomas Pasquier <tfjmp@seas.harvard.edu>
+ *
+ * Copyright (C) 2015-2017 University of Cambridge, Harvard University
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2, as
+ * published by the Free Software Foundation; either version 2 of the License,
+ * or (at your option) any later version.
+ *
+ */
+#include <net/net_namespace.h>
+
+#include "provenance.h"
+#include "provenance_net.h"
+#include "provenance_task.h"
+
+static inline unsigned int __ipv4_out(struct sk_buff *skb)
+{
+	struct provenance *cprov = current_provenance();
+	struct provenance *iprov = NULL;
+	union prov_elt pckprov;
+	unsigned long irqflags;
+
+	if (!cprov)
+		return NF_ACCEPT;
+
+	if (provenance_is_tracked(prov_elt(cprov))) {
+		iprov = sk_inode_provenance(skb->sk);
+		if (!iprov)
+			return NF_ACCEPT;
+		provenance_parse_skb_ipv4(skb, &pckprov);
+		spin_lock_irqsave_nested(prov_lock(cprov), irqflags, PROVENANCE_LOCK_TASK);
+		spin_lock_nested(prov_lock(iprov), PROVENANCE_LOCK_INODE);
+		record_inode_to_pck(iprov, &pckprov);
+		if (provenance_records_packet(prov_elt(iprov)))
+			record_packet_content(&pckprov, skb);
+		spin_unlock(prov_lock(iprov));
+		spin_unlock_irqrestore(prov_lock(cprov), irqflags);
+	}
+	return NF_ACCEPT;
+}
+
+static unsigned int provenance_ipv4_out(void *priv,
+					struct sk_buff *skb,
+					const struct nf_hook_state *state)
+{
+	return __ipv4_out(skb);
+}
+
+static struct nf_hook_ops provenance_nf_ops[] = {
+	{
+		.hook = provenance_ipv4_out,
+		.pf = NFPROTO_IPV4,
+		.hooknum = NF_INET_LOCAL_OUT,
+		.priority = NF_IP_PRI_LAST,
+	},
+};
+
+// will initialise the hooks
+static int __net_init provenance_nf_register(struct net *net)
+{
+	return nf_register_net_hooks(net, provenance_nf_ops, ARRAY_SIZE(provenance_nf_ops));
+}
+
+static void __net_exit provenance_nf_unregister(struct net *net)
+{
+	nf_unregister_net_hooks(net, provenance_nf_ops, ARRAY_SIZE(provenance_nf_ops));
+}
+
+static struct pernet_operations provenance_net_ops = {
+	.init	= provenance_nf_register,
+	.exit	= provenance_nf_unregister,
+};
+
+static int __init provenance_nf_ip_init(void)
+{
+	int err;
+
+	pr_info("Provenance: registering netfilter hooks.\n");
+	err = register_pernet_subsys(&provenance_net_ops);
+	if (err)
+		panic("Provenance: register_pernet_subsys error %d\n", err);
+	return 0;
+}
+
+__initcall(provenance_nf_ip_init);
diff -uprN -b -B ./pristine/linux-4.14.9/security/provenance/propagate.c ./linux-4.14.9/security/provenance/propagate.c
--- ./pristine/linux-4.14.9/security/provenance/propagate.c	1970-01-01 01:00:00.000000000 +0100
+++ ./linux-4.14.9/security/provenance/propagate.c	2017-12-27 19:40:12.203134599 +0000
@@ -0,0 +1,51 @@
+/*
+ *
+ * Author: Thomas Pasquier <tfjmp@g.harvard.edu>
+ *
+ * Copyright (C) 2015-2017 University of Cambridge, Harvard University
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2, as
+ * published by the Free Software Foundation; either version 2 of the License,
+ * or (at your option) any later version.
+ *
+ */
+#include "provenance.h"
+#include "provenance_query.h"
+
+static int out_edge(prov_entry_t *node, prov_entry_t *edge)
+{
+	if (provenance_does_propagate(node) && provenance_is_tracked(node)) {
+		// can propagate over edge?
+		if (!filter_propagate_relation(prov_type(edge))) {
+			set_tracked(edge);
+			set_propagate(edge);
+		}
+	}
+	return 0;
+}
+
+static int in_edge(prov_entry_t *edge, prov_entry_t *node)
+{
+	if (provenance_does_propagate(edge) && provenance_is_tracked(edge)) {
+		// can propagate to node?
+		if (!filter_propagate_node(node)) {
+			set_tracked(node);
+			set_propagate(node);
+		}
+	}
+	return 0;
+}
+
+struct provenance_query_hooks hooks = {
+	QUERY_HOOK_INIT(out_edge, out_edge),
+	QUERY_HOOK_INIT(in_edge,  in_edge),
+};
+
+static int __init init_prov_propagate(void)
+{
+	register_provenance_query_hooks(&hooks);
+	pr_info("Provenance: propagate ready.\n");
+	return 0;
+}
+security_initcall(init_prov_propagate);
diff -uprN -b -B ./pristine/linux-4.14.9/security/provenance/query.c ./linux-4.14.9/security/provenance/query.c
--- ./pristine/linux-4.14.9/security/provenance/query.c	1970-01-01 01:00:00.000000000 +0100
+++ ./linux-4.14.9/security/provenance/query.c	2017-12-27 19:40:12.204134608 +0000
@@ -0,0 +1,32 @@
+/*
+ *
+ * Author: Thomas Pasquier <tfjmp@g.harvard.edu>
+ *
+ * Copyright (C) 2015-2017 University of Cambridge, Harvard University
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2, as
+ * published by the Free Software Foundation; either version 2 of the License,
+ * or (at your option) any later version.
+ *
+ */
+#include <linux/rculist.h>
+
+#include "provenance_query.h"
+
+int register_provenance_query_hooks(struct provenance_query_hooks *hook)
+{
+	if (!hook)
+		return -ENOMEM;
+	pr_info("Provenance: registering policy hook...\n");
+	list_add_tail_rcu(&(hook->list), &provenance_query_hooks);
+	return 0;
+}
+EXPORT_SYMBOL_GPL(register_provenance_query_hooks);
+
+int unregister_provenance_query_hooks(struct provenance_query_hooks *hook)
+{
+	list_del_rcu(&(hook->list));
+	return 0;
+}
+EXPORT_SYMBOL_GPL(unregister_provenance_query_hooks);
diff -uprN -b -B ./pristine/linux-4.14.9/security/provenance/relay.c ./linux-4.14.9/security/provenance/relay.c
--- ./pristine/linux-4.14.9/security/provenance/relay.c	1970-01-01 01:00:00.000000000 +0100
+++ ./linux-4.14.9/security/provenance/relay.c	2017-12-27 19:40:12.204134608 +0000
@@ -0,0 +1,126 @@
+/*
+ *
+ * Author: Thomas Pasquier <thomas.pasquier@cl.cam.ac.uk>
+ *
+ * Copyright (C) 2015-2017 University of Cambridge, Harvard University
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2, as
+ * published by the Free Software Foundation; either version 2 of the License,
+ * or (at your option) any later version.
+ *
+ */
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/debugfs.h>
+
+#include "provenance.h"
+#include "provenance_relay.h"
+
+#define PROV_BASE_NAME "provenance"
+#define LONG_PROV_BASE_NAME "long_provenance"
+
+/* global variable, extern in provenance.h */
+static struct rchan *prov_chan;
+static struct rchan *long_prov_chan;
+atomic64_t prov_id = ATOMIC64_INIT(0);
+
+/*
+ * create_buf_file() callback.  Creates relay file in debugfs.
+ */
+static struct dentry *create_buf_file_handler(const char *filename,
+					      struct dentry *parent,
+					      umode_t mode,
+					      struct rchan_buf *buf,
+					      int *is_global)
+{
+	return debugfs_create_file(filename, mode, parent, buf,
+				   &relay_file_operations);
+}
+
+/*
+ * remove_buf_file() callback.  Removes relay file from debugfs.
+ */
+static int remove_buf_file_handler(struct dentry *dentry)
+{
+	debugfs_remove(dentry);
+	return 0;
+}
+
+/*
+ * relay interface callbacks
+ */
+static struct rchan_callbacks relay_callbacks = {
+
+	.create_buf_file	= create_buf_file_handler,
+	.remove_buf_file	= remove_buf_file_handler,
+};
+
+static void write_boot_buffer(void)
+{
+	if (boot_buffer->nb_entry > 0)
+		relay_write(prov_chan, boot_buffer->buffer, boot_buffer->nb_entry * sizeof(union prov_elt));
+	kfree(boot_buffer);
+	boot_buffer = NULL;
+
+	if (long_boot_buffer->nb_entry > 0)
+		relay_write(long_prov_chan, long_boot_buffer->buffer, long_boot_buffer->nb_entry * sizeof(union long_prov_elt));
+	kfree(long_boot_buffer);
+	long_boot_buffer = NULL;
+}
+
+bool relay_ready;
+extern struct workqueue_struct *prov_queue;
+
+int prov_create_channel(char *buffer, size_t len)
+{
+	struct relay_list *tmp;
+	char *long_name = kzalloc(PATH_MAX, GFP_KERNEL);
+	struct rchan *chan;
+	struct rchan *long_chan;
+	int rc = 0;
+
+	// test if channel already exists
+	list_for_each_entry(tmp, &relay_list, list) {
+		if (strcmp(tmp->name, buffer) == 0) {
+			rc = -EFAULT;
+			goto out;
+		}
+	}
+
+	if (strlen(buffer) > len)
+		return -ENOMEM;
+	snprintf(long_name, PATH_MAX, "long_%s", buffer);
+	chan = relay_open(buffer, NULL, PROV_RELAY_BUFF_SIZE, PROV_NB_SUBBUF, &relay_callbacks, NULL);
+	if (!chan) {
+		rc = -EFAULT;
+		goto out;
+	}
+	long_chan = relay_open(long_name, NULL, PROV_RELAY_BUFF_SIZE, PROV_NB_SUBBUF, &relay_callbacks, NULL);
+	if (!long_chan) {
+		rc = -EFAULT;
+		goto out;
+	}
+	prov_add_relay(buffer, chan, long_chan);
+out:
+	kfree(long_name);
+	return rc;
+}
+
+static int __init relay_prov_init(void)
+{
+	prov_chan = relay_open(PROV_BASE_NAME, NULL, PROV_RELAY_BUFF_SIZE, PROV_NB_SUBBUF, &relay_callbacks, NULL);
+	if (!prov_chan)
+		panic("Provenance: relay_open failure\n");
+
+	long_prov_chan = relay_open(LONG_PROV_BASE_NAME, NULL, PROV_RELAY_BUFF_SIZE, PROV_NB_SUBBUF, &relay_callbacks, NULL);
+	if (!long_prov_chan)
+		panic("Provenance: relay_open failure\n");
+	prov_add_relay(PROV_BASE_NAME, prov_chan, long_prov_chan);
+	relay_ready = true;
+	// relay buffer are ready, we can write down the boot buffer
+	write_boot_buffer();
+	pr_info("Provenance: relay ready.\n");
+	return 0;
+}
+core_initcall(relay_prov_init);
diff -uprN -b -B ./pristine/linux-4.14.9/security/provenance/type.c ./linux-4.14.9/security/provenance/type.c
--- ./pristine/linux-4.14.9/security/provenance/type.c	1970-01-01 01:00:00.000000000 +0100
+++ ./linux-4.14.9/security/provenance/type.c	2017-12-27 19:40:12.204134608 +0000
@@ -0,0 +1,362 @@
+/*
+ *
+ * Author: Thomas Pasquier <tfjmp@g.harvard.edu>
+ *
+ * Copyright (C) 2015-2017 University of Cambridge, Harvard University
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2, as
+ * published by the Free Software Foundation; either version 2 of the License,
+ * or (at your option) any later version.
+ *
+ */
+#include "provenance.h"
+#include "provenance_types.h"
+
+/* reation string name */
+static const char RL_STR_UNKNOWN[]               = "unknown";
+static const char RL_STR_READ[]                  = "read";
+static const char RL_STR_WRITE[]                 = "write";
+static const char RL_STR_CREATE[]                = "create";
+static const char RL_STR_CHANGE[]                = "change";
+static const char RL_STR_MMAP_WRITE[]            = "mmap_write";
+static const char RL_STR_SH_WRITE[]              = "sh_write";
+static const char RL_STR_BIND[]                  = "bind";
+static const char RL_STR_CONNECT[]               = "connect";
+static const char RL_STR_LISTEN[]                = "listen";
+static const char RL_STR_ACCEPT[]                = "accept";
+static const char RL_STR_OPEN[]                  = "open";
+static const char RL_STR_VERSION[]               = "version_entity";
+static const char RL_STR_MMAP[]                  = "mmap";
+static const char RL_STR_MUNMAP[]                = "munmap";
+static const char RL_STR_LINK[]                  = "link";
+static const char RL_STR_LINK_INODE[]            = "link_inode";
+static const char RL_STR_SETATTR[]               = "setattr";
+static const char RL_STR_SETATTR_INODE[]         = "setattr_inode";
+static const char RL_STR_ACCEPT_SOCKET[]         = "accept_socket";
+static const char RL_STR_SETXATTR[]              = "setxattr";
+static const char RL_STR_SETXATTR_INODE[]        = "setxattr_inode";
+static const char RL_STR_RMVXATTR[]              = "removexattr";
+static const char RL_STR_RMVXATTR_INODE[]        = "removexattr_inode";
+static const char RL_STR_NAMED[]                 = "named";
+static const char RL_STR_NAMED_PROCESS[]         = "named_process";
+static const char RL_STR_EXEC[]                  = "exec";
+static const char RL_STR_EXEC_PROCESS[]          = "exec_process";
+static const char RL_STR_CLONE[]                 = "clone";
+static const char RL_STR_VERSION_PROCESS[]       = "version_activity";
+static const char RL_STR_SEARCH[]                = "search";
+static const char RL_STR_GETATTR[]               = "getattr";
+static const char RL_STR_GETXATTR[]              = "getxattr";
+static const char RL_STR_GETXATTR_INODE[]        = "getxattr_inode";
+static const char RL_STR_LSTXATTR[]              = "listxattr";
+static const char RL_STR_READLINK[]              = "readlink";
+static const char RL_STR_MMAP_READ[]             = "mmap_read";
+static const char RL_STR_SH_READ[]               = "sh_read";
+static const char RL_STR_MMAP_EXEC[]             = "mmap_exec";
+static const char RL_STR_SND[]                   = "send";
+static const char RL_STR_SND_PACKET[]            = "send_packet";
+static const char RL_STR_SND_UNIX[]              = "send_unix";
+static const char RL_STR_RCV[]                   = "receive";
+static const char RL_STR_RCV_PACKET[]            = "receive_packet";
+static const char RL_STR_RCV_UNIX[]              = "receive_unix";
+static const char RL_STR_PERM_READ[]             = "perm_read";
+static const char RL_STR_PERM_WRITE[]            = "perm_write";
+static const char RL_STR_PERM_EXEC[]             = "perm_exec";
+static const char RL_STR_TERMINATE_PROCESS[]     = "terminate";
+static const char RL_STR_CLOSED[]                = "closed";
+static const char RL_STR_ARG[]                   = "arg";
+static const char RL_STR_ENV[]                   = "env";
+static const char RL_STR_LOG[]                   = "log";
+
+/* node string name */
+static const char ND_STR_UNKNOWN[]							= "unknown";
+static const char ND_STR_STR[]									= "string";
+static const char ND_STR_TASK[]									= "task";
+static const char ND_STR_INODE_UNKNOWN[]				= "inode_unknown";
+static const char ND_STR_INODE_LINK[]						= "link";
+static const char ND_STR_INODE_FILE[]						= "file";
+static const char ND_STR_INODE_DIRECTORY[]			= "directory";
+static const char ND_STR_INODE_CHAR[]						= "char";
+static const char ND_STR_INODE_BLOCK[]					= "block";
+static const char ND_STR_INODE_FIFO[]						= "fifo";
+static const char ND_STR_INODE_SOCKET[]					= "socket";
+static const char ND_STR_MSG[]									= "msg";
+static const char ND_STR_SHM[]									= "shm";
+static const char ND_STR_ADDR[]									= "address";
+static const char ND_STR_SB[]										= "sb";
+static const char ND_STR_FILE_NAME[]						= "file_name";
+static const char ND_STR_DISC_ENTITY[]					= "disc_entity";
+static const char ND_STR_DISC_ACTIVITY[]				= "disc_activity";
+static const char ND_STR_DISC_AGENT[]						= "disc_agent";
+static const char ND_STR_PACKET[]								= "packet";
+static const char ND_STR_INODE_MMAP[]						= "mmaped_file";
+static const char ND_STR_IATTR[]								= "iattr";
+static const char ND_STR_XATTR[]								= "xattr";
+static const char ND_STR_PCKCNT[]								= "packet_content";
+static const char ND_STR_ARG[]									= "argv";
+static const char ND_STR_ENV[]									= "envp";
+
+#define MATCH_AND_RETURN(str1, str2, v) if (strcmp(str1, str2) == 0) return v
+/* transform from relation ID to string representation */
+const char* relation_str(uint64_t type)
+{
+	switch (type) {
+	case RL_READ:
+		return RL_STR_READ;
+	case RL_WRITE:
+		return RL_STR_WRITE;
+	case RL_CREATE:
+		return RL_STR_CREATE;
+	case RL_CHANGE:
+		return RL_STR_CHANGE;
+	case RL_MMAP_WRITE:
+		return RL_STR_MMAP_WRITE;
+	case RL_BIND:
+		return RL_STR_BIND;
+	case RL_CONNECT:
+		return RL_STR_CONNECT;
+	case RL_LISTEN:
+		return RL_STR_LISTEN;
+	case RL_ACCEPT:
+		return RL_STR_ACCEPT;
+	case RL_OPEN:
+		return RL_STR_OPEN;
+	case RL_VERSION:
+		return RL_STR_VERSION;
+	case RL_MMAP:
+		return RL_STR_MMAP;
+	case RL_MUNMAP:
+		return RL_STR_MUNMAP;
+	case RL_LINK:
+		return RL_STR_LINK;
+	case RL_LINK_INODE:
+		return RL_STR_LINK_INODE;
+	case RL_SETATTR:
+		return RL_STR_SETATTR;
+	case RL_SETATTR_INODE:
+		return RL_STR_SETATTR_INODE;
+	case RL_ACCEPT_SOCKET:
+		return RL_STR_ACCEPT_SOCKET;
+	case RL_SETXATTR:
+		return RL_STR_SETXATTR;
+	case RL_SETXATTR_INODE:
+		return RL_STR_SETXATTR_INODE;
+	case RL_RMVXATTR:
+		return RL_STR_RMVXATTR;
+	case RL_RMVXATTR_INODE:
+		return RL_STR_RMVXATTR_INODE;
+	case RL_NAMED:
+		return RL_STR_NAMED;
+	case RL_NAMED_PROCESS:
+		return RL_STR_NAMED_PROCESS;
+	case RL_EXEC:
+		return RL_STR_EXEC;
+	case RL_EXEC_PROCESS:
+		return RL_STR_EXEC_PROCESS;
+	case RL_CLONE:
+		return RL_STR_CLONE;
+	case RL_VERSION_PROCESS:
+		return RL_STR_VERSION_PROCESS;
+	case RL_SEARCH:
+		return RL_STR_SEARCH;
+	case RL_GETATTR:
+		return RL_STR_GETATTR;
+	case RL_GETXATTR:
+		return RL_STR_GETXATTR;
+	case RL_GETXATTR_INODE:
+		return RL_STR_GETXATTR_INODE;
+	case RL_LSTXATTR:
+		return RL_STR_LSTXATTR;
+	case RL_READLINK:
+		return RL_STR_READLINK;
+	case RL_MMAP_READ:
+		return RL_STR_MMAP_READ;
+	case RL_MMAP_EXEC:
+		return RL_STR_MMAP_EXEC;
+	case RL_SND:
+		return RL_STR_SND;
+	case RL_SND_PACKET:
+		return RL_STR_SND_PACKET;
+	case RL_SND_UNIX:
+		return RL_STR_SND_UNIX;
+	case RL_RCV:
+		return RL_STR_RCV;
+	case RL_RCV_PACKET:
+		return RL_STR_RCV_PACKET;
+	case RL_RCV_UNIX:
+		return RL_STR_RCV_UNIX;
+	case RL_PERM_READ:
+		return RL_STR_PERM_READ;
+	case RL_PERM_WRITE:
+		return RL_STR_PERM_WRITE;
+	case RL_SH_READ:
+		return RL_STR_SH_READ;
+	case RL_SH_WRITE:
+		return RL_STR_SH_WRITE;
+	case RL_PERM_EXEC:
+		return RL_STR_PERM_EXEC;
+	case RL_TERMINATE_PROCESS:
+		return RL_STR_TERMINATE_PROCESS;
+	case RL_CLOSED:
+		return RL_STR_CLOSED;
+	case RL_ARG:
+		return RL_STR_ARG;
+	case RL_ENV:
+		return RL_STR_ENV;
+	case RL_LOG:
+		return RL_STR_LOG;
+	default:
+		return RL_STR_UNKNOWN;
+	}
+}
+EXPORT_SYMBOL_GPL(relation_str);
+
+/* from string representation to relation ID */
+uint64_t relation_id(const char* str)
+{
+	MATCH_AND_RETURN(str, RL_STR_READ, RL_READ);
+	MATCH_AND_RETURN(str, RL_STR_WRITE, RL_WRITE);
+	MATCH_AND_RETURN(str, RL_STR_CREATE, RL_CREATE);
+	MATCH_AND_RETURN(str, RL_STR_CHANGE, RL_CHANGE);
+	MATCH_AND_RETURN(str, RL_STR_MMAP_WRITE, RL_MMAP_WRITE);
+	MATCH_AND_RETURN(str, RL_STR_BIND, RL_BIND);
+	MATCH_AND_RETURN(str, RL_STR_CONNECT, RL_CONNECT);
+	MATCH_AND_RETURN(str, RL_STR_LISTEN, RL_LISTEN);
+	MATCH_AND_RETURN(str, RL_STR_ACCEPT, RL_ACCEPT);
+	MATCH_AND_RETURN(str, RL_STR_OPEN, RL_OPEN);
+	MATCH_AND_RETURN(str, RL_STR_VERSION, RL_VERSION);
+	MATCH_AND_RETURN(str, RL_STR_MMAP, RL_MMAP);
+	MATCH_AND_RETURN(str, RL_STR_MUNMAP, RL_MUNMAP);
+	MATCH_AND_RETURN(str, RL_STR_LINK, RL_LINK);
+	MATCH_AND_RETURN(str, RL_STR_LINK_INODE, RL_LINK_INODE);
+	MATCH_AND_RETURN(str, RL_STR_SETATTR, RL_SETATTR);
+	MATCH_AND_RETURN(str, RL_STR_SETATTR_INODE, RL_SETATTR_INODE);
+	MATCH_AND_RETURN(str, RL_STR_ACCEPT_SOCKET, RL_ACCEPT_SOCKET);
+	MATCH_AND_RETURN(str, RL_STR_SETXATTR, RL_SETXATTR);
+	MATCH_AND_RETURN(str, RL_STR_SETXATTR_INODE, RL_SETXATTR_INODE);
+	MATCH_AND_RETURN(str, RL_STR_RMVXATTR, RL_RMVXATTR);
+	MATCH_AND_RETURN(str, RL_STR_RMVXATTR_INODE, RL_RMVXATTR_INODE);
+	MATCH_AND_RETURN(str, RL_STR_READLINK, RL_READLINK);
+	MATCH_AND_RETURN(str, RL_STR_NAMED, RL_NAMED);
+	MATCH_AND_RETURN(str, RL_STR_NAMED_PROCESS, RL_NAMED_PROCESS);
+	MATCH_AND_RETURN(str, RL_STR_EXEC, RL_EXEC);
+	MATCH_AND_RETURN(str, RL_STR_EXEC_PROCESS, RL_EXEC_PROCESS);
+	MATCH_AND_RETURN(str, RL_STR_CLONE, RL_CLONE);
+	MATCH_AND_RETURN(str, RL_STR_VERSION_PROCESS, RL_VERSION_PROCESS);
+	MATCH_AND_RETURN(str, RL_STR_SEARCH, RL_SEARCH);
+	MATCH_AND_RETURN(str, RL_STR_GETATTR, RL_GETATTR);
+	MATCH_AND_RETURN(str, RL_STR_GETXATTR, RL_GETXATTR);
+	MATCH_AND_RETURN(str, RL_STR_GETXATTR_INODE, RL_GETXATTR_INODE);
+	MATCH_AND_RETURN(str, RL_STR_LSTXATTR, RL_LSTXATTR);
+	MATCH_AND_RETURN(str, RL_STR_MMAP_READ, RL_MMAP_READ);
+	MATCH_AND_RETURN(str, RL_STR_MMAP_EXEC, RL_MMAP_EXEC);
+	MATCH_AND_RETURN(str, RL_STR_SND, RL_SND);
+	MATCH_AND_RETURN(str, RL_STR_SND_PACKET, RL_SND_PACKET);
+	MATCH_AND_RETURN(str, RL_STR_SND_UNIX, RL_SND_UNIX);
+	MATCH_AND_RETURN(str, RL_STR_RCV, RL_RCV);
+	MATCH_AND_RETURN(str, RL_STR_RCV_PACKET, RL_RCV_PACKET);
+	MATCH_AND_RETURN(str, RL_STR_RCV_UNIX, RL_RCV_UNIX);
+	MATCH_AND_RETURN(str, RL_STR_PERM_READ, RL_PERM_READ);
+	MATCH_AND_RETURN(str, RL_STR_PERM_WRITE, RL_PERM_WRITE);
+	MATCH_AND_RETURN(str, RL_STR_PERM_EXEC, RL_PERM_EXEC);
+	MATCH_AND_RETURN(str, RL_STR_SH_READ, RL_SH_READ);
+	MATCH_AND_RETURN(str, RL_STR_SH_WRITE, RL_SH_WRITE);
+	MATCH_AND_RETURN(str, RL_STR_TERMINATE_PROCESS, RL_TERMINATE_PROCESS);
+	MATCH_AND_RETURN(str, RL_STR_CLOSED, RL_CLOSED);
+	MATCH_AND_RETURN(str, RL_STR_ARG, RL_ARG);
+	MATCH_AND_RETURN(str, RL_STR_ENV, RL_ENV);
+	MATCH_AND_RETURN(str, RL_STR_LOG, RL_LOG);
+	return 0;
+}
+EXPORT_SYMBOL_GPL(relation_id);
+
+/* from node ID to string representation */
+const char* node_str(uint64_t type)
+{
+	switch (type) {
+	case ENT_STR:
+		return ND_STR_STR;
+	case ACT_TASK:
+		return ND_STR_TASK;
+	case ENT_INODE_UNKNOWN:
+		return ND_STR_INODE_UNKNOWN;
+	case ENT_INODE_LINK:
+		return ND_STR_INODE_LINK;
+	case ENT_INODE_FILE:
+		return ND_STR_INODE_FILE;
+	case ENT_INODE_DIRECTORY:
+		return ND_STR_INODE_DIRECTORY;
+	case ENT_INODE_CHAR:
+		return ND_STR_INODE_CHAR;
+	case ENT_INODE_BLOCK:
+		return ND_STR_INODE_BLOCK;
+	case ENT_INODE_FIFO:
+		return ND_STR_INODE_FIFO;
+	case ENT_INODE_SOCKET:
+		return ND_STR_INODE_SOCKET;
+	case ENT_INODE_MMAP:
+		return ND_STR_INODE_MMAP;
+	case ENT_MSG:
+		return ND_STR_MSG;
+	case ENT_SHM:
+		return ND_STR_SHM;
+	case ENT_ADDR:
+		return ND_STR_ADDR;
+	case ENT_SBLCK:
+		return ND_STR_SB;
+	case ENT_FILE_NAME:
+		return ND_STR_FILE_NAME;
+	case ENT_DISC:
+		return ND_STR_DISC_ENTITY;
+	case ACT_DISC:
+		return ND_STR_DISC_ACTIVITY;
+	case AGT_DISC:
+		return ND_STR_DISC_AGENT;
+	case ENT_PACKET:
+		return ND_STR_PACKET;
+	case ENT_IATTR:
+		return ND_STR_IATTR;
+	case ENT_XATTR:
+		return ND_STR_XATTR;
+	case ENT_PCKCNT:
+		return ND_STR_PCKCNT;
+	case ENT_ARG:
+		return ND_STR_ARG;
+	case ENT_ENV:
+		return ND_STR_ENV;
+	default:
+		return ND_STR_UNKNOWN;
+	}
+}
+EXPORT_SYMBOL_GPL(node_str);
+
+/* from string to node ID representation */
+uint64_t node_id(const char* str)
+{
+	MATCH_AND_RETURN(str, ND_STR_TASK, ACT_TASK);
+	MATCH_AND_RETURN(str, ND_STR_INODE_UNKNOWN, ENT_INODE_UNKNOWN);
+	MATCH_AND_RETURN(str, ND_STR_INODE_LINK, ENT_INODE_LINK);
+	MATCH_AND_RETURN(str, ND_STR_INODE_FILE, ENT_INODE_FILE);
+	MATCH_AND_RETURN(str, ND_STR_INODE_DIRECTORY, ENT_INODE_DIRECTORY);
+	MATCH_AND_RETURN(str, ND_STR_INODE_CHAR, ENT_INODE_CHAR);
+	MATCH_AND_RETURN(str, ND_STR_INODE_BLOCK, ENT_INODE_BLOCK);
+	MATCH_AND_RETURN(str, ND_STR_INODE_FIFO, ENT_INODE_FIFO);
+	MATCH_AND_RETURN(str, ND_STR_INODE_SOCKET, ENT_INODE_SOCKET);
+	MATCH_AND_RETURN(str, ND_STR_INODE_MMAP, ENT_INODE_MMAP);
+	MATCH_AND_RETURN(str, ND_STR_MSG, ENT_MSG);
+	MATCH_AND_RETURN(str, ND_STR_SHM, ENT_SHM);
+	MATCH_AND_RETURN(str, ND_STR_ADDR, ENT_ADDR);
+	MATCH_AND_RETURN(str, ND_STR_SB, ENT_SBLCK);
+	MATCH_AND_RETURN(str, ND_STR_FILE_NAME, ENT_FILE_NAME);
+	MATCH_AND_RETURN(str, ND_STR_DISC_ENTITY, ENT_DISC);
+	MATCH_AND_RETURN(str, ND_STR_DISC_ACTIVITY, ACT_DISC);
+	MATCH_AND_RETURN(str, ND_STR_DISC_AGENT, AGT_DISC);
+	MATCH_AND_RETURN(str, ND_STR_PACKET, ENT_PACKET);
+	MATCH_AND_RETURN(str, ND_STR_IATTR, ENT_IATTR);
+	MATCH_AND_RETURN(str, ND_STR_XATTR, ENT_XATTR);
+	MATCH_AND_RETURN(str, ND_STR_PCKCNT, ENT_PCKCNT);
+	MATCH_AND_RETURN(str, ND_STR_ARG, ENT_ARG);
+	MATCH_AND_RETURN(str, ND_STR_ENV, ENT_ENV);
+	return 0;
+}
+EXPORT_SYMBOL_GPL(node_id);
diff -uprN -b -B ./pristine/linux-4.14.9/security/security.c ./linux-4.14.9/security/security.c
--- ./pristine/linux-4.14.9/security/security.c	2017-12-25 13:26:48.000000000 +0000
+++ ./linux-4.14.9/security/security.c	2017-12-27 19:40:12.204134608 +0000
@@ -21,6 +21,7 @@
 #include <linux/integrity.h>
 #include <linux/ima.h>
 #include <linux/evm.h>
+#include <linux/camflow.h>
 #include <linux/fsnotify.h>
 #include <linux/mman.h>
 #include <linux/mount.h>
@@ -79,6 +80,10 @@ int __init security_init(void)
 	 */
 	do_security_initcalls();

+	/*
+	* Provenance is the last module to be loaded
+	*/
+	provenance_add_hooks();
 	return 0;
 }

@@ -1703,3 +1708,46 @@ int security_audit_rule_match(u32 secid,
 				actx);
 }
 #endif /* CONFIG_AUDIT */
+
+#ifdef CONFIG_SECURITY_FLOW_FRIENDLY
+void security_mmap_munmap(struct mm_struct *mm,
+					struct vm_area_struct *vma,
+					unsigned long start, unsigned long end)
+{
+	call_void_hook(mmap_munmap, mm, vma, start, end);
+}
+
+int security_file_splice_pipe_to_pipe(struct file *in,
+						    struct file *out)
+{
+	return call_int_hook(file_splice_pipe_to_pipe, 0, in, out);
+}
+
+int security_mq_timedsend(struct inode *inode, struct msg_msg *msg,
+				size_t msg_len, struct timespec64 *ts)
+{
+	return call_int_hook(mq_timedsend, 0, inode, msg, ts);
+}
+
+int security_mq_timedreceive(struct inode *inode, struct msg_msg *msg,
+				size_t msg_len, struct timespec64 *ts)
+{
+	return call_int_hook(mq_timedreceive, 0, inode, msg, ts);
+}
+
+void security_shm_shmdt(struct shmid_kernel *shp)
+{
+	call_void_hook(shm_shmdt, shp);
+}
+
+int security_socket_sendmsg_always(struct socket *sock, struct msghdr *msg, int size)
+{
+	return call_int_hook(socket_sendmsg_always, 0, sock, msg, size);
+}
+
+int security_socket_recvmsg_always(struct socket *sock, struct msghdr *msg,
+			    int size, int flags)
+{
+	return call_int_hook(socket_recvmsg_always, 0, sock, msg, size, flags);
+}
+#endif /* CONFIG_SECURITY_FLOW_FRIENDLY */
