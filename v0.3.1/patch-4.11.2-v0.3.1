diff -uprN -b -B ./pristine/linux-4.11.2/include/linux/camflow_query.h ./linux-4.11.2/include/linux/camflow_query.h
--- ./pristine/linux-4.11.2/include/linux/camflow_query.h	1970-01-01 01:00:00.000000000 +0100
+++ ./linux-4.11.2/include/linux/camflow_query.h	2017-05-22 10:47:47.653667158 +0100
@@ -0,0 +1,33 @@
+/*
+ *
+ * Author: Thomas Pasquier <tfjmp@g.harvard.edu>
+ *
+ * Copyright (C) 2017 Harvard University
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2, as
+ * published by the Free Software Foundation; either version 2 of the License,
+ * or (at your option) any later version.
+ *
+ */
+ #ifndef __LINUX_CAMFLOW_QUERY_H
+ #define __LINUX_CAMFLOW_QUERY_H
+
+ #include <uapi/linux/provenance.h>
+
+ #define CAMFLOW_RAISE_WARNING  1
+ #define CAMFLOW_PREVENT_FLOW   2
+
+ #define QUERY_HOOK_INIT(HEAD, HOOK) .HEAD=&HOOK
+
+struct provenance_query_hooks {
+  struct list_head list;
+  int (*out_edge)(prov_entry_t*, prov_entry_t*);
+  int (*in_edge)(prov_entry_t*, prov_entry_t*);
+};
+
+ extern struct list_head provenance_query_hooks;
+
+int register_camflow_query_hook( struct provenance_query_hooks *hook);
+int unregister_camflow_query_hook( struct provenance_query_hooks *hook);
+#endif
diff -uprN -b -B ./pristine/linux-4.11.2/include/linux/cred.h ./linux-4.11.2/include/linux/cred.h
--- ./pristine/linux-4.11.2/include/linux/cred.h	2017-05-20 13:50:04.000000000 +0100
+++ ./linux-4.11.2/include/linux/cred.h	2017-05-22 10:47:47.639667038 +0100
@@ -140,6 +140,9 @@ struct cred {
 #endif
 #ifdef CONFIG_SECURITY
 	void		*security;	/* subjective LSM security */
+#ifdef CONFIG_SECURITY_PROVENANCE
+	void            *provenance;    /* subjective LSM provenance */
+#endif
 #endif
 	struct user_struct *user;	/* real user ID subscription */
 	struct user_namespace *user_ns; /* user_ns the caps and keyrings are relative to. */
@@ -364,6 +367,7 @@ static inline void put_cred(const struct
 #define current_cap()		(current_cred_xxx(cap_effective))
 #define current_user()		(current_cred_xxx(user))
 #define current_security()	(current_cred_xxx(security))
+#define current_provenance() (current_cred_xxx(provenance))
 
 extern struct user_namespace init_user_ns;
 #ifdef CONFIG_USER_NS
diff -uprN -b -B ./pristine/linux-4.11.2/include/linux/fs.h ./linux-4.11.2/include/linux/fs.h
--- ./pristine/linux-4.11.2/include/linux/fs.h	2017-05-20 13:50:04.000000000 +0100
+++ ./linux-4.11.2/include/linux/fs.h	2017-05-22 10:47:47.640667047 +0100
@@ -569,6 +569,9 @@ struct inode {
 
 #ifdef CONFIG_SECURITY
 	void			*i_security;
+#ifdef CONFIG_SECURITY_PROVENANCE
+	void 			*i_provenance;
+#endif
 #endif
 
 	/* Stat data, not accessed from path walking */
@@ -1310,6 +1313,9 @@ struct super_block {
 	atomic_t		s_active;
 #ifdef CONFIG_SECURITY
 	void                    *s_security;
+#ifdef CONFIG_SECURITY_PROVENANCE
+	void 										*s_provenance;
+#endif
 #endif
 	const struct xattr_handler **s_xattr;
 
diff -uprN -b -B ./pristine/linux-4.11.2/include/linux/ipc.h ./linux-4.11.2/include/linux/ipc.h
--- ./pristine/linux-4.11.2/include/linux/ipc.h	2017-05-20 13:50:04.000000000 +0100
+++ ./linux-4.11.2/include/linux/ipc.h	2017-05-22 10:47:47.654667167 +0100
@@ -21,6 +21,9 @@ struct kern_ipc_perm
 	umode_t		mode; 
 	unsigned long	seq;
 	void		*security;
+#ifdef CONFIG_SECURITY_PROVENANCE
+	void 		*provenance;
+#endif
 };
 
 #endif /* _LINUX_IPC_H */
diff -uprN -b -B ./pristine/linux-4.11.2/include/linux/lsm_hooks.h ./linux-4.11.2/include/linux/lsm_hooks.h
--- ./pristine/linux-4.11.2/include/linux/lsm_hooks.h	2017-05-20 13:50:04.000000000 +0100
+++ ./linux-4.11.2/include/linux/lsm_hooks.h	2017-05-22 10:47:47.642667064 +0100
@@ -1915,6 +1915,11 @@ extern void __init yama_add_hooks(void);
 #else
 static inline void __init yama_add_hooks(void) { }
 #endif
+#ifdef CONFIG_SECURITY_PROVENANCE
+extern void __init provenance_add_hooks(void);
+#else
+static inline void __init provenance_add_hooks(void) { }
+#endif
 #ifdef CONFIG_SECURITY_LOADPIN
 void __init loadpin_add_hooks(void);
 #else
diff -uprN -b -B ./pristine/linux-4.11.2/include/linux/msg.h ./linux-4.11.2/include/linux/msg.h
--- ./pristine/linux-4.11.2/include/linux/msg.h	2017-05-20 13:50:04.000000000 +0100
+++ ./linux-4.11.2/include/linux/msg.h	2017-05-22 10:47:47.655667176 +0100
@@ -11,6 +11,9 @@ struct msg_msg {
 	size_t m_ts;		/* message text size */
 	struct msg_msgseg *next;
 	void *security;
+#ifdef CONFIG_SECURITY_PROVENANCE
+	void *provenance;
+#endif
 	/* the actual message follows immediately */
 };
 
diff -uprN -b -B ./pristine/linux-4.11.2/include/net/sock.h ./linux-4.11.2/include/net/sock.h
--- ./pristine/linux-4.11.2/include/net/sock.h	2017-05-20 13:50:04.000000000 +0100
+++ ./linux-4.11.2/include/net/sock.h	2017-05-22 10:47:47.691667483 +0100
@@ -295,6 +295,7 @@ struct sock_common {
   *	@sk_peek_off: current peek_offset value
   *	@sk_send_head: front of stuff to transmit
   *	@sk_security: used by security modules
+  *	@sk_provenance: used by provenance modules
   *	@sk_mark: generic packet mark
   *	@sk_cgrp_data: cgroup data for this cgroup
   *	@sk_memcg: this socket's memory cgroup association
@@ -461,6 +462,9 @@ struct sock {
 	void			*sk_user_data;
 #ifdef CONFIG_SECURITY
 	void			*sk_security;
+#ifdef CONFIG_SECURITY_PROVENANCE
+	void 			*sk_provenance;
+#endif
 #endif
 	struct sock_cgroup_data	sk_cgrp_data;
 	struct mem_cgroup	*sk_memcg;
diff -uprN -b -B ./pristine/linux-4.11.2/include/uapi/linux/camflow.h ./linux-4.11.2/include/uapi/linux/camflow.h
--- ./pristine/linux-4.11.2/include/uapi/linux/camflow.h	1970-01-01 01:00:00.000000000 +0100
+++ ./linux-4.11.2/include/uapi/linux/camflow.h	2017-05-22 10:47:47.730667817 +0100
@@ -0,0 +1,26 @@
+/*
+ *
+ * Author: Thomas Pasquier <thomas.pasquier@cl.cam.ac.uk>
+ *
+ * Copyright (C) 2016 University of Cambridge
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2, as
+ * published by the Free Software Foundation; either version 2 of the License,
+ * or (at your option) any later version.
+ *
+ */
+#ifndef _UAPI_LINUX_CAMFLOW_H
+#define _UAPI_LINUX_CAMFLOW_H
+
+#define xstr(s) str(s)
+#define str(s) # s
+
+#define CAMFLOW_VERSION_MAJOR     0
+#define CAMFLOW_VERSION_MINOR     3
+#define CAMFLOW_VERSION_PATCH     1
+#define CAMFLOW_VERSION_STR "v"xstr(CAMFLOW_VERSION_MAJOR)\
+  "."xstr(CAMFLOW_VERSION_MINOR)\
+  "."xstr(CAMFLOW_VERSION_PATCH)\
+
+#endif
diff -uprN -b -B ./pristine/linux-4.11.2/include/uapi/linux/Kbuild ./linux-4.11.2/include/uapi/linux/Kbuild
--- ./pristine/linux-4.11.2/include/uapi/linux/Kbuild	2017-05-20 13:50:04.000000000 +0100
+++ ./linux-4.11.2/include/uapi/linux/Kbuild	2017-05-22 10:47:47.729667809 +0100
@@ -79,6 +79,7 @@ header-y += bpqether.h
 header-y += bsg.h
 header-y += bt-bmc.h
 header-y += btrfs.h
+header-y += camflow.h
 header-y += can.h
 header-y += capability.h
 header-y += capi.h
@@ -353,6 +354,7 @@ header-y += ppp_defs.h
 header-y += ppp-ioctl.h
 header-y += pps.h
 header-y += prctl.h
+header-y += provenance.h
 header-y += psci.h
 header-y += ptp_clock.h
 header-y += ptrace.h
diff -uprN -b -B ./pristine/linux-4.11.2/include/uapi/linux/provenance.h ./linux-4.11.2/include/uapi/linux/provenance.h
--- ./pristine/linux-4.11.2/include/uapi/linux/provenance.h	1970-01-01 01:00:00.000000000 +0100
+++ ./linux-4.11.2/include/uapi/linux/provenance.h	2017-05-22 10:47:47.728667800 +0100
@@ -0,0 +1,532 @@
+/*
+ *
+ * Author: Thomas Pasquier <thomas.pasquier@cl.cam.ac.uk>
+ *
+ * Copyright (C) 2015 University of Cambridge
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2, as
+ * published by the Free Software Foundation; either version 2 of the License,
+ * or (at your option) any later version.
+ *
+ */
+#ifndef _UAPI_LINUX_PROVENANCE_H
+#define _UAPI_LINUX_PROVENANCE_H
+
+#ifndef __KERNEL__
+#include <linux/limits.h>
+#else
+#include <linux/socket.h>
+#include <linux/limits.h>
+#include <linux/mutex.h>
+#endif
+
+#define PROVENANCE_HASH "sha256"
+
+#define PROV_GOLDEN_RATIO_64 0x61C8864680B583EBUL
+static inline uint32_t prov_hash(uint64_t val)
+{
+	return (val * PROV_GOLDEN_RATIO_64) >> (64 - 8);
+}
+
+#define PROV_K_HASH 7
+#define PROV_M_BITS 256
+#define PROV_N_BYTES (PROV_M_BITS / 8)
+#define PROV_BYTE_INDEX(a) (a / 8)
+#define PROV_BIT_INDEX(a) (a % 8)
+
+static inline void prov_bloom_add(uint8_t bloom[PROV_N_BYTES], uint64_t val)
+{
+	uint8_t i;
+	uint32_t pos;
+
+	for (i = 0; i < PROV_K_HASH; i++) {
+		pos = prov_hash(val + i) % PROV_M_BITS;
+		bloom[PROV_BYTE_INDEX(pos)] |= 1 << PROV_BIT_INDEX(pos);
+	}
+}
+
+// djb2 hash implementation by Dan Bernstein
+static inline uint64_t djb2_hash(const char *str)
+{
+	uint64_t hash = 5381;
+	int c = *str;
+
+	while (c) {
+		hash = ((hash<<5)+hash) + c;
+		c = *++str;
+	}
+	return hash;
+}
+#define generate_label(str) djb2_hash(str)
+
+/* element in set belong to super */
+static inline bool prov_bloom_match(const uint8_t super[PROV_N_BYTES], const uint8_t set[PROV_N_BYTES])
+{
+	uint8_t i;
+
+	for (i = 0; i < PROV_N_BYTES; i++)
+		if ((super[i] & set[i]) != set[i])
+			return false;
+	return true;
+}
+
+static inline bool prov_bloom_in(const uint8_t bloom[PROV_N_BYTES], uint64_t val)
+{
+	uint8_t tmp[PROV_N_BYTES];
+
+	memset(tmp, 0, PROV_N_BYTES);
+	prov_bloom_add(tmp, val);
+	return prov_bloom_match(bloom, tmp);
+}
+
+/* merge src into dest (dest=dest U src) */
+static inline void prov_bloom_merge(uint8_t dest[PROV_N_BYTES], const uint8_t src[PROV_N_BYTES])
+{
+	uint8_t i;
+
+	for (i = 0; i < PROV_N_BYTES; i++)
+		dest[i] |= src[i];
+}
+
+
+static inline bool prov_bloom_empty(const uint8_t bloom[PROV_N_BYTES])
+{
+	uint8_t i;
+
+	for (i = 0; i < PROV_N_BYTES; i++)
+		if (bloom[i] != 0)
+			return false;
+	return true;
+}
+
+#define PROV_ENABLE_FILE                      "/sys/kernel/security/provenance/enable"
+#define PROV_ALL_FILE                         "/sys/kernel/security/provenance/all"
+#define PROV_NODE_FILE                        "/sys/kernel/security/provenance/node"
+#define PROV_RELATION_FILE                    "/sys/kernel/security/provenance/relation"
+#define PROV_SELF_FILE                        "/sys/kernel/security/provenance/self"
+#define PROV_MACHINE_ID_FILE                  "/sys/kernel/security/provenance/machine_id"
+#define PROV_BOOT_ID_FILE                  		"/sys/kernel/security/provenance/boot_id"
+#define PROV_NODE_FILTER_FILE                 "/sys/kernel/security/provenance/node_filter"
+#define PROV_RELATION_FILTER_FILE             "/sys/kernel/security/provenance/relation_filter"
+#define PROV_PROPAGATE_NODE_FILTER_FILE       "/sys/kernel/security/provenance/propagate_node_filter"
+#define PROV_PROPAGATE_RELATION_FILTER_FILE   "/sys/kernel/security/provenance/propagate_relation_filter"
+#define PROV_FLUSH_FILE                       "/sys/kernel/security/provenance/flush"
+#define PROV_PROCESS_FILE                     "/sys/kernel/security/provenance/process"
+#define PROV_IPV4_INGRESS_FILE                "/sys/kernel/security/provenance/ipv4_ingress"
+#define PROV_IPV4_EGRESS_FILE                 "/sys/kernel/security/provenance/ipv4_egress"
+#define PROV_SECCTX                           "/sys/kernel/security/provenance/secctx"
+#define PROV_SECCTX_FILTER                    "/sys/kernel/security/provenance/secctx_filter"
+#define PROV_NS_FILTER												"/sys/kernel/security/provenance/ns"
+#define PROV_LOG_FILE													"/sys/kernel/security/provenance/log"
+#define PROV_LOGP_FILE												"/sys/kernel/security/provenance/logp"
+#define PROV_POLICY_HASH_FILE									"/sys/kernel/security/provenance/policy_hash"
+
+#define PROV_RELAY_NAME                       "/sys/kernel/debug/provenance"
+#define PROV_LONG_RELAY_NAME                  "/sys/kernel/debug/long_provenance"
+
+#define TYPE_MASK             0xFFFF000000000000UL
+#define SUBTYPE_MASK          0x0000FFFFFFFFFFFFUL
+
+#define W3C_TYPE(type)        (type & TYPE_MASK)
+#define SUBTYPE(type)         (type & SUBTYPE_MASK)
+
+/* W3C PROV TYPES */
+#define DM_RELATION           0x8000000000000000UL
+#define DM_ACTIVITY           0x4000000000000000UL
+#define DM_ENTITY             0x2000000000000000UL
+#define DM_AGENT              0x1000000000000000UL
+/* ALLOWED/DISALLOWED */
+#define RL_ALLOWED            0x0200000000000000UL
+#define RL_DISALLOWED         0x0100000000000000UL
+/* SUBTYPES */
+/* RELATIONS W3C TYPE*/
+#define RL_DERIVED            (DM_RELATION | 0x0080000000000000ULL)
+#define RL_GENERATED          (DM_RELATION | 0x0040000000000000ULL)
+#define RL_ATTRIBUTED         (DM_RELATION | 0x0020000000000000ULL)
+#define RL_USED               (DM_RELATION | 0x0010000000000000ULL)
+#define RL_INFORMED           (DM_RELATION | 0x0008000000000000ULL)
+#define RL_ASSOCIATED         (DM_RELATION | 0x0004000000000000ULL)
+#define RL_BEHALF             (DM_RELATION | 0x0002000000000000ULL)
+#define RL_UNKNOWN            (DM_RELATION | 0x0001000000000000ULL)
+/* DERIVED SUBTYPES */
+#define RL_NAMED              (RL_DERIVED   | 0x0000000000000001ULL)
+#define RL_VERSION            (RL_DERIVED   | 0x0000000000000002ULL)
+#define RL_MMAP               (RL_DERIVED   | 0x0000000000000004ULL)
+#define RL_SND_PACKET         (RL_DERIVED   | 0x0000000000000008ULL)
+#define RL_RCV_PACKET         (RL_DERIVED   | 0x0000000000000010ULL)
+#define RL_CLOSED			        (RL_DERIVED   | 0x0000000000000020ULL)
+/* GENERATED SUBTYPES */
+#define RL_CREATE             (RL_GENERATED | 0x0000000000000040ULL)
+#define RL_WRITE              (RL_GENERATED | 0x0000000000000080ULL)
+#define RL_PERM_WRITE         (RL_GENERATED | 0x0000000000000100ULL)
+#define RL_MMAP_WRITE         (RL_GENERATED | 0x0000000000000200ULL)
+#define RL_SH_WRITE           (RL_GENERATED | 0x0000000000000400ULL)
+#define RL_CONNECT            (RL_GENERATED | 0x0000000000000800ULL)
+#define RL_LISTEN             (RL_GENERATED | 0x0000000000001000ULL)
+#define RL_BIND               (RL_GENERATED | 0x0000000000002000ULL)
+#define RL_SND                (RL_GENERATED | 0x0000000000004000ULL)
+#define RL_LINK               (RL_GENERATED | 0x0000000000008000ULL)
+#define RL_SETATTR            (RL_GENERATED | 0x0000000000010000ULL)
+#define RL_SETXATTR           (RL_GENERATED | 0x0000000000020000ULL)
+#define RL_RMVXATTR           (RL_GENERATED | 0x0000000000040000ULL)
+/* USED SUBTYPES */
+#define RL_READ               (RL_USED      | 0x0000000000080000ULL)
+#define RL_MMAP_READ          (RL_USED      | 0x0000000000100000ULL)
+#define RL_PERM_READ          (RL_USED      | 0x0000000000200000ULL)
+#define RL_SH_READ            (RL_USED      | 0x0000000000400000ULL)
+#define RL_EXEC               (RL_USED      | 0x0000000000800000ULL)
+#define RL_MMAP_EXEC          (RL_USED      | 0x0000000001000000ULL)
+#define RL_PERM_EXEC          (RL_USED      | 0x0000000002000000ULL)
+#define RL_ACCEPT             (RL_USED      | 0x0000000004000000ULL)
+#define RL_RCV                (RL_USED      | 0x0000000008000000ULL)
+#define RL_OPEN               (RL_USED      | 0x0000000010000000ULL)
+#define RL_SEARCH             (RL_USED      | 0x0000000020000000ULL)
+#define RL_GETATTR            (RL_USED      | 0x0000000040000000ULL)
+#define RL_READLINK           (RL_USED      | 0x0000000080000000ULL)
+#define RL_GETXATTR           (RL_USED      | 0x0000000100000000ULL)
+#define RL_LSTXATTR           (RL_USED      | 0x0000000200000000ULL)
+#define RL_NAMED_PROCESS      (RL_USED      | 0x0000000400000000ULL)
+#define RL_SAID								(RL_USED      | 0x0000000800000000ULL)
+/* INFORMED SUBTYPES */
+#define RL_CLONE              (RL_INFORMED  | 0x0000001000000000ULL)
+#define RL_VERSION_PROCESS    (RL_INFORMED  | 0x0000002000000000ULL)
+#define RL_CHANGE             (RL_INFORMED  | 0x0000004000000000ULL)
+#define RL_EXEC_PROCESS       (RL_INFORMED  | 0x0000008000000000ULL)
+#define RL_TERMINATE_PROCESS  (RL_INFORMED  | 0x0000010000000000ULL)
+
+/* ACTIVITY SUBTYPES */
+#define ACT_TASK              (DM_ACTIVITY  | 0x0000000000000001ULL)
+#define ACT_DISC              (DM_ACTIVITY  | 0x0000000000000002ULL)
+/* AGENT SUBTYPES */
+#define AGT_USR               (DM_AGENT     | 0x0000000000000004ULL)
+#define AGT_GRP               (DM_AGENT     | 0x0000000000000008ULL)
+#define AGT_DISC              (DM_AGENT     | 0x0000000000000010ULL)
+/* ENTITY SUBTYPES */
+#define ENT_STR               (DM_ENTITY    | 0x0000000000000020ULL)
+#define ENT_INODE_UNKNOWN     (DM_ENTITY    | 0x0000000000000040ULL)
+#define ENT_INODE_LINK        (DM_ENTITY    | 0x0000000000000080ULL)
+#define ENT_INODE_FILE        (DM_ENTITY    | 0x0000000000000100ULL)
+#define ENT_INODE_DIRECTORY   (DM_ENTITY    | 0x0000000000000200ULL)
+#define ENT_INODE_CHAR        (DM_ENTITY    | 0x0000000000000400ULL)
+#define ENT_INODE_BLOCK       (DM_ENTITY    | 0x0000000000000800ULL)
+#define ENT_INODE_FIFO        (DM_ENTITY    | 0x0000000000001000ULL)
+#define ENT_INODE_SOCKET      (DM_ENTITY    | 0x0000000000002000ULL)
+#define ENT_INODE_MMAP        (DM_ENTITY    | 0x0000000000004000ULL)
+#define ENT_MSG               (DM_ENTITY    | 0x0000000000008000ULL)
+#define ENT_SHM               (DM_ENTITY    | 0x0000000000010000ULL)
+#define ENT_ADDR              (DM_ENTITY    | 0x0000000000020000ULL)
+#define ENT_SBLCK             (DM_ENTITY    | 0x0000000000040000ULL)
+#define ENT_FILE_NAME         (DM_ENTITY    | 0x0000000000080000ULL)
+#define ENT_PACKET            (DM_ENTITY    | 0x0000000000100000ULL)
+#define ENT_DISC              (DM_ENTITY    | 0x0000000000200000ULL)
+#define ENT_IATTR             (DM_ENTITY    | 0x0000000000400000ULL)
+#define ENT_XATTR             (DM_ENTITY    | 0x0000000000800000ULL)
+#define ENT_PCKCNT						(DM_ENTITY    | 0x0000000001000000ULL)
+
+#define FLOW_ALLOWED        0
+#define FLOW_DISALLOWED     1
+
+#define prov_type(prov)               ((prov)->node_info.identifier.node_id.type)
+#define node_type(node) prov_type(node)
+#define edge_type(edge) prov_type(edge)
+#define prov_id_buffer(prov)          ((prov)->node_info.identifier.buffer)
+#define node_identifier(node)         ((node)->node_info.identifier.node_id)
+#define relation_identifier(relation) ((relation)->relation_info.identifier.relation_id)
+#define get_prov_identifier(node)			((node)->node_info.identifier)
+#define packet_identifier(packet)     ((packet)->pck_info.identifier.packet_id)
+#define prov_is_relation(prov)        ((relation_identifier(prov).type & DM_RELATION) != 0)
+#define prov_is_node(prov)            ((node_identifier(prov).type & DM_RELATION) == 0)
+#define node_secid(node)              ((node)->node_info.secid)
+
+#define prov_flag(prov) ((prov)->msg_info.flag)
+#define prov_taint(prov) ((prov)->msg_info.taint)
+#define prov_jiffies(prov) ((prov)->msg_info.jiffies)
+
+struct node_identifier {
+	uint64_t type;
+	uint64_t id;
+	uint32_t boot_id;
+	uint32_t machine_id;
+	uint32_t version;
+};
+
+struct relation_identifier {
+	uint64_t type;
+	uint64_t id;
+	uint32_t boot_id;
+	uint32_t machine_id;
+};
+
+struct packet_identifier {
+	uint64_t type;
+	uint16_t id;
+	uint32_t snd_ip;
+	uint32_t rcv_ip;
+	uint16_t snd_port;
+	uint16_t rcv_port;
+	uint8_t protocol;
+	uint32_t seq;
+};
+
+#define PROV_IDENTIFIER_BUFFER_LENGTH sizeof(struct node_identifier)
+
+union prov_identifier {
+	struct node_identifier node_id;
+	struct relation_identifier relation_id;
+	struct packet_identifier packet_id;
+	uint8_t buffer[PROV_IDENTIFIER_BUFFER_LENGTH];
+};
+
+#define prov_set_flag(node, nbit) 	(prov_flag(node) |= 1 << nbit)
+#define prov_clear_flag(node, nbit) (prov_flag(node) &= ~(1 << nbit))
+#define prov_check_flag(node, nbit) ((prov_flag(node) & (1 << nbit)) == (1 << nbit))
+
+#define RECORDED_BIT 0
+#define set_recorded(node)                  prov_set_flag(node, RECORDED_BIT)
+#define clear_recorded(node)                prov_clear_flag(node, RECORDED_BIT)
+#define provenance_is_recorded(node)        prov_check_flag(node, RECORDED_BIT)
+
+#define NAME_RECORDED_BIT 1
+#define set_name_recorded(node)             prov_set_flag(node, NAME_RECORDED_BIT)
+#define clear_name_recorded(node)           prov_clear_flag(node, NAME_RECORDED_BIT)
+#define provenance_is_name_recorded(node)   prov_check_flag(node, NAME_RECORDED_BIT)
+
+#define TRACKED_BIT 2
+#define set_tracked(node)                   prov_set_flag(node, TRACKED_BIT)
+#define clear_tracked(node)                 prov_clear_flag(node, TRACKED_BIT)
+#define provenance_is_tracked(node)         prov_check_flag(node, TRACKED_BIT)
+
+#define OPAQUE_BIT 3
+#define set_opaque(node)                    prov_set_flag(node, OPAQUE_BIT)
+#define clear_opaque(node)                  prov_clear_flag(node, OPAQUE_BIT)
+#define provenance_is_opaque(node)          prov_check_flag(node, OPAQUE_BIT)
+
+#define PROPAGATE_BIT 4
+#define set_propagate(node)                 prov_set_flag(node, PROPAGATE_BIT)
+#define clear_propagate(node)               prov_clear_flag(node, PROPAGATE_BIT)
+#define provenance_does_propagate(node)     prov_check_flag(node, PROPAGATE_BIT)
+
+#define RECORD_PACKET_BIT 5
+#define set_record_packet(node)							prov_set_flag(node, RECORD_PACKET_BIT)
+#define clear_record_packet(node)						prov_clear_flag(node, RECORD_PACKET_BIT)
+#define provenance_records_packet(node)			prov_check_flag(node, RECORD_PACKET_BIT)
+
+#define basic_elements union prov_identifier identifier; uint8_t flag; uint64_t jiffies; uint32_t secid; uint8_t taint[PROV_N_BYTES]
+
+struct msg_struct {
+	basic_elements;
+};
+
+#define FILE_INFO_SET 0x01
+
+struct relation_struct {
+	basic_elements;
+	uint8_t allowed;
+	union prov_identifier snd;
+	union prov_identifier rcv;
+	uint8_t set;
+	int64_t offset;
+};
+
+struct node_struct {
+	basic_elements;
+};
+
+struct task_prov_struct {
+	basic_elements;
+	uint32_t uid;
+	uint32_t gid;
+	uint32_t pid;
+	uint32_t vpid;
+	uint32_t utsns;
+	uint32_t ipcns;
+	uint32_t mntns;
+	uint32_t pidns;
+	uint32_t netns;
+	uint32_t cgroupns;
+};
+
+struct inode_prov_struct {
+	basic_elements;
+	uint64_t ino;
+	uint32_t uid;
+	uint32_t gid;
+	uint16_t mode;
+	uint8_t sb_uuid[16];
+};
+
+struct iattr_prov_struct {
+	basic_elements;
+	uint32_t valid;
+	uint16_t mode;
+	uint32_t uid;
+	uint32_t gid;
+	int64_t size;
+	int64_t atime;
+	int64_t ctime;
+	int64_t mtime;
+};
+
+struct msg_msg_struct {
+	basic_elements;
+	long type;
+};
+
+struct shm_struct {
+	basic_elements;
+	uint16_t mode;
+};
+
+struct sb_struct {
+	basic_elements;
+	uint8_t uuid[16];
+};
+
+struct pck_struct {
+	basic_elements;
+	uint16_t length;
+};
+
+union prov_elt {
+	struct msg_struct msg_info;
+	struct relation_struct relation_info;
+	struct node_struct node_info;
+	struct task_prov_struct task_info;
+	struct inode_prov_struct inode_info;
+	struct msg_msg_struct msg_msg_info;
+	struct shm_struct shm_info;
+	struct sb_struct sb_info;
+	struct pck_struct pck_info;
+	struct iattr_prov_struct iattr_info;
+};
+
+struct str_struct {
+	basic_elements;
+	char str[PATH_MAX];
+	size_t length;
+};
+
+struct file_name_struct {
+	basic_elements;
+	char name[PATH_MAX];
+	size_t length;
+};
+
+struct address_struct {
+	basic_elements;
+	struct sockaddr addr;
+	size_t length;
+};
+
+#define PROV_TRUNCATED 1
+struct pckcnt_struct {
+	basic_elements;
+	uint8_t content[PATH_MAX];
+	size_t length;
+	uint8_t truncated;
+};
+
+#define PROV_XATTR_NAME_SIZE    256
+#define PROV_XATTR_VALUE_SIZE   (PATH_MAX - PROV_XATTR_NAME_SIZE)
+struct xattr_prov_struct {
+	basic_elements;
+	char name[PROV_XATTR_NAME_SIZE]; // max Linux characters
+	int32_t flags;
+	uint8_t value[PROV_XATTR_VALUE_SIZE];
+	size_t size;
+};
+
+struct disc_node_struct {
+	basic_elements;
+	size_t length;
+	char content[PATH_MAX];
+	union prov_identifier parent;
+};
+
+union long_prov_elt {
+	struct msg_struct msg_info;
+	struct relation_struct relation_info;
+	struct node_struct node_info;
+	struct task_prov_struct task_info;
+	struct inode_prov_struct inode_info;
+	struct msg_msg_struct msg_msg_info;
+	struct shm_struct shm_info;
+	struct sb_struct sb_info;
+	struct pck_struct pck_info;
+	struct iattr_prov_struct iattr_info;
+	struct str_struct str_info;
+	struct file_name_struct file_name_info;
+	struct address_struct address_info;
+	struct pckcnt_struct pckcnt_info;
+	struct disc_node_struct disc_node_info;
+	struct xattr_prov_struct xattr_info;
+};
+
+typedef union long_prov_elt prov_entry_t;
+
+struct prov_filter {
+	uint64_t filter;
+	uint64_t mask;
+	uint8_t add;
+};
+
+#define PROV_SET_TRACKED      0x01
+#define PROV_SET_OPAQUE       0x02
+#define PROV_SET_PROPAGATE    0x04
+#define PROV_SET_TAINT        0x08
+
+struct prov_process_config {
+	union prov_elt prov;
+	uint8_t op;
+	uint32_t vpid;
+};
+
+#define PROV_NET_TRACKED      0x01
+#define PROV_NET_OPAQUE       0x02
+#define PROV_NET_PROPAGATE    0x04
+#define PROV_NET_TAINT        0x08
+#define PROV_NET_RECORD       0x10
+#define PROV_NET_DELETE       0x20 // to actually delete a filter from the list
+
+struct prov_ipv4_filter {
+	uint32_t ip;
+	uint32_t mask;
+	uint16_t port;
+	uint8_t op;
+	uint64_t taint;
+};
+
+#define PROV_SEC_TRACKED      0x01
+#define PROV_SEC_OPAQUE       0x02
+#define PROV_SEC_PROPAGATE    0x04
+#define PROV_SEC_TAINT        0x08
+#define PROV_SEC_DELETE       0x10 // to actually delete a filter from the list
+
+struct secinfo {
+	uint32_t secid;
+	char secctx[PATH_MAX];
+	uint32_t len;
+	uint8_t op;
+	uint64_t taint;
+};
+
+#define PROV_NS_TRACKED      0x01
+#define PROV_NS_OPAQUE       0x02
+#define PROV_NS_PROPAGATE    0x04
+#define PROV_NS_TAINT        0x08
+#define PROV_NS_DELETE       0x10 // to actually delete a filter from the list
+#define IGNORE_NS 0
+
+struct nsinfo {
+	uint32_t utsns;
+	uint32_t ipcns;
+	uint32_t mntns;
+	uint32_t pidns;
+	uint32_t netns;
+	uint32_t cgroupns;
+	uint8_t op;
+	uint64_t taint;
+};
+
+#endif
diff -uprN -b -B ./pristine/linux-4.11.2/include/uapi/linux/xattr.h ./linux-4.11.2/include/uapi/linux/xattr.h
--- ./pristine/linux-4.11.2/include/uapi/linux/xattr.h	2017-05-20 13:50:04.000000000 +0100
+++ ./linux-4.11.2/include/uapi/linux/xattr.h	2017-05-22 10:47:47.730667817 +0100
@@ -52,6 +52,9 @@
 #define XATTR_SELINUX_SUFFIX "selinux"
 #define XATTR_NAME_SELINUX XATTR_SECURITY_PREFIX XATTR_SELINUX_SUFFIX
 
+#define XATTR_PROVENANCE_SUFFIX "provenance"
+#define XATTR_NAME_PROVENANCE XATTR_SECURITY_PREFIX XATTR_PROVENANCE_SUFFIX
+
 #define XATTR_SMACK_SUFFIX "SMACK64"
 #define XATTR_SMACK_IPIN "SMACK64IPIN"
 #define XATTR_SMACK_IPOUT "SMACK64IPOUT"
diff -uprN -b -B ./pristine/linux-4.11.2/Makefile ./linux-4.11.2/Makefile
--- ./pristine/linux-4.11.2/Makefile	2017-05-20 13:50:04.000000000 +0100
+++ ./linux-4.11.2/Makefile	2017-05-22 09:02:11.323773472 +0100
@@ -1,7 +1,7 @@
 VERSION = 4
 PATCHLEVEL = 11
 SUBLEVEL = 2
-EXTRAVERSION =
+EXTRAVERSION = camflow-0.3.1
 NAME = Fearless Coyote
 
 # *DOCUMENTATION*
diff -uprN -b -B ./pristine/linux-4.11.2/security/Kconfig ./linux-4.11.2/security/Kconfig
--- ./pristine/linux-4.11.2/security/Kconfig	2017-05-20 13:50:04.000000000 +0100
+++ ./linux-4.11.2/security/Kconfig	2017-05-22 10:47:47.531666115 +0100
@@ -199,6 +199,7 @@ source security/tomoyo/Kconfig
 source security/apparmor/Kconfig
 source security/loadpin/Kconfig
 source security/yama/Kconfig
+source security/provenance/Kconfig
 
 source security/integrity/Kconfig
 
diff -uprN -b -B ./pristine/linux-4.11.2/security/Makefile ./linux-4.11.2/security/Makefile
--- ./pristine/linux-4.11.2/security/Makefile	2017-05-20 13:50:04.000000000 +0100
+++ ./linux-4.11.2/security/Makefile	2017-05-22 10:47:47.542666209 +0100
@@ -8,6 +8,7 @@ subdir-$(CONFIG_SECURITY_SMACK)		+= smac
 subdir-$(CONFIG_SECURITY_TOMOYO)        += tomoyo
 subdir-$(CONFIG_SECURITY_APPARMOR)	+= apparmor
 subdir-$(CONFIG_SECURITY_YAMA)		+= yama
+subdir-$(CONFIG_SECURITY_PROVENANCE)	+= provenance
 subdir-$(CONFIG_SECURITY_LOADPIN)	+= loadpin
 
 # always enable default capabilities
@@ -23,6 +24,7 @@ obj-$(CONFIG_AUDIT)			+= lsm_audit.o
 obj-$(CONFIG_SECURITY_TOMOYO)		+= tomoyo/
 obj-$(CONFIG_SECURITY_APPARMOR)		+= apparmor/
 obj-$(CONFIG_SECURITY_YAMA)		+= yama/
+obj-$(CONFIG_SECURITY_PROVENANCE)		+= provenance/
 obj-$(CONFIG_SECURITY_LOADPIN)		+= loadpin/
 obj-$(CONFIG_CGROUP_DEVICE)		+= device_cgroup.o
 
diff -uprN -b -B ./pristine/linux-4.11.2/security/provenance/fs.c ./linux-4.11.2/security/provenance/fs.c
--- ./pristine/linux-4.11.2/security/provenance/fs.c	1970-01-01 01:00:00.000000000 +0100
+++ ./linux-4.11.2/security/provenance/fs.c	2017-05-22 10:47:47.561666371 +0100
@@ -0,0 +1,797 @@
+/*
+ *
+ * Author: Thomas Pasquier <thomas.pasquier@cl.cam.ac.uk>
+ *
+ * Copyright (C) 2015 University of Cambridge
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2, as
+ * published by the Free Software Foundation; either version 2 of the License,
+ * or (at your option) any later version.
+ *
+ */
+#include <linux/security.h>
+#include <crypto/hash.h>
+
+#include "provenance.h"
+#include "provenance_inode.h"
+#include "provenance_net.h"
+#include "provenance_task.h"
+
+#define TMPBUFLEN       12
+
+#define declare_file_operations(ops_name, write_op, read_op) static const struct file_operations ops_name = { \
+		.write		= write_op, \
+		.read		= read_op, \
+		.llseek		= generic_file_llseek, \
+}
+
+static ssize_t no_read(struct file *filp, char __user *buf, size_t count, loff_t *ppos)
+{
+	return -EPERM; // write only
+}
+
+static ssize_t no_write(struct file *file, const char __user *buf,
+			size_t count, loff_t *ppos)
+{
+	return -EPERM; // read only
+}
+
+static inline void __init_opaque(void)
+{
+	provenance_mark_as_opaque(PROV_ENABLE_FILE);
+	provenance_mark_as_opaque(PROV_ALL_FILE);
+	provenance_mark_as_opaque(PROV_NODE_FILE);
+	provenance_mark_as_opaque(PROV_RELATION_FILE);
+	provenance_mark_as_opaque(PROV_SELF_FILE);
+	provenance_mark_as_opaque(PROV_MACHINE_ID_FILE);
+	provenance_mark_as_opaque(PROV_BOOT_ID_FILE);
+	provenance_mark_as_opaque(PROV_NODE_FILTER_FILE);
+	provenance_mark_as_opaque(PROV_RELATION_FILTER_FILE);
+	provenance_mark_as_opaque(PROV_PROPAGATE_NODE_FILTER_FILE);
+	provenance_mark_as_opaque(PROV_PROPAGATE_RELATION_FILTER_FILE);
+	provenance_mark_as_opaque(PROV_FLUSH_FILE);
+	provenance_mark_as_opaque(PROV_PROCESS_FILE);
+	provenance_mark_as_opaque(PROV_IPV4_INGRESS_FILE);
+	provenance_mark_as_opaque(PROV_IPV4_EGRESS_FILE);
+	provenance_mark_as_opaque(PROV_SECCTX);
+	provenance_mark_as_opaque(PROV_SECCTX_FILTER);
+	provenance_mark_as_opaque(PROV_NS_FILTER);
+	provenance_mark_as_opaque(PROV_LOG_FILE);
+	provenance_mark_as_opaque(PROV_LOGP_FILE);
+	provenance_mark_as_opaque(PROV_POLICY_HASH_FILE);
+}
+
+static inline ssize_t __write_flag(struct file *file, const char __user *buf,
+				   size_t count, loff_t *ppos, bool *flag)
+
+{
+	char *page = NULL;
+	ssize_t length;
+	bool new_value;
+	uint32_t tmp;
+
+	/* no partial write */
+	if (*ppos > 0)
+		return -EINVAL;
+
+	if (!capable(CAP_AUDIT_CONTROL))
+		return -EPERM;
+
+	page = (char *)get_zeroed_page(GFP_KERNEL);
+	if (!page)
+		return -ENOMEM;
+
+	length =  -EFAULT;
+	if (copy_from_user(page, buf, count))
+		goto out;
+
+	length = kstrtouint(page, 2, &tmp);
+	if (length)
+		goto out;
+
+	new_value = tmp;
+	(*flag) = new_value;
+	length = count;
+out:
+	free_page((unsigned long)page);
+	return length;
+}
+
+static ssize_t __read_flag(struct file *filp, char __user *buf,
+			   size_t count, loff_t *ppos, bool flag)
+{
+	char tmpbuf[TMPBUFLEN];
+	ssize_t length;
+	int tmp = flag;
+
+	length = scnprintf(tmpbuf, TMPBUFLEN, "%d", tmp);
+	return simple_read_from_buffer(buf, count, ppos, tmpbuf, length);
+}
+
+#define declare_write_flag_fcn(fcn_name, flag) static ssize_t fcn_name(struct file *file, const char __user *buf, size_t count, loff_t *ppos) \
+	{ \
+		return __write_flag(file, buf, count, ppos, &flag); \
+	}
+#define declare_read_flag_fcn(fcn_name, flag) static ssize_t fcn_name(struct file *filp, char __user *buf, size_t count, loff_t *ppos) \
+	{ \
+		return __read_flag(filp, buf, count, ppos, flag); \
+	}
+
+declare_write_flag_fcn(prov_write_enable, prov_policy.prov_enabled);
+declare_read_flag_fcn(prov_read_enable, prov_policy.prov_enabled);
+declare_file_operations(prov_enable_ops, prov_write_enable, prov_read_enable);
+
+declare_write_flag_fcn(prov_write_all, prov_policy.prov_all);
+declare_read_flag_fcn(prov_read_all, prov_policy.prov_all);
+declare_file_operations(prov_all_ops, prov_write_all, prov_read_all);
+
+static ssize_t prov_write_machine_id(struct file *file, const char __user *buf,
+				     size_t count, loff_t *ppos)
+{
+	uint32_t *tmp = (uint32_t *)buf;
+
+	// ideally should be decoupled from set machine id
+	__init_opaque();
+
+	if (!capable(CAP_AUDIT_CONTROL))
+		return -EPERM;
+
+	if (count < sizeof(uint32_t))
+		return -ENOMEM;
+
+	if (copy_from_user(&prov_machine_id, tmp, sizeof(uint32_t)))
+		return -EAGAIN;
+
+	return count; // read only
+}
+
+static ssize_t prov_read_machine_id(struct file *filp, char __user *buf,
+				    size_t count, loff_t *ppos)
+{
+	if (count < sizeof(uint32_t))
+		return -ENOMEM;
+
+	if (copy_to_user(buf, &prov_machine_id, sizeof(uint32_t)))
+		return -EAGAIN;
+
+	return count;
+}
+declare_file_operations(prov_machine_id_ops, prov_write_machine_id, prov_read_machine_id);
+
+static ssize_t prov_write_boot_id(struct file *file, const char __user *buf,
+				     size_t count, loff_t *ppos)
+{
+	uint32_t *tmp = (uint32_t *)buf;
+
+	// ideally should be decoupled from set machine id
+	__init_opaque();
+
+	if (!capable(CAP_AUDIT_CONTROL))
+		return -EPERM;
+
+	if (count < sizeof(uint32_t))
+		return -ENOMEM;
+
+	if (copy_from_user(&prov_boot_id, tmp, sizeof(uint32_t)))
+		return -EAGAIN;
+
+	return count; // read only
+}
+
+static ssize_t prov_read_boot_id(struct file *filp, char __user *buf,
+				    size_t count, loff_t *ppos)
+{
+	if (count < sizeof(uint32_t))
+		return -ENOMEM;
+
+	if (copy_to_user(buf, &prov_boot_id, sizeof(uint32_t)))
+		return -EAGAIN;
+
+	return count;
+}
+declare_file_operations(prov_boot_id_ops, prov_write_boot_id, prov_read_boot_id);
+
+
+static ssize_t prov_write_node(struct file *file, const char __user *buf,
+			       size_t count, loff_t *ppos)
+
+{
+	struct provenance *cprov = current_provenance();
+	union long_prov_elt *node = NULL;
+
+	if (!capable(CAP_AUDIT_WRITE))
+		return -EPERM;
+
+	if (count < sizeof(struct disc_node_struct))
+		return -ENOMEM;
+
+	node = kzalloc(sizeof(union long_prov_elt), GFP_KERNEL);
+	if (!node)
+		return -ENOMEM;
+
+	if (copy_from_user(node, buf, sizeof(struct disc_node_struct))) {
+		count = -ENOMEM;
+		goto out;
+	}
+	if (prov_type(node) == ENT_DISC || prov_type(node) == ACT_DISC || prov_type(node) == AGT_DISC) {
+		spin_lock_nested(prov_lock(cprov), PROVENANCE_LOCK_TASK);
+		write_node(prov_elt(cprov));
+		copy_identifier(&node->disc_node_info.parent, &prov_elt(cprov)->node_info.identifier);
+		spin_unlock(prov_lock(cprov));
+		node_identifier(node).id = prov_next_node_id();
+		node_identifier(node).boot_id = prov_boot_id;
+		node_identifier(node).machine_id = prov_machine_id;
+		long_prov_write(node);
+	} else{ // the node is not of disclosed type
+		count = -EINVAL;
+		goto out;
+	}
+
+	if (copy_to_user((void *)buf, &node, count)) {
+		count = -ENOMEM;
+		goto out;
+	}
+
+out:
+	if (node)
+		kfree(node);
+	return count;
+}
+declare_file_operations(prov_node_ops, prov_write_node, no_read);
+
+static ssize_t prov_write_relation(struct file *file, const char __user *buf,
+				   size_t count, loff_t *ppos)
+{
+	union prov_elt relation;
+
+	if (!capable(CAP_AUDIT_WRITE))
+		return -EPERM;
+
+	if (count < sizeof(struct relation_struct))
+		return -ENOMEM;
+
+	if (copy_from_user(&relation, buf, sizeof(struct relation_struct)))
+		return -ENOMEM;
+
+	prov_write(&relation);
+	return count;
+}
+declare_file_operations(prov_relation_ops, prov_write_relation, no_read);
+
+static inline void update_prov_config(union prov_elt *setting, uint8_t op, struct provenance *prov)
+{
+	spin_lock_nested(prov_lock(prov), PROVENANCE_LOCK_TASK);
+	if ((op & PROV_SET_TRACKED) != 0) {
+		if (provenance_is_tracked(setting))
+			set_tracked(prov_elt(prov));
+		else
+			clear_tracked(prov_elt(prov));
+	}
+
+	if ((op & PROV_SET_OPAQUE) != 0) {
+		if (provenance_is_opaque(setting))
+			set_opaque(prov_elt(prov));
+		else
+			clear_opaque(prov_elt(prov));
+	}
+
+	if ((op & PROV_SET_PROPAGATE) != 0) {
+		if (provenance_does_propagate(setting))
+			set_propagate(prov_elt(prov));
+		else
+			clear_propagate(prov_elt(prov));
+	}
+
+	if ((op & PROV_SET_TAINT) != 0)
+		prov_bloom_merge(prov_taint(prov_elt(prov)), prov_taint(setting));
+	spin_unlock(prov_lock(prov));
+}
+
+static ssize_t prov_write_self(struct file *file, const char __user *buf,
+			       size_t count, loff_t *ppos)
+{
+	struct prov_process_config msg;
+	struct provenance *prov = current_provenance();
+
+	if (count < sizeof(struct prov_process_config))
+		return -EINVAL;
+
+	if (copy_from_user(&msg, buf, sizeof(struct prov_process_config)))
+		return -ENOMEM;
+
+	update_prov_config(&(msg.prov), msg.op, prov);
+	return sizeof(struct prov_process_config);
+}
+
+static ssize_t prov_read_self(struct file *filp, char __user *buf,
+			      size_t count, loff_t *ppos)
+{
+	struct provenance *cprov = current_provenance();
+	union prov_elt *tmp = (union prov_elt *)buf;
+
+	if (count < sizeof(struct task_prov_struct))
+		return -ENOMEM;
+
+	spin_lock_nested(prov_lock(cprov), PROVENANCE_LOCK_TASK);
+	if (copy_to_user(tmp, prov_elt(cprov), sizeof(union prov_elt)))
+		count = -EAGAIN;
+	spin_unlock(prov_lock(cprov));
+	return count; // write only
+}
+declare_file_operations(prov_self_ops, prov_write_self, prov_read_self);
+
+static inline ssize_t __write_filter(struct file *file, const char __user *buf,
+				     size_t count, uint64_t *filter)
+{
+	struct prov_filter *setting;
+
+	if (!capable(CAP_AUDIT_CONTROL))
+		return -EPERM;
+
+	if (count < sizeof(struct prov_filter))
+		return -ENOMEM;
+
+	setting = (struct prov_filter *)buf;
+
+	if (setting->add != 0)
+		(*filter) |= setting->filter & setting->mask;
+	else
+		(*filter) &=  ~(setting->filter & setting->mask);
+
+	return count;
+}
+
+static inline ssize_t __read_filter(struct file *filp, char __user *buf,
+				    size_t count, uint64_t filter)
+{
+	if (count < sizeof(uint64_t))
+		return -ENOMEM;
+
+	if (copy_to_user(buf, &filter, sizeof(uint64_t)))
+		return -EAGAIN;
+
+	return count;
+}
+
+#define declare_write_filter_fcn(fcn_name, filter) static ssize_t fcn_name(struct file *file, const char __user *buf, size_t count, loff_t *ppos) \
+	{ \
+		return __write_filter(file, buf, count, &filter); \
+	}
+#define declare_reader_filter_fcn(fcn_name, filter) static ssize_t fcn_name(struct file *filp, char __user *buf, size_t count, loff_t *ppos) \
+	{ \
+		return __read_filter(filp, buf, count, filter); \
+	}
+
+declare_write_filter_fcn(prov_write_node_filter, prov_policy.prov_node_filter);
+declare_reader_filter_fcn(prov_read_node_filter, prov_policy.prov_node_filter);
+declare_file_operations(prov_node_filter_ops, prov_write_node_filter, prov_read_node_filter);
+
+declare_write_filter_fcn(prov_write_relation_filter, prov_policy.prov_relation_filter);
+declare_reader_filter_fcn(prov_read_relation_filter, prov_policy.prov_relation_filter);
+declare_file_operations(prov_relation_filter_ops, prov_write_relation_filter, prov_read_relation_filter);
+
+declare_write_filter_fcn(prov_write_propagate_node_filter, prov_policy.prov_propagate_node_filter);
+declare_reader_filter_fcn(prov_read_propagate_node_filter, prov_policy.prov_propagate_node_filter);
+declare_file_operations(prov_propagate_node_filter_ops, prov_write_propagate_node_filter, prov_read_propagate_node_filter);
+
+declare_write_filter_fcn(prov_write_propagate_relation_filter, prov_policy.prov_propagate_relation_filter);
+declare_reader_filter_fcn(prov_read_propagate_relation_filter, prov_policy.prov_propagate_relation_filter);
+declare_file_operations(prov_propagate_relation_filter_ops, prov_write_propagate_relation_filter, prov_read_propagate_relation_filter);
+
+static ssize_t prov_write_flush(struct file *file, const char __user *buf,
+				size_t count, loff_t *ppos)
+
+{
+	if (!capable(CAP_AUDIT_CONTROL))
+		return -EPERM;
+
+	prov_flush();
+	return 0;
+}
+declare_file_operations(prov_flush_ops, prov_write_flush, no_read);
+
+static ssize_t prov_write_process(struct file *file, const char __user *buf,
+				  size_t count, loff_t *ppos)
+{
+	struct prov_process_config msg;
+	struct provenance *prov;
+
+	if (!capable(CAP_AUDIT_CONTROL))
+		return -EPERM;
+
+	if (count < sizeof(struct prov_process_config))
+		return -EINVAL;
+
+	if (copy_from_user(&msg, buf, sizeof(struct prov_process_config)))
+		return -ENOMEM;
+
+	prov = prov_from_vpid(msg.vpid);
+	if (!prov)
+		return -EINVAL;
+
+	update_prov_config(&(msg.prov), msg.op, prov);
+	return sizeof(struct prov_process_config);
+}
+
+static ssize_t prov_read_process(struct file *filp, char __user *buf,
+				 size_t count, loff_t *ppos)
+{
+	struct prov_process_config *msg;
+	struct provenance *prov;
+	int rtn = sizeof(struct prov_process_config);
+
+	if (count < sizeof(struct prov_process_config))
+		return -EINVAL;
+
+	msg = (struct prov_process_config *)buf;
+
+	prov = prov_from_vpid(msg->vpid);
+	if (!prov)
+		return -EINVAL;
+
+	spin_lock_nested(prov_lock(prov), PROVENANCE_LOCK_TASK);
+	if (copy_to_user(&msg->prov, prov_elt(prov), sizeof(union prov_elt)))
+		rtn = -ENOMEM;
+	spin_unlock(prov_lock(prov));
+	return rtn;
+}
+declare_file_operations(prov_process_ops, prov_write_process, prov_read_process);
+
+static inline ssize_t __write_ipv4_filter(struct file *file, const char __user *buf,
+					  size_t count, struct list_head *filters)
+{
+	struct ipv4_filters     *f;
+
+	if (!capable(CAP_AUDIT_CONTROL))
+		return -EPERM;
+
+	if (count < sizeof(struct prov_ipv4_filter))
+		return -ENOMEM;
+
+	f = kzalloc(sizeof(struct ipv4_filters), GFP_KERNEL);
+	if (!f)
+		return -ENOMEM;
+
+	if (copy_from_user(&f->filter, buf, sizeof(struct prov_ipv4_filter)))
+		return -EAGAIN;
+	f->filter.ip = f->filter.ip & f->filter.mask;
+
+	// we are not trying to delete something
+	if ((f->filter.op & PROV_NET_DELETE) != PROV_NET_DELETE)
+		prov_ipv4_add_or_update(filters, f);
+	else
+		prov_ipv4_delete(filters, f);
+	return sizeof(struct prov_ipv4_filter);
+}
+
+static inline ssize_t __read_ipv4_filter(struct file *filp, char __user *buf,
+					 size_t count, struct list_head *filters)
+{
+	struct list_head *listentry, *listtmp;
+	struct ipv4_filters *tmp;
+	size_t pos = 0;
+
+	if (count < sizeof(struct prov_ipv4_filter))
+		return -ENOMEM;
+
+	list_for_each_safe(listentry, listtmp, filters) {
+		tmp = list_entry(listentry, struct ipv4_filters, list);
+		if (count < pos + sizeof(struct prov_ipv4_filter))
+			return -ENOMEM;
+
+		if (copy_to_user(buf + pos, &(tmp->filter), sizeof(struct prov_ipv4_filter)))
+			return -EAGAIN;
+
+		pos += sizeof(struct prov_ipv4_filter);
+	}
+	return pos;
+}
+
+#define declare_write_ipv4_filter_fcn(fcn_name, filter) static ssize_t fcn_name(struct file *file, const char __user *buf, size_t count, loff_t *ppos) \
+	{ \
+		return __write_ipv4_filter(file, buf, count, &filter); \
+	}
+#define declare_reader_ipv4_filter_fcn(fcn_name, filter) static ssize_t fcn_name(struct file *filp, char __user *buf, size_t count, loff_t *ppos) \
+	{ \
+		return __read_ipv4_filter(filp, buf, count, &filter); \
+	}
+
+declare_write_ipv4_filter_fcn(prov_write_ipv4_ingress_filter, ingress_ipv4filters);
+declare_reader_ipv4_filter_fcn(prov_read_ipv4_ingress_filter, ingress_ipv4filters);
+declare_file_operations(prov_ipv4_ingress_filter_ops, prov_write_ipv4_ingress_filter, prov_read_ipv4_ingress_filter);
+
+declare_write_ipv4_filter_fcn(prov_write_ipv4_egress_filter, egress_ipv4filters);
+declare_reader_ipv4_filter_fcn(prov_read_ipv4_egress_filter, egress_ipv4filters);
+declare_file_operations(prov_ipv4_egress_filter_ops, prov_write_ipv4_egress_filter, prov_read_ipv4_egress_filter);
+
+static ssize_t prov_read_secctx(struct file *filp, char __user *buf,
+				size_t count, loff_t *ppos)
+{
+	char *ctx = NULL;
+	uint32_t len;
+	struct secinfo *data;
+	int rtn = 0;
+
+	if (count < sizeof(struct secinfo))
+		return -ENOMEM;
+	data = (struct secinfo *)buf;
+
+	rtn = security_secid_to_secctx(data->secid, &ctx, &len); // read secctx
+	if (rtn < 0)
+		goto out;
+	if (len < PATH_MAX) {
+		if (copy_to_user(data->secctx, ctx, len)) {
+			rtn = -ENOMEM;
+			goto out;
+		}
+		data->secctx[len] = '\0'; // maybe unecessary
+		data->len = len;
+	} else
+		rtn = -ENOMEM;
+out:
+	security_release_secctx(ctx, len); // security module dealloc
+	return rtn;
+}
+declare_file_operations(prov_secctx_ops, no_write, prov_read_secctx);
+
+static ssize_t prov_write_secctx_filter(struct file *file, const char __user *buf,
+					size_t count, loff_t *ppos)
+{
+	struct secctx_filters *s;
+
+	if (count < sizeof(struct secinfo))
+		return -ENOMEM;
+
+	s = kzalloc(sizeof(struct secctx_filters), GFP_KERNEL);
+	if (!s)
+		return -ENOMEM;
+
+	if (copy_from_user(&s->filter, buf, sizeof(struct secinfo)))
+		return -EAGAIN;
+
+	security_secctx_to_secid(s->filter.secctx, s->filter.len, &s->filter.secid);
+	if ((s->filter.op & PROV_SEC_DELETE) != PROV_SEC_DELETE)
+		prov_secctx_add_or_update(s);
+	else
+		prov_secctx_delete(s);
+	return 0;
+}
+
+static ssize_t prov_read_secctx_filter(struct file *filp, char __user *buf,
+				       size_t count, loff_t *ppos)
+{
+	struct list_head *listentry, *listtmp;
+	struct secctx_filters *tmp;
+	size_t pos = 0;
+
+	if (count < sizeof(struct secinfo))
+		return -ENOMEM;
+
+	list_for_each_safe(listentry, listtmp, &secctx_filters) {
+		tmp = list_entry(listentry, struct secctx_filters, list);
+		if (count < pos + sizeof(struct secinfo))
+			return -ENOMEM;
+
+		if (copy_to_user(buf + pos, &(tmp->filter), sizeof(struct secinfo)))
+			return -EAGAIN;
+		pos += sizeof(struct secinfo);
+	}
+	return pos;
+}
+declare_file_operations(prov_secctx_filter_ops, prov_write_secctx_filter, prov_read_secctx_filter);
+
+static ssize_t prov_write_ns_filter(struct file *file, const char __user *buf,
+					size_t count, loff_t *ppos)
+{
+	struct ns_filters *s;
+
+	if (count < sizeof(struct nsinfo))
+		return -ENOMEM;
+
+	s = kzalloc(sizeof(struct ns_filters), GFP_KERNEL);
+	if (!s)
+		return -ENOMEM;
+
+	if (copy_from_user(&s->filter, buf, sizeof(struct nsinfo)))
+		return -EAGAIN;
+	if ((s->filter.op & PROV_NS_DELETE) != PROV_NS_DELETE)
+		prov_ns_add_or_update(s);
+	else
+		prov_ns_delete(s);
+	return 0;
+}
+
+static ssize_t prov_read_ns_filter(struct file *filp, char __user *buf,
+				       size_t count, loff_t *ppos)
+{
+	struct list_head *listentry, *listtmp;
+	struct ns_filters *tmp;
+	size_t pos = 0;
+
+	if (count < sizeof(struct nsinfo))
+		return -ENOMEM;
+
+	list_for_each_safe(listentry, listtmp, &ns_filters) {
+		tmp = list_entry(listentry, struct ns_filters, list);
+		if (count < pos + sizeof(struct nsinfo))
+			return -ENOMEM;
+		if (copy_to_user(buf + pos, &(tmp->filter), sizeof(struct nsinfo)))
+			return -EAGAIN;
+		pos += sizeof(struct nsinfo);
+	}
+	return pos;
+}
+declare_file_operations(prov_ns_filter_ops, prov_write_ns_filter, prov_read_ns_filter);
+
+static ssize_t prov_write_log(struct file *file, const char __user *buf,
+			      size_t count, loff_t *ppos)
+{
+	struct provenance *cprov = current_provenance();
+
+	if (count <= 0 || count >= PATH_MAX)
+		return 0;
+	set_tracked(prov_elt(cprov));
+	return record_log(prov_elt(cprov), buf, count);
+}
+declare_file_operations(prov_log_ops, prov_write_log, no_read);
+
+static ssize_t prov_write_logp(struct file *file, const char __user *buf,
+			       size_t count, loff_t *ppos)
+{
+	struct provenance *cprov = current_provenance();
+
+	if (count <= 0 || count >= PATH_MAX)
+		return 0;
+	set_tracked(prov_elt(cprov));
+	set_propagate(prov_elt(cprov));
+	return record_log(prov_elt(cprov), buf, count);
+}
+declare_file_operations(prov_logp_ops, prov_write_logp, no_read);
+
+static ssize_t prov_read_policy_hash(struct file *filp, char __user *buf,
+				       size_t count, loff_t *ppos)
+{
+	size_t pos = 0;
+	size_t size;
+	int rc;
+	struct crypto_shash *policy_shash_tfm;
+	struct shash_desc *hashdesc = NULL;
+	uint8_t* buff = NULL;
+	struct list_head *listentry, *listtmp;
+	struct ipv4_filters *ipv4_tmp;
+	struct ns_filters *ns_tmp;
+	struct secctx_filters *secctx_tmp;
+
+	policy_shash_tfm = crypto_alloc_shash(PROVENANCE_HASH, 0, 0);
+	if(IS_ERR(policy_shash_tfm))
+		return -ENOMEM;
+	pos = crypto_shash_digestsize(policy_shash_tfm);
+	if(count < pos)
+		return -ENOMEM;
+	buff = kzalloc(pos, GFP_KERNEL);
+	if(!buff){
+		pr_err("Provenance: error allocating hash buffer.");
+		pos = -ENOMEM;
+		goto out;
+	}
+	size = sizeof(struct shash_desc) + crypto_shash_descsize(policy_shash_tfm);
+	hashdesc = (struct shash_desc*)kzalloc(size, GFP_KERNEL);
+	if(!hashdesc){
+		pr_err("Provenance: error allocating hash desc.");
+		pos = -ENOMEM;
+		goto out;
+	}
+	hashdesc->tfm = policy_shash_tfm;
+	hashdesc->flags = 0x0;
+	rc = crypto_shash_init(hashdesc);
+	if(rc){
+		pr_err("Provenance: error initialising hash.");
+		pos = -EAGAIN;
+		goto out;
+	}
+	/* LSM version */
+	rc = crypto_shash_update(hashdesc, (u8*)CAMFLOW_VERSION_STR, strlen(CAMFLOW_VERSION_STR));
+	if(rc){
+		pr_err("Provenance: error updating hash.");
+		pos = -EAGAIN;
+		goto out;
+	}
+	/* general policy */
+	rc = crypto_shash_update(hashdesc, (u8*)&prov_policy, sizeof(struct capture_policy));
+	if(rc){
+		pr_err("Provenance: error updating hash.");
+		pos = -EAGAIN;
+		goto out;
+	}
+	/* ingress network policy */
+	list_for_each_safe(listentry, listtmp, &ingress_ipv4filters) {
+		ipv4_tmp = list_entry(listentry, struct ipv4_filters, list);
+		rc = crypto_shash_update(hashdesc, (u8*)&ipv4_tmp->filter, sizeof(struct prov_ipv4_filter));
+		if(rc){
+			pr_err("Provenance: error updating hash.");
+			pos = -EAGAIN;
+			goto out;
+		}
+	}
+	/* egress network policy */
+	list_for_each_safe(listentry, listtmp, &egress_ipv4filters) {
+		ipv4_tmp = list_entry(listentry, struct ipv4_filters, list);
+		rc = crypto_shash_update(hashdesc, (u8*)&ipv4_tmp->filter, sizeof(struct prov_ipv4_filter));
+		if(rc){
+			pr_err("Provenance: error updating hash.");
+			pos = -EAGAIN;
+			goto out;
+		}
+	}
+	/* namespace policy */
+	list_for_each_safe(listentry, listtmp, &ns_filters) {
+		ns_tmp = list_entry(listentry, struct ns_filters, list);
+		rc = crypto_shash_update(hashdesc, (u8*)&ns_tmp->filter, sizeof(struct nsinfo));
+		if(rc){
+			pr_err("Provenance: error updating hash.");
+			pos = -EAGAIN;
+			goto out;
+		}
+	}
+	/* secctx policy */
+	list_for_each_safe(listentry, listtmp, &secctx_filters) {
+		secctx_tmp = list_entry(listentry, struct secctx_filters, list);
+		rc = crypto_shash_update(hashdesc, (u8*)&secctx_tmp->filter, sizeof(struct secinfo));
+		if(rc){
+			pr_err("Provenance: error updating hash.");
+			pos = -EAGAIN;
+			goto out;
+		}
+	}
+	rc = crypto_shash_final(hashdesc, buff);
+	if(rc){
+		pr_err("Provenance: error finialising hash.");
+		pos = -EAGAIN;
+		goto out;
+	}
+	if (copy_to_user(buf, buff, pos)){
+		pr_err("Provenance: error copying hash to user.");
+		pos = -EAGAIN;
+		goto out;
+	}
+out:
+	if(!buff)
+		kfree(buff);
+	if(!hashdesc)
+		kfree(hashdesc);
+	crypto_free_shash(policy_shash_tfm);
+	return pos;
+}
+declare_file_operations(prov_policy_hash_ops, no_write, prov_read_policy_hash);
+
+static int __init init_prov_fs(void)
+{
+	struct dentry *prov_dir;
+
+	prov_dir = securityfs_create_dir("provenance", NULL);
+	securityfs_create_file("enable", 0644, prov_dir, NULL, &prov_enable_ops);
+	securityfs_create_file("all", 0644, prov_dir, NULL, &prov_all_ops);
+	securityfs_create_file("node", 0666, prov_dir, NULL, &prov_node_ops);
+	securityfs_create_file("relation", 0666, prov_dir, NULL, &prov_relation_ops);
+	securityfs_create_file("self", 0666, prov_dir, NULL, &prov_self_ops);
+	securityfs_create_file("machine_id", 0444, prov_dir, NULL, &prov_machine_id_ops);
+	securityfs_create_file("boot_id", 0444, prov_dir, NULL, &prov_boot_id_ops);
+	securityfs_create_file("node_filter", 0644, prov_dir, NULL, &prov_node_filter_ops);
+	securityfs_create_file("relation_filter", 0644, prov_dir, NULL, &prov_relation_filter_ops);
+	securityfs_create_file("propagate_node_filter", 0644, prov_dir, NULL, &prov_propagate_node_filter_ops);
+	securityfs_create_file("propagate_relation_filter", 0644, prov_dir, NULL, &prov_propagate_relation_filter_ops);
+	securityfs_create_file("flush", 0600, prov_dir, NULL, &prov_flush_ops);
+	securityfs_create_file("process", 0644, prov_dir, NULL, &prov_process_ops);
+	securityfs_create_file("ipv4_ingress", 0644, prov_dir, NULL, &prov_ipv4_ingress_filter_ops);
+	securityfs_create_file("ipv4_egress", 0644, prov_dir, NULL, &prov_ipv4_egress_filter_ops);
+	securityfs_create_file("secctx", 0644, prov_dir, NULL, &prov_secctx_ops);
+	securityfs_create_file("secctx_filter", 0644, prov_dir, NULL, &prov_secctx_filter_ops);
+	securityfs_create_file("ns", 0644, prov_dir, NULL, &prov_ns_filter_ops);
+	securityfs_create_file("log", 0666, prov_dir, NULL, &prov_log_ops);
+	securityfs_create_file("logp", 0666, prov_dir, NULL, &prov_logp_ops);
+	securityfs_create_file("policy_hash", 0444, prov_dir, NULL, &prov_policy_hash_ops);
+	pr_info("Provenance: fs ready.\n");
+	return 0;
+}
+core_initcall(init_prov_fs);
diff -uprN -b -B ./pristine/linux-4.11.2/security/provenance/hooks.c ./linux-4.11.2/security/provenance/hooks.c
--- ./pristine/linux-4.11.2/security/provenance/hooks.c	1970-01-01 01:00:00.000000000 +0100
+++ ./linux-4.11.2/security/provenance/hooks.c	2017-05-22 10:47:47.561666371 +0100
@@ -0,0 +1,1600 @@
+/*
+ *
+ * Author: Thomas Pasquier <thomas.pasquier@cl.cam.ac.uk>
+ *
+ * Copyright (C) 2015 University of Cambridge
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2, as
+ * published by the Free Software Foundation; either version 2 of the License,
+ * or (at your option) any later version.
+ *
+ */
+#include <linux/slab.h>
+#include <linux/lsm_hooks.h>
+#include <linux/msg.h>
+#include <net/sock.h>
+#include <linux/binfmts.h>
+#include <linux/random.h>
+#include <linux/xattr.h>
+#include <linux/file.h>
+#include <linux/workqueue.h>
+
+#include "provenance.h"
+#include "provenance_net.h"
+#include "provenance_inode.h"
+#include "provenance_task.h"
+
+#ifdef CONFIG_SECURITY_PROVENANCE_PERSISTENCE
+struct save_work {
+	struct work_struct work;
+	struct dentry *dentry;
+};
+
+static void __do_prov_save(struct work_struct *pwork)
+{
+	struct save_work *w = container_of(pwork, struct save_work, work);
+	struct dentry *dentry = w->dentry;
+
+	if (!dentry)
+		goto free_work;
+	save_provenance(dentry);
+free_work:
+	kfree(w);
+}
+
+static struct workqueue_struct *prov_queue;
+static inline void queue_save_provenance(struct provenance *provenance,
+				  struct dentry *dentry)
+{
+	struct save_work *work;
+
+	if (!prov_queue)
+		return;
+	// not initialised or already saved
+	if (!provenance->initialised || provenance->saved)
+		return;
+	work = kmalloc(sizeof(struct save_work), GFP_ATOMIC);
+	if (!work)
+		return;
+	work->dentry = dentry;
+	INIT_WORK(&work->work, __do_prov_save);
+	queue_work(prov_queue, &work->work);
+}
+#else
+static inline void queue_save_provenance(struct provenance *provenance,
+					struct dentry *dentry){}
+#endif
+
+/*
+ * initialise the security for the init task
+ */
+static void cred_init_provenance(void)
+{
+	struct cred *cred = (struct cred *)current->real_cred;
+	struct provenance *prov = alloc_provenance(ACT_TASK, GFP_KERNEL);
+
+	if (!prov)
+		panic("Provenance:  Failed to initialize initial task.\n");
+	prov_elt(prov)->task_info.uid = __kuid_val(cred->euid);
+	prov_elt(prov)->task_info.gid = __kgid_val(cred->egid);
+	cred->provenance = prov;
+}
+
+/*
+ * @cred points to the credentials.
+ * @gfp indicates the atomicity of any memory allocations.
+ * Only allocate sufficient memory and attach to @cred such that
+ * cred_transfer() will not get ENOMEM.
+ */
+static int provenance_cred_alloc_blank(struct cred *cred, gfp_t gfp)
+{
+	struct provenance *prov  = alloc_provenance(ACT_TASK, gfp);
+
+	if (!prov)
+		return -ENOMEM;
+
+	prov_elt(prov)->task_info.uid = __kuid_val(cred->euid);
+	prov_elt(prov)->task_info.gid = __kgid_val(cred->egid);
+
+	cred->provenance = prov;
+	return 0;
+}
+
+/*
+ * @cred points to the credentials.
+ * Deallocate and clear the cred->security field in a set of credentials.
+ */
+static void provenance_cred_free(struct cred *cred)
+{
+	if (cred->provenance) {
+		terminate_task(cred->provenance);
+		free_provenance(cred->provenance);
+	}
+	cred->provenance = NULL;
+}
+
+/*
+ * @new points to the new credentials.
+ * @old points to the original credentials.
+ * @gfp indicates the atomicity of any memory allocations.
+ * Prepare a new set of credentials by copying the data from the old set.
+ */
+static int provenance_cred_prepare(struct cred *new,
+				   const struct cred *old,
+				   gfp_t gfp)
+{
+	struct provenance *old_prov = old->provenance;
+	struct provenance *prov = alloc_provenance(ACT_TASK, gfp);
+	unsigned long irqflags;
+	int rc;
+
+	if (!prov)
+		return -ENOMEM;
+	//task_config_from_file(current);
+	prov_elt(prov)->task_info.uid = __kuid_val(new->euid);
+	prov_elt(prov)->task_info.gid = __kgid_val(new->egid);
+	spin_lock_irqsave_nested(prov_lock(old_prov), irqflags, PROVENANCE_LOCK_TASK);
+	prov->has_mmap = old_prov->has_mmap;
+	rc = flow_between_activities(RL_CLONE, old_prov, prov, NULL);
+	spin_unlock_irqrestore(prov_lock(old_prov), irqflags);
+	new->provenance = prov;
+	return rc;
+}
+
+/*
+ * @new points to the new credentials.
+ * @old points to the original credentials.
+ * Transfer data from original creds to new creds
+ */
+static void provenance_cred_transfer(struct cred *new, const struct cred *old)
+{
+	const struct provenance *old_prov = old->provenance;
+	struct provenance *prov = new->provenance;
+
+	*prov =  *old_prov;
+}
+
+/*
+ * Update the module's state after setting one or more of the user
+ * identity attributes of the current process.  The @flags parameter
+ * indicates which of the set*uid system calls invoked this hook.if
+ * @new is the set of credentials that will be installed.  Modifications
+ * should be made to this rather than to @current->cred.
+ * @old is the set of credentials that are being replaces
+ * @flags contains one of the LSM_SETID_* values.
+ * Return 0 on success.
+ */
+static int provenance_task_fix_setuid(struct cred *new,
+				      const struct cred *old,
+				      int flags)
+{
+	struct provenance *old_prov = old->provenance;
+	struct provenance *prov = new->provenance;
+	unsigned long irqflags;
+	int rc;
+
+	spin_lock_irqsave_nested(prov_lock(old_prov), irqflags, PROVENANCE_LOCK_TASK);
+	rc = flow_between_activities(RL_CHANGE, old_prov, prov, NULL);
+	spin_unlock_irqrestore(prov_lock(old_prov), irqflags);
+	return rc;
+}
+
+/*
+ * Allocate and attach a security structure to @inode->i_security.  The
+ * i_security field is initialized to NULL when the inode structure is
+ * allocated.
+ * @inode contains the inode structure.
+ * Return 0 if operation was successful.
+ */
+static int provenance_inode_alloc_security(struct inode *inode)
+{
+	struct provenance *iprov = alloc_provenance(ENT_INODE_UNKNOWN, GFP_KERNEL);
+	struct provenance *sprov;
+
+	if (unlikely(!iprov))
+		return -ENOMEM;
+	prov_elt(iprov)->inode_info.ino = inode->i_ino;
+	prov_elt(iprov)->inode_info.uid = __kuid_val(inode->i_uid);
+	prov_elt(iprov)->inode_info.gid = __kgid_val(inode->i_gid);
+	security_inode_getsecid(inode, &(prov_elt(iprov)->inode_info.secid));
+	update_inode_type(inode->i_mode, iprov);
+	sprov = inode->i_sb->s_provenance;
+	memcpy(prov_elt(iprov)->inode_info.sb_uuid, prov_elt(sprov)->sb_info.uuid, 16 * sizeof(uint8_t));
+	inode->i_provenance = iprov;
+	refresh_inode_provenance(inode);
+	return 0;
+}
+
+/*
+ * @inode contains the inode structure.
+ * Deallocate the inode security structure and set @inode->i_security to
+ * NULL.
+ */
+static void provenance_inode_free_security(struct inode *inode)
+{
+	if (inode->i_provenance) {
+		close_inode(inode->i_provenance);
+		free_provenance(inode->i_provenance);
+	}
+	inode->i_provenance = NULL;
+}
+
+/*
+ * Check permission to create a regular file.
+ * @dir contains inode structure of the parent of the new file.
+ * @dentry contains the dentry structure for the file to be created.
+ * @mode contains the file mode of the file to be created.
+ * Return 0 if permission is granted.
+ */
+static int provenance_inode_create(struct inode *dir,
+				   struct dentry *dentry,
+				   umode_t mode)
+{
+	struct provenance *cprov = current_provenance();
+	struct provenance *iprov = dir->i_provenance;
+	unsigned long irqflags;
+	int rc;
+
+	if (!iprov)
+		return -ENOMEM;
+	spin_lock_irqsave_nested(prov_lock(cprov), irqflags, PROVENANCE_LOCK_TASK);
+	spin_lock_nested(prov_lock(iprov), PROVENANCE_LOCK_DIR);
+	rc = flow_from_activity(RL_WRITE, cprov, iprov, NULL);
+	spin_unlock(prov_lock(iprov));
+	spin_unlock_irqrestore(prov_lock(cprov), irqflags);
+	return rc;
+}
+
+/*
+ * Check permission before accessing an inode.  This hook is called by the
+ * existing Linux permission function, so a security module can use it to
+ * provide additional checking for existing Linux permission checks.
+ * Notice that this hook is called when a file is opened (as well as many
+ * other operations), whereas the file_security_ops permission hook is
+ * called when the actual read/write operations are performed.
+ * @inode contains the inode structure to check.
+ * @mask contains the permission mask.
+ * Return 0 if permission is granted.
+ */
+static int provenance_inode_permission(struct inode *inode, int mask)
+{
+	struct provenance *cprov = current_provenance();
+	struct provenance *iprov = NULL;
+	uint32_t perms;
+	unsigned long irqflags;
+	int rc = 0;
+
+	if (!mask)
+		return 0;
+	if (unlikely(IS_PRIVATE(inode)))
+		return 0;
+	iprov = inode_provenance(inode, false);
+	if (!iprov)
+		return -ENOMEM;
+	refresh_current_provenance();
+	refresh_inode_provenance(inode);
+	perms = file_mask_to_perms(inode->i_mode, mask);
+	spin_lock_irqsave_nested(prov_lock(cprov), irqflags, PROVENANCE_LOCK_TASK);
+	spin_lock_nested(prov_lock(iprov), PROVENANCE_LOCK_INODE);
+	if (is_inode_dir(inode)) {
+		if ((perms & (DIR__WRITE)) != 0)
+			rc = flow_from_activity(RL_PERM_WRITE, cprov, iprov, NULL);
+		if (rc < 0)
+			goto out;
+		if ((perms & (DIR__READ)) != 0)
+			rc = flow_to_activity(RL_PERM_READ, iprov, cprov, NULL);
+		if (rc < 0)
+			goto out;
+		if ((perms & (DIR__SEARCH)) != 0)
+			rc = flow_to_activity(RL_PERM_EXEC, iprov, cprov, NULL);
+	} else if (is_inode_socket(inode)) {
+		if ((perms & (FILE__WRITE | FILE__APPEND)) != 0)
+			rc = flow_from_activity(RL_PERM_WRITE, cprov, iprov, NULL);
+		if (rc < 0)
+			goto out;
+		if ((perms & (FILE__READ)) != 0)
+			rc = flow_to_activity(RL_PERM_READ, iprov, cprov, NULL);
+	} else {
+		if ((perms & (FILE__WRITE | FILE__APPEND)) != 0)
+			rc = flow_from_activity(RL_PERM_WRITE, cprov, iprov, NULL);
+		if (rc < 0)
+			goto out;
+		if ((perms & (FILE__READ)) != 0)
+			rc = flow_to_activity(RL_PERM_READ, iprov, cprov, NULL);
+		if (rc < 0)
+			goto out;
+		if ((perms & (FILE__EXECUTE)) != 0)
+			rc = flow_to_activity(RL_PERM_EXEC, iprov, cprov, NULL);
+	}
+out:
+	spin_unlock(prov_lock(iprov));
+	spin_unlock_irqrestore(prov_lock(cprov), irqflags);
+	return rc;
+}
+
+/*
+ * Check permission before creating a new hard link to a file.
+ * @old_dentry contains the dentry structure for an existing
+ * link to the file.
+ * @dir contains the inode structure of the parent directory
+ * of the new link.
+ * @new_dentry contains the dentry structure for the new link.
+ * Return 0 if permission is granted.
+ */
+
+static int provenance_inode_link(struct dentry *old_dentry,
+				 struct inode *dir,
+				 struct dentry *new_dentry)
+{
+	struct provenance *cprov = current_provenance();
+	struct provenance *dprov = NULL;
+	struct provenance *iprov;
+	unsigned long irqflags;
+	int rc;
+
+	iprov = dentry_provenance(old_dentry);
+	if (!iprov)
+		return -ENOMEM;
+
+	dprov = dir->i_provenance;
+	if (!dprov)
+		return -ENOMEM;
+	spin_lock_irqsave_nested(prov_lock(cprov), irqflags, PROVENANCE_LOCK_TASK);
+	spin_lock_nested(prov_lock(dprov), PROVENANCE_LOCK_DIR);
+	spin_lock_nested(prov_lock(iprov), PROVENANCE_LOCK_INODE);
+	rc = flow_from_activity(RL_LINK, cprov, dprov, NULL);
+	if (rc < 0)
+		goto out;
+	rc = flow_from_activity(RL_LINK, cprov, iprov, NULL);
+	if (rc < 0)
+		goto out;
+	rc = flow_between_entities(RL_LINK, dprov, iprov, NULL);
+out:
+	spin_unlock(prov_lock(iprov));
+	spin_unlock(prov_lock(dprov));
+	spin_unlock_irqrestore(prov_lock(cprov), irqflags);
+	record_inode_name_from_dentry(new_dentry, iprov);
+	return rc;
+}
+
+// TODO probably deal with unlink (useful for stream processing)
+
+/*
+ * Check for permission to rename a file or directory.
+ * @old_dir contains the inode structure for parent of the old link.
+ * @old_dentry contains the dentry structure of the old link.
+ * @new_dir contains the inode structure for parent of the new link.
+ * @new_dentry contains the dentry structure of the new link.
+ * Return 0 if permission is granted.
+ */
+static int provenance_inode_rename(struct inode *old_dir,
+				   struct dentry *old_dentry,
+				   struct inode *new_dir,
+				   struct dentry *new_dentry)
+{
+	return provenance_inode_link(old_dentry, new_dir, new_dentry);
+}
+
+/*
+ * Check permission before setting file attributes.  Note that the kernel
+ * call to notify_change is performed from several locations, whenever
+ * file attributes change (such as when a file is truncated, chown/chmod
+ * operations, transferring disk quotas, etc).
+ * @dentry contains the dentry structure for the file.
+ * @attr is the iattr structure containing the new file attributes.
+ * Return 0 if permission is granted.
+ */
+static int provenance_inode_setattr(struct dentry *dentry, struct iattr *iattr)
+{
+	struct provenance *cprov = current_provenance();
+	struct provenance *iprov;
+	struct provenance *iattrprov;
+	unsigned long irqflags;
+	int rc;
+
+	iprov = dentry_provenance(dentry);
+	if (!iprov)
+		return -ENOMEM;
+	iattrprov = alloc_provenance(ENT_IATTR, GFP_KERNEL);
+	if (!iattrprov)
+		return -ENOMEM;
+
+	prov_elt(iattrprov)->iattr_info.valid = iattr->ia_valid;
+	prov_elt(iattrprov)->iattr_info.mode = iattr->ia_mode;
+	prov_elt(iattrprov)->iattr_info.uid = __kuid_val(iattr->ia_uid);
+	prov_elt(iattrprov)->iattr_info.gid = __kgid_val(iattr->ia_gid);
+	prov_elt(iattrprov)->iattr_info.size = iattr->ia_size;
+	prov_elt(iattrprov)->iattr_info.atime = iattr->ia_atime.tv_sec;
+	prov_elt(iattrprov)->iattr_info.mtime = iattr->ia_mtime.tv_sec;
+	prov_elt(iattrprov)->iattr_info.ctime = iattr->ia_ctime.tv_sec;
+
+	spin_lock_irqsave_nested(prov_lock(cprov), irqflags, PROVENANCE_LOCK_TASK);
+	spin_lock_nested(prov_lock(iprov), PROVENANCE_LOCK_INODE);
+	rc = flow_from_activity(RL_SETATTR, cprov, iattrprov, NULL);
+	if (rc < 0)
+		goto out;
+	rc = flow_between_entities(RL_SETATTR, iattrprov, iprov, NULL);
+	queue_save_provenance(iprov, dentry);
+out:
+	spin_unlock(prov_lock(iprov));
+	spin_unlock_irqrestore(prov_lock(cprov), irqflags);
+	free_provenance(iattrprov);
+	return rc;
+}
+
+/*
+ * Check permission before obtaining file attributes.
+ * @path contains the path structure for the file.
+ * Return 0 if permission is granted.
+ */
+static int provenance_inode_getattr(const struct path *path)
+{
+	struct provenance *cprov = current_provenance();
+	struct provenance *iprov = dentry_provenance(path->dentry);
+	unsigned long irqflags;
+	int rc;
+
+	if (!iprov)
+		return -ENOMEM;
+
+	spin_lock_irqsave_nested(prov_lock(cprov), irqflags, PROVENANCE_LOCK_TASK);
+	spin_lock_nested(prov_lock(iprov), PROVENANCE_LOCK_INODE);
+	rc = flow_to_activity(RL_GETATTR, iprov, cprov, NULL);
+	spin_unlock(prov_lock(iprov));
+	spin_unlock_irqrestore(prov_lock(cprov), irqflags);
+	return rc;
+}
+
+/*
+ * Check the permission to read the symbolic link.
+ * @dentry contains the dentry structure for the file link.
+ * Return 0 if permission is granted.
+ */
+static int provenance_inode_readlink(struct dentry *dentry)
+{
+	struct provenance *cprov = current_provenance();
+	struct provenance *iprov = dentry_provenance(dentry);
+	unsigned long irqflags;
+	int rc;
+
+	if (!iprov)
+		return -ENOMEM;
+
+	spin_lock_irqsave_nested(prov_lock(cprov), irqflags, PROVENANCE_LOCK_TASK);
+	spin_lock_nested(prov_lock(iprov), PROVENANCE_LOCK_INODE);
+	rc = flow_to_activity(RL_READLINK, iprov, cprov, NULL);
+	spin_unlock(prov_lock(iprov));
+	spin_unlock_irqrestore(prov_lock(cprov), irqflags);
+	return rc;
+}
+
+static int provenance_inode_setxattr(struct dentry *dentry,
+				     const char *name,
+				     const void *value,
+				     size_t size,
+				     int flags)
+{
+	struct provenance *prov;
+	union prov_elt *setting;
+
+	if (strcmp(name, XATTR_NAME_PROVENANCE) == 0) { // provenance xattr
+		if (size != sizeof(union prov_elt))
+			return -ENOMEM;
+		prov = dentry_provenance(dentry);
+		setting = (union prov_elt *)value;
+
+		if (provenance_is_tracked(setting))
+			set_tracked(prov_elt(prov));
+		else
+			clear_tracked(prov_elt(prov));
+
+		if (provenance_is_opaque(setting))
+			set_opaque(prov_elt(prov));
+		else
+			clear_opaque(prov_elt(prov));
+
+		if (provenance_does_propagate(setting))
+			set_propagate(prov_elt(prov));
+		else
+			clear_propagate(prov_elt(prov));
+
+		prov_bloom_merge(prov_taint(prov_elt(prov)), prov_taint(setting));
+	}
+	return 0;
+}
+
+/*
+ * Update inode security field after successful setxattr operation.
+ * @value identified by @name for @dentry.
+ */
+static void provenance_inode_post_setxattr(struct dentry *dentry,
+					   const char *name,
+					   const void *value,
+					   size_t size,
+					   int flags)
+{
+	struct provenance *cprov = current_provenance();
+	struct provenance *iprov = dentry_provenance(dentry);
+	unsigned long irqflags;
+
+	if (strcmp(name, XATTR_NAME_PROVENANCE) == 0)
+		return;
+
+	if (!iprov)
+		return;
+	spin_lock_irqsave_nested(prov_lock(cprov), irqflags, PROVENANCE_LOCK_TASK);
+	spin_lock_nested(prov_lock(iprov), PROVENANCE_LOCK_INODE);
+	if (provenance_is_opaque(prov_elt(cprov)) || provenance_is_opaque(prov_elt(iprov)))
+		goto out;
+	if (!provenance_is_tracked(prov_elt(cprov)) && !provenance_is_tracked(prov_elt(iprov)))
+		goto out;
+	record_write_xattr(RL_SETXATTR, iprov, cprov, name, value, size, flags);
+out:
+	queue_save_provenance(iprov, dentry);
+	spin_unlock(prov_lock(iprov));
+	spin_unlock_irqrestore(prov_lock(cprov), irqflags);
+}
+
+/*
+ * Check permission before obtaining the extended attributes
+ * identified by @name for @dentry.
+ * Return 0 if permission is granted.
+ */
+static int provenance_inode_getxattr(struct dentry *dentry, const char *name)
+{
+	struct provenance *cprov = current_provenance();
+	struct provenance *iprov = dentry_provenance(dentry);
+	int rc = 0;
+	unsigned long irqflags;
+
+	if (strcmp(name, XATTR_NAME_PROVENANCE) == 0)
+		return 0;
+
+	if (!iprov)
+		return -ENOMEM;
+	spin_lock_irqsave_nested(prov_lock(cprov), irqflags, PROVENANCE_LOCK_TASK);
+	spin_lock_nested(prov_lock(iprov), PROVENANCE_LOCK_INODE);
+	if (provenance_is_opaque(prov_elt(cprov)) || provenance_is_opaque(prov_elt(iprov)))
+		goto out;
+	if (!provenance_is_tracked(prov_elt(cprov)) && !provenance_is_tracked(prov_elt(iprov)))
+		goto out;
+	rc = record_read_xattr(RL_GETXATTR, cprov, iprov, name);
+out:
+	spin_unlock(prov_lock(iprov));
+	spin_unlock_irqrestore(prov_lock(cprov), irqflags);
+	return rc;
+}
+
+/*
+ * Check permission before obtaining the list of extended attribute
+ * names for @dentry.
+ * Return 0 if permission is granted.
+ */
+static int provenance_inode_listxattr(struct dentry *dentry)
+{
+	struct provenance *cprov = current_provenance();
+	struct provenance *iprov = dentry_provenance(dentry);
+	unsigned long irqflags;
+	int rc;
+
+	if (!iprov)
+		return -ENOMEM;
+	spin_lock_irqsave_nested(prov_lock(cprov), irqflags, PROVENANCE_LOCK_TASK);
+	spin_lock_nested(prov_lock(iprov), PROVENANCE_LOCK_INODE);
+	rc = flow_to_activity(RL_LSTXATTR, iprov, cprov, NULL);
+	spin_unlock(prov_lock(iprov));
+	spin_unlock_irqrestore(prov_lock(cprov), irqflags);
+	return rc;
+}
+
+/*
+ * Check permission before removing the extended attribute
+ * identified by @name for @dentry.
+ * Return 0 if permission is granted.
+ */
+static int provenance_inode_removexattr(struct dentry *dentry, const char *name)
+{
+	struct provenance *cprov = current_provenance();
+	struct provenance *iprov = dentry_provenance(dentry);
+	unsigned long irqflags;
+	int rc = 0;
+
+	if (strcmp(name, XATTR_NAME_PROVENANCE) == 0)
+		return -EPERM;
+
+	if (!iprov)
+		return -ENOMEM;
+
+	spin_lock_irqsave_nested(prov_lock(cprov), irqflags, PROVENANCE_LOCK_TASK);
+	spin_lock_nested(prov_lock(iprov), PROVENANCE_LOCK_INODE);
+	if (provenance_is_opaque(prov_elt(cprov)) || provenance_is_opaque(prov_elt(iprov)))
+		goto out;
+	if (!provenance_is_tracked(prov_elt(cprov)) && !provenance_is_tracked(prov_elt(iprov)))
+		goto out;
+	rc = record_write_xattr(RL_RMVXATTR, iprov, cprov, name, NULL, 0, 0);
+out:
+	queue_save_provenance(iprov, dentry);;
+	spin_unlock(prov_lock(iprov));
+	spin_unlock_irqrestore(prov_lock(cprov), irqflags);
+	return rc;
+}
+
+static int provenance_inode_getsecurity(struct inode *inode,
+					const char *name,
+					void **buffer,
+					bool alloc)
+{
+	struct provenance *iprov = inode_provenance(inode, true);
+
+	if (unlikely(!iprov))
+		return -ENOMEM;
+	if (strcmp(name, XATTR_PROVENANCE_SUFFIX))
+		return -EOPNOTSUPP;
+	if (!alloc)
+		goto out;
+	*buffer = kmalloc(sizeof(union prov_elt), GFP_KERNEL);
+	memcpy(*buffer, prov_elt(iprov), sizeof(union prov_elt));
+out:
+	return sizeof(union prov_elt);
+}
+
+static int provenance_inode_listsecurity(struct inode *inode,
+					 char *buffer,
+					 size_t buffer_size)
+{
+	const int len = sizeof(XATTR_NAME_PROVENANCE);
+
+	if (buffer && len <= buffer_size)
+		memcpy(buffer, XATTR_NAME_PROVENANCE, len);
+	return len;
+}
+
+/*
+ * Check file permissions before accessing an open file.  This hook is
+ * called by various operations that read or write files.  A security
+ * module can use this hook to perform additional checking on these
+ * operations, e.g.  to revalidate permissions on use to support privilege
+ * bracketing or policy changes.  Notice that this hook is used when the
+ * actual read/write operations are performed, whereas the
+ * inode_security_ops hook is called when a file is opened (as well as
+ * many other operations).
+ * Caveat:  Although this hook can be used to revalidate permissions for
+ * various system call operations that read or write files, it does not
+ * address the revalidation of permissions for memory-mapped files.
+ * Security modules must handle this separately if they need such
+ * revalidation.
+ * @file contains the file structure being accessed.
+ * @mask contains the requested permissions.
+ * Return 0 if permission is granted.
+ */
+static int provenance_file_permission(struct file *file, int mask)
+{
+	struct provenance *cprov = current_provenance();
+	struct provenance *iprov = file_provenance(file);
+	struct inode *inode = file_inode(file);
+	uint32_t perms;
+	unsigned long irqflags;
+	int rc = 0;
+
+	if (!iprov)
+		return -ENOMEM;
+	refresh_current_provenance();
+	refresh_inode_provenance(inode);
+	perms = file_mask_to_perms(inode->i_mode, mask);
+	spin_lock_irqsave_nested(prov_lock(cprov), irqflags, PROVENANCE_LOCK_TASK);
+	spin_lock_nested(prov_lock(iprov), PROVENANCE_LOCK_INODE);
+	if (is_inode_dir(inode)) {
+		if ((perms & (DIR__WRITE)) != 0)
+			rc = flow_from_activity(RL_WRITE, cprov, iprov, file);
+		if (rc < 0)
+			goto out;
+		if ((perms & (DIR__READ)) != 0)
+			rc = flow_to_activity(RL_READ, iprov, cprov, file);
+		if (rc < 0)
+			goto out;
+		if ((perms & (DIR__SEARCH)) != 0)
+			rc = flow_to_activity(RL_SEARCH, iprov, cprov, file);
+	} else if (is_inode_socket(inode)) {
+		if ((perms & (FILE__WRITE | FILE__APPEND)) != 0)
+			rc = flow_from_activity(RL_SND, cprov, iprov, file);
+		if (rc < 0)
+			goto out;
+		if ((perms & (FILE__READ)) != 0)
+			rc = flow_to_activity(RL_RCV, iprov, cprov, file);
+	} else{
+		if ((perms & (FILE__WRITE | FILE__APPEND)) != 0)
+			rc = flow_from_activity(RL_WRITE, cprov, iprov, file);
+		if (rc < 0)
+			goto out;
+		if ((perms & (FILE__READ)) != 0)
+			rc = flow_to_activity(RL_READ, iprov, cprov, file);
+		if (rc < 0)
+			goto out;
+		if ((perms & (FILE__EXECUTE)) != 0) {
+			if (provenance_is_opaque(prov_elt(iprov)))
+				set_opaque(prov_elt(cprov));
+			else
+				rc = flow_to_activity(RL_EXEC, iprov, cprov, file);
+		}
+	}
+	queue_save_provenance(iprov, file_dentry(file));
+out:
+	spin_unlock(prov_lock(iprov));
+	spin_unlock_irqrestore(prov_lock(cprov), irqflags);
+	return rc;
+}
+
+/*
+ * Save open-time permission checking state for later use upon
+ * file_permission, and recheck access if anything has changed
+ * since inode_permission.
+ */
+static int provenance_file_open(struct file *file, const struct cred *cred)
+{
+	struct provenance *cprov = current_provenance();
+	struct provenance *iprov = file_provenance(file);
+	unsigned long irqflags;
+	int rc;
+
+	if (!iprov)
+		return -ENOMEM;
+	spin_lock_irqsave_nested(prov_lock(cprov), irqflags, PROVENANCE_LOCK_TASK);
+	spin_lock_nested(prov_lock(iprov), PROVENANCE_LOCK_INODE);
+	rc = flow_to_activity(RL_OPEN, iprov, cprov, file);
+	spin_unlock(prov_lock(iprov));
+	spin_unlock_irqrestore(prov_lock(cprov), irqflags);
+	return rc;
+}
+
+/*
+ * Check permissions for a mmap operation.  The @file may be NULL, e.g.
+ * if mapping anonymous memory.
+ * @file contains the file structure for file to map (may be NULL).
+ * @reqprot contains the protection requested by the application.
+ * @prot contains the protection that will be applied by the kernel.
+ * @flags contains the operational flags.
+ * Return 0 if permission is granted.
+ */
+static int provenance_mmap_file(struct file *file,
+				unsigned long reqprot,
+				unsigned long prot,
+				unsigned long flags)
+{
+	struct provenance *cprov = current_provenance();
+	struct provenance *iprov = NULL;
+	struct provenance *bprov = NULL;
+	unsigned long irqflags;
+	int rc = 0;
+
+	if (unlikely(!file))
+		return 0;
+	iprov = file_provenance(file);
+	if (!iprov)
+		return -ENOMEM;
+	spin_lock_irqsave_nested(prov_lock(cprov), irqflags, PROVENANCE_LOCK_TASK);
+	spin_lock_nested(prov_lock(iprov), PROVENANCE_LOCK_INODE);
+	rc = flow_to_activity(RL_READ, iprov, cprov, file);
+	if (rc < 0)
+		goto out;
+	if ((flags & MAP_TYPE) == MAP_SHARED) {
+		cprov->has_mmap = 1;
+		if ((prot & (PROT_WRITE)) != 0)
+			rc = flow_from_activity(RL_MMAP_WRITE, cprov, iprov, file);
+		if (rc < 0)
+			goto out;
+		if ((prot & (PROT_READ)) != 0)
+			rc = flow_to_activity(RL_MMAP_READ, iprov, cprov, file);
+		if (rc < 0)
+			goto out;
+		if ((prot & (PROT_EXEC)) != 0)
+			rc = flow_to_activity(RL_MMAP_EXEC, iprov, cprov, file);
+	} else{
+		bprov = branch_mmap(iprov, cprov);
+		if (!bprov)
+			goto out;
+		rc = flow_between_entities(RL_MMAP, iprov, bprov, file);
+		if (rc < 0)
+			goto out;
+		if ((prot & (PROT_WRITE)) != 0)
+			rc = flow_from_activity(RL_MMAP_WRITE, cprov, bprov, file);
+		if (rc < 0)
+			goto out;
+		if ((prot & (PROT_READ)) != 0)
+			rc = flow_to_activity(RL_MMAP_READ, bprov, cprov, file);
+		if (rc < 0)
+			goto out;
+		if ((prot & (PROT_EXEC)) != 0)
+			rc = flow_to_activity(RL_MMAP_EXEC, bprov, cprov, file);
+	}
+out:
+		spin_unlock(prov_lock(iprov));
+		spin_unlock_irqrestore(prov_lock(cprov), irqflags);
+		if (bprov) {
+			close_inode(bprov);
+			free_provenance(bprov);
+		}
+	return rc;
+}
+
+/*
+ * @file contains the file structure.
+ * @cmd contains the operation to perform.
+ * @arg contains the operational arguments.
+ * Check permission for an ioctl operation on @file.  Note that @arg
+ * sometimes represents a user space pointer; in other cases, it may be a
+ * simple integer value.  When @arg represents a user space pointer, it
+ * should never be used by the security module.
+ * Return 0 if permission is granted.
+ */
+static int provenance_file_ioctl(struct file *file,
+				 unsigned int cmd,
+				 unsigned long arg)
+{
+	struct provenance *cprov = current_provenance();
+	struct provenance *iprov = file_provenance(file);
+	unsigned long irqflags;
+	int rc;
+
+	if (!iprov)
+		return -ENOMEM;
+	spin_lock_irqsave_nested(prov_lock(cprov), irqflags, PROVENANCE_LOCK_TASK);
+	spin_lock_nested(prov_lock(iprov), PROVENANCE_LOCK_INODE);
+	rc = flow_from_activity(RL_WRITE, cprov, iprov, NULL);
+	if (rc < 0)
+		goto out;
+	rc = flow_to_activity(RL_READ, iprov, cprov, NULL);
+	queue_save_provenance(iprov, file_dentry(file));
+out:
+	spin_unlock(prov_lock(iprov));
+	spin_unlock_irqrestore(prov_lock(cprov), irqflags);
+	return rc;
+}
+
+/* msg */
+
+/*
+ * Allocate and attach a security structure to the msg->security field.
+ * The security field is initialized to NULL when the structure is first
+ * created.
+ * @msg contains the message structure to be modified.
+ * Return 0 if operation was successful and permission is granted.
+ */
+static int provenance_msg_msg_alloc_security(struct msg_msg *msg)
+{
+	struct provenance *cprov = current_provenance();
+	struct provenance *mprov;
+	unsigned long irqflags;
+	int rc;
+
+	/* alloc new prov struct with generated id */
+	mprov = alloc_provenance(ENT_MSG, GFP_KERNEL);
+
+	if (!mprov)
+		return -ENOMEM;
+	prov_elt(mprov)->msg_msg_info.type = msg->m_type;
+	msg->provenance = mprov;
+	spin_lock_irqsave_nested(prov_lock(cprov), irqflags, PROVENANCE_LOCK_TASK);
+	rc = flow_from_activity(RL_CREATE, cprov, mprov, NULL);
+	spin_unlock_irqrestore(prov_lock(cprov), irqflags);
+	return rc;
+}
+
+/*
+ * Deallocate the security structure for this message.
+ * @msg contains the message structure to be modified.
+ */
+static void provenance_msg_msg_free_security(struct msg_msg *msg)
+{
+	if (msg->provenance)
+		free_provenance(msg->provenance);
+	msg->provenance = NULL;
+}
+
+/*
+ * Check permission before a message, @msg, is enqueued on the message
+ * queue, @msq.
+ * @msq contains the message queue to send message to.
+ * @msg contains the message to be enqueued.
+ * @msqflg contains operational flags.
+ * Return 0 if permission is granted.
+ */
+static int provenance_msg_queue_msgsnd(struct msg_queue *msq,
+				       struct msg_msg *msg,
+				       int msqflg)
+{
+	struct provenance *cprov = current_provenance();
+	struct provenance *mprov = msg->provenance;
+	unsigned long irqflags;
+	int rc;
+
+	spin_lock_irqsave_nested(prov_lock(cprov), irqflags, PROVENANCE_LOCK_TASK);
+	spin_lock_nested(prov_lock(mprov), PROVENANCE_LOCK_MSG);
+	rc = flow_from_activity(RL_CREATE, cprov, mprov, NULL);
+	spin_unlock(prov_lock(mprov));
+	spin_unlock_irqrestore(prov_lock(cprov), irqflags);
+	return rc;
+}
+
+/*
+ * Check permission before a message, @msg, is removed from the message
+ * queue, @msq.  The @target task structure contains a pointer to the
+ * process that will be receiving the message (not equal to the current
+ * process when inline receives are being performed).
+ * @msq contains the message queue to retrieve message from.
+ * @msg contains the message destination.
+ * @target contains the task structure for recipient process.
+ * @type contains the type of message requested.
+ * @mode contains the operational flags.
+ * Return 0 if permission is granted.
+ */
+static int provenance_msg_queue_msgrcv(struct msg_queue *msq,
+				       struct msg_msg *msg,
+				       struct task_struct *target,
+				       long type,
+				       int mode)
+{
+	struct provenance *cprov = target->cred->provenance;
+	struct provenance *mprov = msg->provenance;
+	unsigned long irqflags;
+	int rc;
+
+	spin_lock_irqsave_nested(prov_lock(cprov), irqflags, PROVENANCE_LOCK_TASK);
+	spin_lock_nested(prov_lock(mprov), PROVENANCE_LOCK_MSG);
+	rc = flow_to_activity(RL_READ, mprov, cprov, NULL);
+	spin_unlock(prov_lock(mprov));
+	spin_unlock_irqrestore(prov_lock(cprov), irqflags);
+	return rc;
+}
+
+/*
+ * Allocate and attach a security structure to the shp->shm_perm.security
+ * field.  The security field is initialized to NULL when the structure is
+ * first created.
+ * @shp contains the shared memory structure to be modified.
+ * Return 0 if operation was successful and permission is granted.
+ */
+static int provenance_shm_alloc_security(struct shmid_kernel *shp)
+{
+	struct provenance *cprov = current_provenance();
+	struct provenance *sprov = alloc_provenance(ENT_SHM, GFP_KERNEL);
+	unsigned long irqflags;
+	int rc;
+
+	if (!sprov)
+		return -ENOMEM;
+	prov_elt(sprov)->shm_info.mode = shp->shm_perm.mode;
+	shp->shm_perm.provenance = sprov;
+	spin_lock_irqsave_nested(prov_lock(cprov), irqflags, PROVENANCE_LOCK_TASK);
+	rc = flow_to_activity(RL_WRITE, sprov, cprov, NULL);
+	if (rc < 0)
+		goto out;
+	rc = flow_from_activity(RL_READ, cprov, sprov, NULL);
+out:
+	spin_unlock_irqrestore(prov_lock(cprov), irqflags);
+	return 0;
+}
+
+/*
+ * Deallocate the security struct for this memory segment.
+ * @shp contains the shared memory structure to be modified.
+ */
+static void provenance_shm_free_security(struct shmid_kernel *shp)
+{
+	if (shp->shm_perm.provenance)
+		free_provenance(shp->shm_perm.provenance);
+	shp->shm_perm.provenance = NULL;
+}
+
+/*
+ * Check permissions prior to allowing the shmat system call to attach the
+ * shared memory segment @shp to the data segment of the calling process.
+ * The attaching address is specified by @shmaddr.
+ * @shp contains the shared memory structure to be modified.
+ * @shmaddr contains the address to attach memory region to.
+ * @shmflg contains the operational flags.
+ * Return 0 if permission is granted.
+ */
+static int provenance_shm_shmat(struct shmid_kernel *shp, char __user *shmaddr, int shmflg)
+{
+	struct provenance *cprov = current_provenance();
+	struct provenance *sprov = shp->shm_perm.provenance;
+	unsigned long irqflags;
+	int rc = 0;
+
+	if (!sprov)
+		return -ENOMEM;
+	spin_lock_irqsave_nested(prov_lock(cprov), irqflags, PROVENANCE_LOCK_TASK);
+	spin_lock_nested(prov_lock(sprov), PROVENANCE_LOCK_SHM);
+	if (shmflg & SHM_RDONLY)
+		rc = flow_to_activity(RL_READ, sprov, cprov, NULL);
+	else {
+		rc = flow_to_activity(RL_READ, sprov, cprov, NULL);
+		if (rc < 0)
+			goto out;
+		rc = flow_from_activity(RL_WRITE, cprov, sprov, NULL);
+	}
+out:
+	spin_unlock(prov_lock(sprov));
+	spin_unlock_irqrestore(prov_lock(cprov), irqflags);
+	return rc;
+}
+
+/*
+ * Allocate and attach a security structure to the sk->sk_security field,
+ * which is used to copy security attributes between local stream sockets.
+ */
+static int provenance_sk_alloc_security(struct sock *sk,
+					int family,
+					gfp_t priority)
+{
+	struct provenance *skprov = current_provenance();
+
+	if (!skprov)
+		return -ENOMEM;
+	sk->sk_provenance = skprov;
+	return 0;
+}
+
+/*
+ * This hook allows a module to update or allocate a per-socket security
+ * structure. Note that the security field was not added directly to the
+ * socket structure, but rather, the socket security information is stored
+ * in the associated inode.  Typically, the inode alloc_security hook will
+ * allocate and and attach security information to
+ * sock->inode->i_security.  This hook may be used to update the
+ * sock->inode->i_security field with additional information that wasn't
+ * available when the inode was allocated.
+ * @sock contains the newly created socket structure.
+ * @family contains the requested protocol family.
+ * @type contains the requested communications type.
+ * @protocol contains the requested protocol.
+ * @kern set to 1 if a kernel socket.
+ */
+static int provenance_socket_post_create(struct socket *sock,
+					 int family,
+					 int type,
+					 int protocol,
+					 int kern)
+{
+	struct provenance *cprov  = current_provenance();
+	struct provenance *iprov = socket_inode_provenance(sock);
+	unsigned long irqflags;
+	int rc;
+
+	if (kern)
+		return 0;
+	spin_lock_irqsave_nested(prov_lock(cprov), irqflags, PROVENANCE_LOCK_TASK);
+	spin_lock_nested(prov_lock(iprov), PROVENANCE_LOCK_INODE);
+	rc = flow_from_activity(RL_CREATE, cprov, iprov, NULL);
+	spin_unlock(prov_lock(iprov));
+	spin_unlock_irqrestore(prov_lock(cprov), irqflags);
+	return rc;
+}
+
+/*
+ * Check permission before socket protocol layer bind operation is
+ * performed and the socket @sock is bound to the address specified in the
+ * @address parameter.
+ * @sock contains the socket structure.
+ * @address contains the address to bind to.
+ * @addrlen contains the length of address.
+ * Return 0 if permission is granted.
+ */
+static int provenance_socket_bind(struct socket *sock,
+				  struct sockaddr *address,
+				  int addrlen)
+{
+	struct provenance *cprov  = current_provenance();
+	struct provenance *iprov = socket_inode_provenance(sock);
+	struct sockaddr_in *ipv4_addr;
+	uint8_t op;
+	int rc;
+
+	if (!iprov)
+		return -ENOMEM;
+
+	if (provenance_is_opaque(prov_elt(cprov)))
+		return 0;
+
+	/* should we start tracking this socket */
+	if (address->sa_family == AF_INET) {
+		ipv4_addr = (struct sockaddr_in *)address;
+		op = prov_ipv4_ingressOP(ipv4_addr->sin_addr.s_addr, ipv4_addr->sin_port);
+		if ((op & PROV_NET_TRACKED) != 0) {
+			set_tracked(prov_elt(iprov));
+			set_tracked(prov_elt(cprov));
+		}
+		if ((op & PROV_NET_PROPAGATE) != 0) {
+			set_propagate(prov_elt(iprov));
+			set_propagate(prov_elt(cprov));
+		}
+		if ((op & PROV_NET_RECORD) != 0)
+			set_record_packet(prov_elt(iprov));
+	}
+	rc = provenance_record_address(address, addrlen, iprov);
+	if (rc < 0)
+		return rc;
+	rc = flow_from_activity(RL_BIND, cprov, iprov, NULL);
+	return rc;
+}
+
+/*
+ * Check permission before socket protocol layer connect operation
+ * attempts to connect socket @sock to a remote address, @address.
+ * @sock contains the socket structure.
+ * @address contains the address of remote endpoint.
+ * @addrlen contains the length of address.
+ * Return 0 if permission is granted.
+ */
+static int provenance_socket_connect(struct socket *sock,
+				     struct sockaddr *address,
+				     int addrlen)
+{
+	struct provenance *cprov  = current_provenance();
+	struct provenance *iprov = socket_inode_provenance(sock);
+	struct sockaddr_in *ipv4_addr;
+	unsigned long irqflags;
+	uint8_t op;
+	int rc = 0;
+
+	if (!iprov)
+		return -ENOMEM;
+
+	spin_lock_irqsave_nested(prov_lock(cprov), irqflags, PROVENANCE_LOCK_TASK);
+	spin_lock_nested(prov_lock(iprov), PROVENANCE_LOCK_INODE);
+	if (provenance_is_opaque(prov_elt(cprov)))
+		goto out;
+
+	/* should we start tracking this socket */
+	if (address->sa_family == AF_INET) {
+		ipv4_addr = (struct sockaddr_in *)address;
+		op = prov_ipv4_egressOP(ipv4_addr->sin_addr.s_addr, ipv4_addr->sin_port);
+		if ((op & PROV_NET_TRACKED) != 0) {
+			set_tracked(prov_elt(iprov));
+			set_tracked(prov_elt(cprov));
+		}
+		if ((op & PROV_NET_PROPAGATE) != 0) {
+			set_propagate(prov_elt(iprov));
+			set_propagate(prov_elt(cprov));
+		}
+		if ((op & PROV_NET_RECORD) != 0)
+			set_record_packet(prov_elt(iprov));
+	}
+	rc = provenance_record_address(address, addrlen, iprov);
+	if (rc < 0)
+		return rc;
+	rc = flow_from_activity(RL_CONNECT, cprov, iprov, NULL);
+out:
+	spin_unlock(prov_lock(iprov));
+	spin_unlock_irqrestore(prov_lock(cprov), irqflags);
+	return rc;
+}
+
+/*
+ * Check permission before socket protocol layer listen operation.
+ * @sock contains the socket structure.
+ * @backlog contains the maximum length for the pending connection queue.
+ * Return 0 if permission is granted.
+ */
+static int provenance_socket_listen(struct socket *sock, int backlog)
+{
+	struct provenance *cprov  = current_provenance();
+	struct provenance *iprov = socket_inode_provenance(sock);
+	unsigned long irqflags;
+	int rc;
+
+	if (!iprov)
+		return -ENOMEM;
+	spin_lock_irqsave_nested(prov_lock(cprov), irqflags, PROVENANCE_LOCK_TASK);
+	spin_lock_nested(prov_lock(iprov), PROVENANCE_LOCK_INODE);
+	rc = flow_from_activity(RL_LISTEN, cprov, iprov, NULL);
+	spin_unlock(prov_lock(iprov));
+	spin_unlock_irqrestore(prov_lock(cprov), irqflags);
+	return rc;
+}
+
+/*
+ * Check permission before accepting a new connection.  Note that the new
+ * socket, @newsock, has been created and some information copied to it,
+ * but the accept operation has not actually been performed.
+ * @sock contains the listening socket structure.
+ * @newsock contains the newly created server socket for connection.
+ * Return 0 if permission is granted.
+ */
+static int provenance_socket_accept(struct socket *sock, struct socket *newsock)
+{
+	struct provenance *cprov  = current_provenance();
+	struct provenance *iprov = socket_inode_provenance(sock);
+	struct provenance *niprov = socket_inode_provenance(newsock);
+	unsigned long irqflags;
+	int rc;
+
+	spin_lock_irqsave_nested(prov_lock(cprov), irqflags, PROVENANCE_LOCK_TASK);
+	spin_lock_nested(prov_lock(iprov), PROVENANCE_LOCK_INODE);
+	rc = flow_between_entities(RL_CREATE, iprov, niprov, NULL);
+	if (rc < 0)
+		goto out;
+	rc = flow_to_activity(RL_ACCEPT, niprov, cprov, NULL);
+out:
+	spin_unlock(prov_lock(iprov));
+	spin_unlock_irqrestore(prov_lock(cprov), irqflags);
+	return rc;
+}
+
+/*
+ * Check permission before transmitting a message to another socket.
+ * @sock contains the socket structure.
+ * @msg contains the message to be transmitted.
+ * @size contains the size of message.
+ * Return 0 if permission is granted.
+ */
+static int provenance_socket_sendmsg(struct socket *sock,
+				     struct msghdr *msg,
+				     int size)
+{
+	struct provenance *cprov = current_provenance();
+	struct provenance *iprov = socket_inode_provenance(sock);
+	unsigned long irqflags;
+	int rc;
+
+	if (!iprov)
+		return -ENOMEM;
+	spin_lock_irqsave_nested(prov_lock(cprov), irqflags, PROVENANCE_LOCK_TASK);
+	spin_lock_nested(prov_lock(iprov), PROVENANCE_LOCK_INODE);
+	rc = flow_from_activity(RL_SND, cprov, iprov, NULL);
+	spin_unlock(prov_lock(iprov));
+	spin_unlock_irqrestore(prov_lock(cprov), irqflags);
+	return rc;
+}
+
+/*
+ * Check permission before receiving a message from a socket.
+ * @sock contains the socket structure.
+ * @msg contains the message structure.
+ * @size contains the size of message structure.
+ * @flags contains the operational flags.
+ * Return 0 if permission is granted.
+ */
+static int provenance_socket_recvmsg(struct socket *sock,
+				     struct msghdr *msg,
+				     int size,
+				     int flags)
+{
+	struct provenance *cprov = current_provenance();
+	struct provenance *iprov = socket_inode_provenance(sock);
+	unsigned long irqflags;
+	int rc;
+
+	if (!iprov)
+		return -ENOMEM;
+	spin_lock_irqsave_nested(prov_lock(cprov), irqflags, PROVENANCE_LOCK_TASK);
+	spin_lock_nested(prov_lock(iprov), PROVENANCE_LOCK_INODE);
+	rc = flow_to_activity(RL_RCV, iprov, cprov, NULL);
+	spin_unlock(prov_lock(iprov));
+	spin_unlock_irqrestore(prov_lock(cprov), irqflags);
+	return rc;
+}
+
+/*
+ * Check permissions on incoming network packets.  This hook is distinct
+ * from Netfilter's IP input hooks since it is the first time that the
+ * incoming sk_buff @skb has been associated with a particular socket, @sk.
+ * Must not sleep inside this hook because some callers hold spinlocks.
+ * @sk contains the sock (not socket) associated with the incoming sk_buff.
+ * @skb contains the incoming network data.
+ */
+static int provenance_socket_sock_rcv_skb(struct sock *sk, struct sk_buff *skb)
+{
+	struct provenance *cprov = sk_provenance(sk);
+	struct provenance *iprov;
+	union prov_elt pckprov;
+	uint16_t family = sk->sk_family;
+	unsigned long irqflags;
+	int rc = 0;
+
+	if (!cprov)
+		return 0;
+	if (family != PF_INET)
+		return 0;
+	iprov = sk_inode_provenance(sk);
+	if (!iprov)
+		return 0;
+	if (provenance_is_tracked(prov_elt(iprov)) ||
+	    provenance_is_tracked(prov_elt(cprov))) {
+		provenance_parse_skb_ipv4(skb, &pckprov);
+		spin_lock_irqsave_nested(prov_lock(cprov), irqflags, PROVENANCE_LOCK_TASK);
+		spin_lock_nested(prov_lock(iprov), PROVENANCE_LOCK_INODE);
+		rc = record_pck_to_inode(&pckprov, iprov);
+		if (rc < 0)
+			goto out;
+		if (provenance_is_tracked(prov_elt(cprov)))
+			rc = flow_to_activity(RL_RCV, iprov, cprov, NULL);
+		if (rc < 0)
+			goto out;
+		if (provenance_records_packet(prov_elt(iprov)))
+			rc = record_packet_content(&pckprov, skb);
+out:
+		spin_unlock(prov_lock(iprov));
+		spin_unlock_irqrestore(prov_lock(cprov), irqflags);
+	}
+	return rc;
+}
+
+/*
+ * Check permissions before establishing a Unix domain stream connection
+ * between @sock and @other.
+ * @sock contains the sock structure.
+ * @other contains the peer sock structure.
+ * @newsk contains the new sock structure.
+ * Return 0 if permission is granted.
+ */
+static int provenance_unix_stream_connect(struct sock *sock,
+					  struct sock *other,
+					  struct sock *newsk)
+{
+	/*struct provenance *cprov  = current_provenance();
+	   struct provenance *iprov = sk_inode_provenance(sock);
+	   struct provenance *oprov = sk_inode_provenance(other);
+	   struct provenance *nprov = sk_inode_provenance(newsk);
+	   unsigned long irqflags;
+	   spin_lock_irqsave_nested(prov_lock(cprov), irqflags, PROVENANCE_LOCK_TASK);
+	   spin_lock_nested(prov_lock(iprov), PROVENANCE_LOCK_INODE);
+	   flow_from_activity(RL_CONNECT, cprov, nprov, NULL);
+	   flow_from_activity(RL_CONNECT, iprov, nprov, NULL);
+	   flow_from_activity(RL_CONNECT, oprov, nprov, NULL);
+	   spin_unlock(prov_lock(iprov));
+	   spin_unlock_irqrestore(prov_lock(cprov), irqflags);*/
+	return 0;
+}
+
+/*
+ * Check permissions before connecting or sending datagrams from @sock to
+ * @other.
+ * @sock contains the socket structure.
+ * @other contains the peer socket structure.
+ * Return 0 if permission is granted.
+ */
+static int provenance_unix_may_send(struct socket *sock,
+				    struct socket *other)
+{
+	struct provenance *sprov = socket_inode_provenance(sock);
+	struct provenance *oprov = socket_inode_provenance(other);
+	unsigned long irqflags;
+	int rc;
+
+	spin_lock_irqsave_nested(prov_lock(sprov), irqflags, PROVENANCE_LOCK_SOCKET);
+	spin_lock_nested(prov_lock(oprov), PROVENANCE_LOCK_SOCK);
+	rc = flow_between_entities(RL_UNKNOWN, sprov, oprov, NULL);
+	spin_unlock(prov_lock(oprov));
+	spin_unlock_irqrestore(prov_lock(sprov), irqflags);
+	return rc;
+}
+
+/* outdated description */
+/*
+ * Save security information in the bprm->security field, typically based
+ * on information about the bprm->file, for later use by the apply_creds
+ * hook.  This hook may also optionally check permissions (e.g. for
+ * transitions between security domains).
+ * This hook may be called multiple times during a single execve, e.g. for
+ * interpreters.  The hook can tell whether it has already been called by
+ * checking to see if @bprm->security is non-NULL.if so, then the hook
+ * may decide either to retain the security information saved earlier or
+ * to replace it.
+ * @bprm contains the linux_binprm structure.
+ * Return 0 if the hook is successful and permission is granted.
+ */
+static int provenance_bprm_set_creds(struct linux_binprm *bprm)
+{
+	struct provenance *nprov = bprm->cred->provenance;
+	struct provenance *iprov = file_provenance(bprm->file);
+	unsigned long irqflags;
+	int rc;
+
+	if (!nprov)
+		return -ENOMEM;
+
+	if (provenance_is_opaque(prov_elt(iprov))) {
+		set_opaque(prov_elt(nprov));
+		return 0;
+	}
+	spin_lock_irqsave_nested(prov_lock(iprov), irqflags, PROVENANCE_LOCK_INODE);
+	rc = flow_to_activity(RL_EXEC, iprov, nprov, NULL);
+	spin_unlock_irqrestore(prov_lock(iprov), irqflags);
+	return rc;
+}
+
+/*
+ * Prepare to install the new security attributes of a process being
+ * transformed by an execve operation, based on the old credentials
+ * pointed to by @current->cred and the information set in @bprm->cred by
+ * the bprm_set_creds hook.  @bprm points to the linux_binprm structure.
+ * This hook is a good place to perform state changes on the process such
+ * as closing open file descriptors to which access will no longer be
+ * granted when the attributes are changed.  This is called immediately
+ * before commit_creds().
+ */
+static void provenance_bprm_committing_creds(struct linux_binprm *bprm)
+{
+	struct provenance *cprov  = current_provenance();
+	struct provenance *nprov = bprm->cred->provenance;
+	struct provenance *iprov = file_provenance(bprm->file);
+	unsigned long irqflags;
+
+	if (provenance_is_opaque(prov_elt(iprov))) {
+		set_opaque(prov_elt(nprov));
+		return;
+	}
+	record_node_name(cprov, bprm->interp);
+	spin_lock_irqsave_nested(prov_lock(cprov), irqflags, PROVENANCE_LOCK_TASK);
+	spin_lock_nested(prov_lock(iprov), PROVENANCE_LOCK_INODE);
+	flow_between_activities(RL_EXEC_PROCESS, cprov, nprov, NULL);
+	flow_to_activity(RL_EXEC, iprov, nprov, NULL);
+	spin_unlock(prov_lock(iprov));
+	spin_unlock_irqrestore(prov_lock(cprov), irqflags);
+}
+
+/*
+ * Allocate and attach a security structure to the sb->s_security field.
+ * The s_security field is initialized to NULL when the structure is
+ * allocated.
+ * @sb contains the super_block structure to be modified.
+ * Return 0 if operation was successful.
+ */
+static int provenance_sb_alloc_security(struct super_block *sb)
+{
+	struct provenance *sbprov  = alloc_provenance(ENT_SBLCK, GFP_KERNEL);
+
+	if (!sbprov)
+		return -ENOMEM;
+	sb->s_provenance = sbprov;
+	return 0;
+}
+
+/*
+ * Deallocate and clear the sb->s_security field.
+ * @sb contains the super_block structure to be modified.
+ */
+static void provenance_sb_free_security(struct super_block *sb)
+{
+	if (sb->s_provenance)
+		free_provenance(sb->s_provenance);
+	sb->s_provenance = NULL;
+}
+
+static int provenance_sb_kern_mount(struct super_block *sb,
+				    int flags,
+				    void *data)
+{
+	int i;
+	uint8_t c = 0;
+	struct provenance *sbprov = sb->s_provenance;
+
+	for (i = 0; i < 16; i++) {
+		prov_elt(sbprov)->sb_info.uuid[i] = sb->s_uuid[i];
+		c |= sb->s_uuid[i];
+	}
+	if (c == 0) // no uuid defined, generate random one
+		get_random_bytes(prov_elt(sbprov)->sb_info.uuid, 16 * sizeof(uint8_t));
+	return 0;
+}
+
+static struct security_hook_list provenance_hooks[] __ro_after_init = {
+	/* task related hooks */
+	LSM_HOOK_INIT(cred_alloc_blank,	      provenance_cred_alloc_blank),
+	LSM_HOOK_INIT(cred_free,	      provenance_cred_free),
+	LSM_HOOK_INIT(cred_prepare,	      provenance_cred_prepare),
+	LSM_HOOK_INIT(cred_transfer,	      provenance_cred_transfer),
+	LSM_HOOK_INIT(task_fix_setuid,	      provenance_task_fix_setuid),
+
+	/* inode related hooks */
+	LSM_HOOK_INIT(inode_alloc_security,   provenance_inode_alloc_security),
+	LSM_HOOK_INIT(inode_create,	      provenance_inode_create),
+	LSM_HOOK_INIT(inode_free_security,    provenance_inode_free_security),
+	LSM_HOOK_INIT(inode_permission,	      provenance_inode_permission),
+	LSM_HOOK_INIT(inode_link,	      provenance_inode_link),
+	LSM_HOOK_INIT(inode_rename,	      provenance_inode_rename),
+	LSM_HOOK_INIT(inode_setattr,	      provenance_inode_setattr),
+	LSM_HOOK_INIT(inode_getattr,	      provenance_inode_getattr),
+	LSM_HOOK_INIT(inode_readlink,	      provenance_inode_readlink),
+	LSM_HOOK_INIT(inode_setxattr,	      provenance_inode_setxattr),
+	LSM_HOOK_INIT(inode_post_setxattr,    provenance_inode_post_setxattr),
+	LSM_HOOK_INIT(inode_getxattr,	      provenance_inode_getxattr),
+	LSM_HOOK_INIT(inode_listxattr,	      provenance_inode_listxattr),
+	LSM_HOOK_INIT(inode_removexattr,      provenance_inode_removexattr),
+	LSM_HOOK_INIT(inode_getsecurity,      provenance_inode_getsecurity),
+	LSM_HOOK_INIT(inode_listsecurity,     provenance_inode_listsecurity),
+
+	/* file related hooks */
+	LSM_HOOK_INIT(file_permission,	      provenance_file_permission),
+	LSM_HOOK_INIT(mmap_file,	      provenance_mmap_file),
+	LSM_HOOK_INIT(file_ioctl,	      provenance_file_ioctl),
+	LSM_HOOK_INIT(file_open,	      provenance_file_open),
+
+	/* msg related hooks */
+	LSM_HOOK_INIT(msg_msg_alloc_security, provenance_msg_msg_alloc_security),
+	LSM_HOOK_INIT(msg_msg_free_security,  provenance_msg_msg_free_security),
+	LSM_HOOK_INIT(msg_queue_msgsnd,	      provenance_msg_queue_msgsnd),
+	LSM_HOOK_INIT(msg_queue_msgrcv,	      provenance_msg_queue_msgrcv),
+
+	/* shared memory related hooks */
+	LSM_HOOK_INIT(shm_alloc_security,     provenance_shm_alloc_security),
+	LSM_HOOK_INIT(shm_free_security,      provenance_shm_free_security),
+	LSM_HOOK_INIT(shm_shmat,	      provenance_shm_shmat),
+
+	/* socket related hooks */
+	LSM_HOOK_INIT(sk_alloc_security,      provenance_sk_alloc_security),
+	LSM_HOOK_INIT(socket_post_create,     provenance_socket_post_create),
+	LSM_HOOK_INIT(socket_bind,	      provenance_socket_bind),
+	LSM_HOOK_INIT(socket_connect,	      provenance_socket_connect),
+	LSM_HOOK_INIT(socket_listen,	      provenance_socket_listen),
+	LSM_HOOK_INIT(socket_accept,	      provenance_socket_accept),
+	LSM_HOOK_INIT(socket_sendmsg,	      provenance_socket_sendmsg),
+	LSM_HOOK_INIT(socket_recvmsg,	      provenance_socket_recvmsg),
+	LSM_HOOK_INIT(socket_sock_rcv_skb,    provenance_socket_sock_rcv_skb),
+	LSM_HOOK_INIT(unix_stream_connect,    provenance_unix_stream_connect),
+	LSM_HOOK_INIT(unix_may_send,	      provenance_unix_may_send),
+
+	/* exec related hooks */
+	LSM_HOOK_INIT(bprm_set_creds,	      provenance_bprm_set_creds),
+	LSM_HOOK_INIT(bprm_committing_creds,  provenance_bprm_committing_creds),
+
+	/* file system related hooks */
+	LSM_HOOK_INIT(sb_alloc_security,      provenance_sb_alloc_security),
+	LSM_HOOK_INIT(sb_free_security,	      provenance_sb_free_security),
+	LSM_HOOK_INIT(sb_kern_mount,	      provenance_sb_kern_mount)
+};
+
+struct kmem_cache *provenance_cache;
+struct kmem_cache *long_provenance_cache;
+
+struct prov_boot_buffer         *boot_buffer;
+struct prov_long_boot_buffer    *long_boot_buffer;
+
+LIST_HEAD(ingress_ipv4filters);
+LIST_HEAD(egress_ipv4filters);
+LIST_HEAD(secctx_filters);
+LIST_HEAD(ns_filters);
+LIST_HEAD(provenance_query_hooks);
+
+struct capture_policy prov_policy;
+
+uint32_t prov_machine_id;
+uint32_t prov_boot_id;
+
+void __init provenance_add_hooks(void)
+{
+	prov_policy.prov_enabled = true;
+#ifdef CONFIG_SECURITY_PROVENANCE_WHOLE_SYSTEM
+	prov_policy.prov_all = true;
+#else
+	prov_policy.prov_all = false;
+#endif
+	prov_machine_id = 1;
+	prov_boot_id = 0;
+	provenance_cache = kmem_cache_create("provenance_struct",
+					     sizeof(struct provenance),
+					     0, SLAB_PANIC, NULL);
+	long_provenance_cache = kmem_cache_create("long_provenance_struct",
+					     sizeof(union long_prov_elt),
+					     0, SLAB_PANIC, NULL);
+	/* init relay buffers, to deal with provenance before FS is ready */
+	boot_buffer = kzalloc(sizeof(struct prov_boot_buffer), GFP_KERNEL);
+	if (unlikely(!boot_buffer))
+		panic("Provenance: could not allocate boot_buffer.");
+	long_boot_buffer = kzalloc(sizeof(struct prov_long_boot_buffer), GFP_KERNEL);
+	if (unlikely(!long_boot_buffer))
+		panic("Provenance: could not allocate long_boot_buffer.");
+#ifdef CONFIG_SECURITY_PROVENANCE_PERSISTENCE
+	prov_queue = alloc_workqueue("prov_queue", 0, 0);
+	if (!prov_queue)
+		pr_err("Provenance: could not initialise work queue.");
+#endif
+	relay_ready = false;
+	cred_init_provenance();
+	/* register the provenance security hooks */
+	security_add_hooks(provenance_hooks, ARRAY_SIZE(provenance_hooks), "provenance");
+	pr_info("Provenance: Camflow %s\n", CAMFLOW_VERSION_STR);
+	pr_info("Provenance: hooks ready.\n");
+}
diff -uprN -b -B ./pristine/linux-4.11.2/security/provenance/include/provenance_filter.h ./linux-4.11.2/security/provenance/include/provenance_filter.h
--- ./pristine/linux-4.11.2/security/provenance/include/provenance_filter.h	1970-01-01 01:00:00.000000000 +0100
+++ ./linux-4.11.2/security/provenance/include/provenance_filter.h	2017-05-22 10:47:47.573666474 +0100
@@ -0,0 +1,128 @@
+/*
+ *
+ * Author: Thomas Pasquier <tfjmp@seas.harvard.edu>
+ *
+ * Copyright (C) 2016 Harvard University
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2, as
+ * published by the Free Software Foundation; either version 2 of the License,
+ * or (at your option) any later version.
+ *
+ */
+#ifndef _LINUX_PROVENANCE_FILTER_H
+#define _LINUX_PROVENANCE_FILTER_H
+
+#include <uapi/linux/provenance.h>
+
+#include "provenance_policy.h"
+#include "provenance_ns.h"
+#include "provenance_secctx.h"
+
+#define HIT_FILTER(filter, data) ((filter & data) != 0)
+
+#define filter_node(node) __filter_node(prov_policy.prov_node_filter, node)
+#define filter_propagate_node(node) __filter_node(prov_policy.prov_propagate_node_filter, node)
+
+/* return either or not the node should be filtered out */
+static inline bool __filter_node(uint64_t filter, prov_entry_t *node)
+{
+	if (!prov_policy.prov_enabled)
+		return true;
+	if (provenance_is_opaque(node))
+		return true;
+	// we hit an element of the black list ignore
+	if (HIT_FILTER(filter, node_identifier(node).type))
+		return true;
+	return false;
+}
+
+#define UPDATE_FILTER (SUBTYPE(RL_VERSION_PROCESS) | SUBTYPE(RL_VERSION) | SUBTYPE(RL_NAMED))
+static inline bool filter_update_node(uint64_t relation_type)
+{
+	if (HIT_FILTER(UPDATE_FILTER, relation_type)) // not update if relation is of above type
+		return true;
+	return false;
+}
+
+/* return either or not the relation should be filtered out */
+static inline bool filter_relation(uint64_t type)
+{
+	// we hit an element of the black list ignore
+	if (HIT_FILTER(prov_policy.prov_relation_filter, type))
+		return true;
+	return false;
+}
+
+/* return either or not tracking should propagate */
+static inline bool filter_propagate_relation(uint64_t type)
+{
+	// the relation does not allow tracking propagation
+	if (HIT_FILTER(prov_policy.prov_propagate_relation_filter, type))
+		return true;
+	return false;
+}
+
+static inline bool should_record_relation(uint64_t type, union prov_elt *from, union prov_elt *to)
+{
+	if (filter_relation(type))
+		return false;
+	// one of the node should not appear in the record, ignore the relation
+	if (filter_node((prov_entry_t *)from) || filter_node((prov_entry_t *)to))
+		return false;
+	return true;
+}
+
+static inline bool prov_has_secid(union prov_elt *prov)
+{
+	switch (prov_type(prov)) {
+	case ENT_INODE_UNKNOWN:
+	case ENT_INODE_LINK:
+	case ENT_INODE_FILE:
+	case ENT_INODE_DIRECTORY:
+	case ENT_INODE_CHAR:
+	case ENT_INODE_BLOCK:
+	case ENT_INODE_FIFO:
+	case ENT_INODE_SOCKET:
+	case ENT_INODE_MMAP:
+		return true;
+	default: return false;
+	}
+}
+
+static inline void apply_target(union prov_elt *prov)
+{
+	uint8_t op;
+
+	// track based on ns
+	if (prov_type(prov) == ACT_TASK) {
+		op = prov_ns_whichOP(prov->task_info.utsns,
+										prov->task_info.ipcns,
+										prov->task_info.mntns,
+										prov->task_info.pidns,
+										prov->task_info.netns,
+										prov->task_info.cgroupns);
+		if (unlikely(op != 0)) {
+			pr_info("Provenance: apply ns filter %u.", op);
+			if ((op & PROV_NS_TRACKED) != 0)
+				set_tracked(prov);
+			if ((op & PROV_NS_PROPAGATE) != 0)
+				set_propagate(prov);
+			if ((op & PROV_NS_OPAQUE) != 0)
+				set_opaque(prov);
+		}
+	}
+	if (prov_has_secid(prov)) {
+		op = prov_secctx_whichOP(node_secid(prov));
+		if (unlikely(op != 0)) {
+			pr_info("Provenance: apply secctx filter %u.", op);
+			if ((op & PROV_SEC_TRACKED) != 0)
+				set_tracked(prov);
+			if ((op & PROV_SEC_PROPAGATE) != 0)
+				set_propagate(prov);
+			if ((op & PROV_SEC_OPAQUE) != 0)
+				set_opaque(prov);
+		}
+	}
+}
+#endif
diff -uprN -b -B ./pristine/linux-4.11.2/security/provenance/include/provenance.h ./linux-4.11.2/security/provenance/include/provenance.h
--- ./pristine/linux-4.11.2/security/provenance/include/provenance.h	1970-01-01 01:00:00.000000000 +0100
+++ ./linux-4.11.2/security/provenance/include/provenance.h	2017-05-22 10:47:47.574666483 +0100
@@ -0,0 +1,237 @@
+/*
+ *
+ * Author: Thomas Pasquier <thomas.pasquier@cl.cam.ac.uk>
+ *
+ * Copyright (C) 2015 University of Cambridge
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2, as
+ * published by the Free Software Foundation; either version 2 of the License,
+ * or (at your option) any later version.
+ *
+ */
+#ifndef _LINUX_PROVENANCE_H
+#define _LINUX_PROVENANCE_H
+
+#include <linux/slab.h>
+#include <linux/types.h>
+#include <linux/bug.h>
+#include <linux/socket.h>
+#include <uapi/linux/mman.h>
+#include <uapi/linux/camflow.h>
+#include <uapi/linux/provenance.h>
+#include <uapi/linux/stat.h>
+#include <linux/fs.h>
+#include <linux/mm.h>
+#include <linux/xattr.h>
+
+#include "provenance_policy.h"
+#include "provenance_filter.h"
+#include "provenance_relay.h"
+
+extern struct kmem_cache *provenance_cache;
+extern struct kmem_cache *long_provenance_cache;
+
+enum {
+	PROVENANCE_LOCK_TASK,
+	PROVENANCE_LOCK_DIR,
+	PROVENANCE_LOCK_INODE,
+	PROVENANCE_LOCK_MSG,
+	PROVENANCE_LOCK_SHM,
+	PROVENANCE_LOCK_SOCKET,
+	PROVENANCE_LOCK_SOCK
+};
+
+struct provenance {
+	union prov_elt msg;
+	spinlock_t lock;
+	uint8_t updt_mmap;
+	uint8_t has_mmap;
+	bool has_outgoing;
+	bool initialised;
+	bool saved;
+};
+
+#define prov_elt(provenance) (&(provenance->msg))
+#define prov_lock(provenance) (&(provenance->lock))
+#define prov_entry(provenance) ((prov_entry_t *)prov_elt(provenance))
+
+#define ASSIGN_NODE_ID 0
+
+static inline struct provenance *alloc_provenance(uint64_t ntype, gfp_t gfp)
+{
+	struct provenance *prov =  kmem_cache_zalloc(provenance_cache, gfp);
+
+	if (!prov)
+		return NULL;
+	spin_lock_init(prov_lock(prov));
+	prov_type(prov_elt(prov)) = ntype;
+	node_identifier(prov_elt(prov)).id = prov_next_node_id();
+	node_identifier(prov_elt(prov)).boot_id = prov_boot_id;
+	node_identifier(prov_elt(prov)).machine_id = prov_machine_id;
+	return prov;
+}
+
+static inline void free_provenance(struct provenance *prov)
+{
+	kmem_cache_free(provenance_cache, prov);
+}
+
+static inline union long_prov_elt *alloc_long_provenance(uint64_t ntype)
+{
+	union long_prov_elt *tmp = kmem_cache_zalloc(long_provenance_cache, GFP_ATOMIC);
+
+	if (!tmp)
+		return NULL;
+	prov_type(tmp) = ntype;
+	node_identifier(tmp).id = prov_next_node_id();
+	node_identifier(tmp).boot_id = prov_boot_id;
+	node_identifier(tmp).machine_id = prov_machine_id;
+	return tmp;
+}
+
+static inline void free_long_provenance(union long_prov_elt *prov)
+{
+	kmem_cache_free(long_provenance_cache, prov);
+}
+
+static inline int record_node_name(struct provenance *node, const char *name)
+{
+	union long_prov_elt *fname_prov;
+	int rc;
+
+	if (provenance_is_name_recorded(prov_elt(node)) || !provenance_is_recorded(prov_elt(node)))
+		return 0;
+	fname_prov = alloc_long_provenance(ENT_FILE_NAME);
+	if (!fname_prov) {
+		pr_err("Provenance: recod name failed to allocate memory\n");
+		return -ENOMEM;
+	}
+	strlcpy(fname_prov->file_name_info.name, name, PATH_MAX);
+	fname_prov->file_name_info.length = strnlen(fname_prov->file_name_info.name, PATH_MAX);
+	write_long_node(fname_prov);
+	if (prov_type(prov_elt(node)) == ACT_TASK) {
+		spin_lock_nested(prov_lock(node), PROVENANCE_LOCK_TASK);
+		rc = write_relation(RL_NAMED_PROCESS, fname_prov, prov_elt(node), NULL);
+		set_name_recorded(prov_elt(node));
+		spin_unlock(prov_lock(node));
+	} else{
+		spin_lock_nested(prov_lock(node), PROVENANCE_LOCK_INODE);
+		rc = write_relation(RL_NAMED, fname_prov, prov_elt(node), NULL);
+		set_name_recorded(prov_elt(node));
+		spin_unlock(prov_lock(node));
+	}
+	free_long_provenance(fname_prov);
+	return rc;
+}
+
+static inline int record_log(union prov_elt *cprov, const char __user *buf, size_t count)
+{
+	union long_prov_elt *str;
+	int rc = 0;
+
+	str = alloc_long_provenance(ENT_STR);
+	if (!str) {
+		rc = -ENOMEM;
+		goto out;
+	}
+	if (copy_from_user(str->str_info.str, buf, count)) {
+		rc = -EAGAIN;
+		goto out;
+	}
+	str->str_info.str[count] = '\0'; // make sure the string is null terminated
+	str->str_info.length = count;
+	write_node(cprov);
+	write_long_node(str);
+	rc = write_relation(RL_SAID, str, cprov, NULL);
+out:
+	free_long_provenance(str);
+	if (rc < 0)
+		return rc;
+	return count;
+}
+
+static inline int __update_version(uint64_t type, struct provenance *prov)
+{
+	union prov_elt old_prov;
+	int rc = 0;
+
+	if (!prov->has_outgoing) // there is no outgoing
+		return 0;
+	if (filter_update_node(type))
+		return 0;
+	memcpy(&old_prov, prov_elt(prov), sizeof(union prov_elt));
+	node_identifier(prov_elt(prov)).version++;
+	clear_recorded(prov_elt(prov));
+	write_node(prov_elt(prov));
+	write_node(&old_prov);
+	if (node_identifier(prov_elt(prov)).type == ACT_TASK)
+		rc = write_relation(RL_VERSION_PROCESS, &old_prov, prov_elt(prov), NULL);
+	else
+		rc = write_relation(RL_VERSION, &old_prov, prov_elt(prov), NULL);
+	prov->has_outgoing = false; // we update there is no more outgoing edge
+	prov->saved = false;
+	return rc;
+}
+
+static inline int record_relation(uint64_t type,
+				  struct provenance *from,
+				  struct provenance *to,
+				  struct file *file)
+{
+	int rc = 0;
+
+	// check if the nodes match some capture options
+	apply_target(prov_elt(from));
+	apply_target(prov_elt(to));
+
+	if (!provenance_is_tracked(prov_elt(from)) && !provenance_is_tracked(prov_elt(to)) && !prov_policy.prov_all)
+		return 0;
+	if (!should_record_relation(type, prov_elt(from), prov_elt(to)))
+		return 0;
+	rc = __update_version(type, to);
+	if (rc < 0)
+		return rc;
+	write_node(prov_elt(from));
+	write_node(prov_elt(to));
+	rc = write_relation(type, prov_elt(from), prov_elt(to), file);
+	from->has_outgoing = true; // there is an outgoing edge
+	return rc;
+}
+
+static inline int flow_to_activity(uint64_t type,
+				   struct provenance *from,
+				   struct provenance *to,
+				   struct file *file)
+{
+	int rc = record_relation(type, from, to, file);
+
+	if (should_record_relation(type, prov_elt(from), prov_elt(to)))
+		to->updt_mmap = 1;
+	return rc;
+}
+
+static inline int flow_from_activity(uint64_t type,
+				     struct provenance *from,
+				     struct provenance *to,
+				     struct file *file)
+{
+	return record_relation(type, from, to, file);
+}
+
+static inline int flow_between_entities(uint64_t type,
+					struct provenance *from,
+					struct provenance *to,
+					struct file *file)
+{
+	return record_relation(type, from, to, file);
+}
+
+static inline int flow_between_activities(uint64_t type,
+					  struct provenance *from,
+					  struct provenance *to,
+					  struct file *file)
+{
+	return record_relation(type, from, to, file);
+}
+#endif
diff -uprN -b -B ./pristine/linux-4.11.2/security/provenance/include/provenance_inode.h ./linux-4.11.2/security/provenance/include/provenance_inode.h
--- ./pristine/linux-4.11.2/security/provenance/include/provenance_inode.h	1970-01-01 01:00:00.000000000 +0100
+++ ./linux-4.11.2/security/provenance/include/provenance_inode.h	2017-05-22 10:47:47.574666483 +0100
@@ -0,0 +1,373 @@
+/*
+ *
+ * Author: Thomas Pasquier <tfjmp@seas.harvard.edu>
+ *
+ * Copyright (C) 2016 Harvard University
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2, as
+ * published by the Free Software Foundation; either version 2 of the License,
+ * or (at your option) any later version.
+ *
+ */
+#ifndef CONFIG_SECURITY_PROVENANCE_INODE
+#define CONFIG_SECURITY_PROVENANCE_INODE
+#include <linux/file.h>
+#include <linux/fs.h>
+#include <linux/namei.h>
+#include <linux/xattr.h>
+
+#include "provenance_policy.h"
+#include "provenance_secctx.h"  // for record_inode_name
+
+#define is_inode_dir(inode) S_ISDIR(inode->i_mode)
+#define is_inode_socket(inode) S_ISSOCK(inode->i_mode)
+#define is_inode_file(inode) S_ISREG(inode->i_mode)
+
+static inline void update_inode_type(uint16_t mode, struct provenance *prov)
+{
+	uint64_t type = ENT_INODE_UNKNOWN;
+	unsigned long irqflags;
+
+	if (S_ISBLK(mode))
+		type = ENT_INODE_BLOCK;
+	else if (S_ISCHR(mode))
+		type = ENT_INODE_CHAR;
+	else if (S_ISDIR(mode))
+		type = ENT_INODE_DIRECTORY;
+	else if (S_ISFIFO(mode))
+		type = ENT_INODE_FIFO;
+	else if (S_ISLNK(mode))
+		type = ENT_INODE_LINK;
+	else if (S_ISREG(mode))
+		type = ENT_INODE_FILE;
+	else if (S_ISSOCK(mode))
+		type = ENT_INODE_SOCKET;
+	spin_lock_irqsave_nested(prov_lock(prov), irqflags, PROVENANCE_LOCK_INODE);
+	prov_elt(prov)->inode_info.mode = mode;
+	prov_type(prov_elt(prov)) = type;
+	spin_unlock_irqrestore(prov_lock(prov), irqflags);
+}
+
+static inline void provenance_mark_as_opaque(const char *name)
+{
+	struct path path;
+	struct provenance *prov;
+
+	if (kern_path(name, LOOKUP_FOLLOW, &path)) {
+		pr_err("Provenance: Failed file look up (%s).", name);
+		return;
+	}
+	prov = path.dentry->d_inode->i_provenance;
+	if (prov)
+		set_opaque(prov_elt(prov));
+}
+
+static inline int record_inode_name_from_dentry(struct dentry *dentry, struct provenance *prov)
+{
+	char *buffer;
+	char *ptr;
+	int rc;
+
+	if (provenance_is_name_recorded(prov_elt(prov)) ||
+	    !provenance_is_recorded(prov_elt(prov)))
+		return 0;
+	// should not sleep
+	buffer = kcalloc(PATH_MAX, sizeof(char), GFP_ATOMIC);
+	if (!buffer) {
+		pr_err("Provenance: could not allocate memory\n");
+		return -ENOMEM;
+	}
+	ptr = dentry_path_raw(dentry, buffer, PATH_MAX);
+	rc = record_node_name(prov, ptr);
+	kfree(buffer);
+	return rc;
+}
+
+static inline int record_inode_name(struct inode *inode, struct provenance *prov)
+{
+	struct dentry *dentry;
+	int rc;
+
+	if (provenance_is_name_recorded(prov_elt(prov)) || !provenance_is_recorded(prov_elt(prov)))
+		return 0;
+	dentry = d_find_alias(inode);
+	if (!dentry) // we did not find a dentry, not sure if it should ever happen
+		return 0;
+	rc = record_inode_name_from_dentry(dentry, prov);
+	dput(dentry);
+	return rc;
+}
+
+static inline void refresh_inode_provenance(struct inode *inode)
+{
+	struct provenance *prov = inode->i_provenance;
+
+	// will not be recorded
+	if (provenance_is_opaque(prov_elt(prov)))
+		return;
+	record_inode_name(inode, prov);
+	prov_elt(prov)->inode_info.ino = inode->i_ino;
+	prov_elt(prov)->inode_info.uid = __kuid_val(inode->i_uid);
+	prov_elt(prov)->inode_info.gid = __kgid_val(inode->i_gid);
+	security_inode_getsecid(inode, &(prov_elt(prov)->inode_info.secid));
+}
+
+static inline struct provenance *branch_mmap(struct provenance *iprov, struct provenance *cprov)
+{
+	struct provenance *prov;
+
+	if (!provenance_is_tracked(prov_elt(iprov)) && !provenance_is_tracked(prov_elt(cprov)) && !prov_policy.prov_all)
+		return NULL;
+	prov = alloc_provenance(ENT_INODE_MMAP, GFP_ATOMIC);
+	if (!prov)
+		return NULL;
+	set_tracked(prov_elt(prov));
+	prov_elt(prov)->inode_info.uid = prov_elt(iprov)->inode_info.uid;
+	prov_elt(prov)->inode_info.gid = prov_elt(iprov)->inode_info.gid;
+	prov_elt(prov)->inode_info.mode = prov_elt(iprov)->inode_info.mode;
+	prov_elt(prov)->inode_info.ino = prov_elt(iprov)->inode_info.ino;
+	memcpy(prov_elt(prov)->inode_info.sb_uuid, prov_elt(iprov)->inode_info.sb_uuid, 16 * sizeof(uint8_t));
+	return prov;
+}
+
+static inline int inode_init_provenance(struct inode *inode, struct dentry *opt_dentry)
+{
+	struct provenance *prov = inode->i_provenance;
+	union prov_elt *buf;
+	struct dentry *dentry;
+	int rc = 0;
+
+	if (prov->initialised)
+		return 0;
+	spin_lock_nested(prov_lock(prov), PROVENANCE_LOCK_INODE);
+	if (prov->initialised) {
+		spin_unlock(prov_lock(prov));
+		return 0;
+	}       else
+		prov->initialised = true;
+	spin_unlock(prov_lock(prov));
+	update_inode_type(inode->i_mode, prov);
+	if (!(inode->i_opflags & IOP_XATTR)) // xattr not supported on this inode
+		return 0;
+	if (opt_dentry)
+		dentry = dget(opt_dentry);
+	else
+		dentry = d_find_alias(inode);
+	if (!dentry)
+		return 0;
+	buf = kmalloc(sizeof(union prov_elt), GFP_NOFS);
+	if (!buf) {
+		prov->initialised = false;
+		dput(dentry);
+		return -ENOMEM;
+	}
+	rc = __vfs_getxattr(dentry, inode, XATTR_NAME_PROVENANCE, buf, sizeof(union prov_elt));
+	dput(dentry);
+	if (rc < 0) {
+		if (rc != -ENODATA && rc != -EOPNOTSUPP) {
+			prov->initialised = false;
+			goto free_buf;
+		} else {
+			rc = 0;
+			goto free_buf;
+		}
+	}
+	memcpy(prov_elt(prov), buf, sizeof(union prov_elt));
+	rc = 0;
+free_buf:
+	kfree(buf);
+	return rc;
+}
+
+static inline struct provenance *inode_provenance(struct inode *inode, bool may_sleep)
+{
+	struct provenance *prov = inode->i_provenance;
+
+	might_sleep_if(may_sleep);
+	if (!prov->initialised && may_sleep)
+		inode_init_provenance(inode, NULL);
+	return prov;
+}
+
+static inline struct provenance *dentry_provenance(struct dentry *dentry)
+{
+	struct inode *inode = d_backing_inode(dentry);
+	struct provenance *prov;
+
+	if (!inode)
+		return NULL;
+	prov = inode->i_provenance;
+	inode_init_provenance(inode, dentry);
+	return prov;
+}
+
+static inline struct provenance *file_provenance(struct file *file)
+{
+	struct inode *inode = file_inode(file);
+
+	if (!inode)
+		return NULL;
+	return inode_provenance(inode, true);
+}
+
+static inline void save_provenance(struct dentry *dentry)
+{
+	struct inode *inode;
+	struct provenance *prov;
+	union prov_elt buf;
+
+	if (!dentry)
+		return;
+	inode = d_backing_inode(dentry);
+	if (!inode)
+		return;
+	prov = inode->i_provenance;
+	if (!prov)
+		return;
+	spin_lock(prov_lock(prov));
+	if (!prov->initialised || prov->saved) { // not initialised or already saved
+		spin_unlock(prov_lock(prov));
+		return;
+	}
+	memcpy(&buf, prov_elt(prov), sizeof(union prov_elt));
+	prov->saved = true;
+	spin_unlock(prov_lock(prov));
+	clear_recorded(&buf);
+	clear_name_recorded(&buf);
+	if (!dentry)
+		return;
+	__vfs_setxattr_noperm(dentry, XATTR_NAME_PROVENANCE, &buf, sizeof(union prov_elt), 0);
+}
+
+static inline int record_write_xattr(uint64_t type,
+				     struct provenance *iprov,
+				     struct provenance *cprov,
+				     const char *name,
+				     const void *value,
+				     size_t size,
+				     int flags)
+{
+	union long_prov_elt *xattr;
+	int rc = 0;
+
+	if (!should_record_relation(type, prov_elt(cprov), prov_elt(iprov)))
+		return 0;
+	xattr = alloc_long_provenance(ENT_XATTR);
+	if (!xattr)
+		goto out;
+	memcpy(xattr->xattr_info.name, name, PROV_XATTR_NAME_SIZE - 1);
+	xattr->xattr_info.name[PROV_XATTR_NAME_SIZE - 1] = '\0';
+	if (value) {
+		if (size < PROV_XATTR_VALUE_SIZE) {
+			xattr->xattr_info.size = size;
+			memcpy(xattr->xattr_info.value, value, size);
+		} else{
+			xattr->xattr_info.size = PROV_XATTR_VALUE_SIZE;
+			memcpy(xattr->xattr_info.value, value, PROV_XATTR_VALUE_SIZE);
+		}
+		xattr->xattr_info.flags = flags;
+	}
+	write_node(prov_elt(cprov));
+	write_long_node(xattr);
+	rc = write_relation(type, prov_elt(cprov), xattr, NULL);
+	if (rc < 0)
+		goto out;
+	rc = __update_version(type, iprov);
+	if (rc < 0)
+		goto out;
+	write_node(prov_elt(iprov));
+	rc = write_relation(type, xattr, prov_elt(iprov), NULL);
+	cprov->has_outgoing = true;
+out:
+	free_long_provenance(xattr);
+	return rc;
+}
+
+static inline int record_read_xattr(uint64_t type,
+				    struct provenance *cprov,
+				    struct provenance *iprov,
+				    const char *name)
+{
+	union long_prov_elt *xattr;
+	int rc = 0;
+
+	if (!should_record_relation(type, prov_elt(iprov), prov_elt(cprov)))
+		return 0;
+	xattr = alloc_long_provenance(ENT_XATTR);
+	if (!xattr)
+		goto out;
+	memcpy(xattr->xattr_info.name, name, PROV_XATTR_NAME_SIZE - 1);
+	xattr->xattr_info.name[PROV_XATTR_NAME_SIZE - 1] = '\0';
+	write_node(prov_elt(iprov));
+	write_long_node(xattr);
+	rc = write_relation(type, prov_elt(iprov), xattr, NULL);
+	if (rc < 0)
+		goto out;
+	rc = __update_version(type, cprov);
+	if (rc < 0)
+		goto out;
+	write_node(prov_elt(cprov));
+	rc = write_relation(type, xattr, prov_elt(cprov), NULL);
+	iprov->has_outgoing = true;
+out:
+	free_long_provenance(xattr);
+	return rc;
+}
+
+static inline int close_inode(struct provenance *iprov)
+{
+	union prov_elt old_prov;
+	int rc;
+
+	if (!provenance_is_tracked(prov_elt(iprov)) && !prov_policy.prov_all)
+		return 0;
+	if (filter_node(prov_entry(iprov)))
+		return 0;
+	// persistent
+	if (prov_type(prov_entry(iprov)) == ENT_INODE_FILE ||
+			prov_type(prov_entry(iprov)) == ENT_INODE_DIRECTORY)
+		return 0;
+	memcpy(&old_prov, prov_elt(iprov), sizeof(union prov_elt));
+	node_identifier(prov_elt(iprov)).version++;
+	clear_recorded(prov_elt(iprov));
+	write_node(&old_prov);
+	write_node(prov_elt(iprov));
+	rc = write_relation(RL_CLOSED, &old_prov, prov_elt(iprov), NULL);
+	iprov->has_outgoing = false;
+	return rc;
+}
+
+#define FILE__EXECUTE   0x00000001UL
+#define FILE__READ      0x00000002UL
+#define FILE__APPEND    0x00000004UL
+#define FILE__WRITE     0x00000008UL
+#define DIR__SEARCH     0x00000010UL
+#define DIR__WRITE      0x00000020UL
+#define DIR__READ       0x00000040UL
+
+static inline uint32_t file_mask_to_perms(int mode, unsigned int mask)
+{
+	uint32_t av = 0;
+
+	if (!S_ISDIR(mode)) {
+		if (mask & MAY_EXEC)
+			av |= FILE__EXECUTE;
+		if (mask & MAY_READ)
+			av |= FILE__READ;
+		if (mask & MAY_APPEND)
+			av |= FILE__APPEND;
+		else if (mask & MAY_WRITE)
+			av |= FILE__WRITE;
+	} else {
+		if (mask & MAY_EXEC)
+			av |= DIR__SEARCH;
+		if (mask & MAY_WRITE)
+			av |= DIR__WRITE;
+		if (mask & MAY_READ)
+			av |= DIR__READ;
+	}
+
+	return av;
+}
+#endif
diff -uprN -b -B ./pristine/linux-4.11.2/security/provenance/include/provenance_net.h ./linux-4.11.2/security/provenance/include/provenance_net.h
--- ./pristine/linux-4.11.2/security/provenance/include/provenance_net.h	1970-01-01 01:00:00.000000000 +0100
+++ ./linux-4.11.2/security/provenance/include/provenance_net.h	2017-05-22 10:47:47.574666483 +0100
@@ -0,0 +1,269 @@
+/*
+ *
+ * Author: Thomas Pasquier <tfjmp@seas.harvard.edu>
+ *
+ * Copyright (C) 2016 Harvard University
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2, as
+ * published by the Free Software Foundation; either version 2 of the License,
+ * or (at your option) any later version.
+ *
+ */
+#ifndef CONFIG_SECURITY_PROVENANCE_NET
+#define CONFIG_SECURITY_PROVENANCE_NET
+
+#include <net/sock.h>
+#include <net/ip.h>
+#include <linux/netfilter_ipv4.h>
+#include <linux/netfilter_ipv6.h>
+#include <linux/ip.h>
+#include <linux/tcp.h>
+#include <linux/udp.h>
+#include <linux/skbuff.h>
+
+#include "provenance.h"
+#include "provenance_policy.h"
+
+static inline struct provenance *socket_inode_provenance(struct socket *sock)
+{
+	struct provenance *iprov = SOCK_INODE(sock)->i_provenance;
+
+	return iprov;
+}
+
+static inline struct provenance *sk_inode_provenance(struct sock *sk)
+{
+	struct socket *sock = sk->sk_socket;
+
+	if (!sock)
+		return NULL;
+	return socket_inode_provenance(sock);
+}
+
+static inline struct provenance *sk_provenance(struct sock *sk)
+{
+	struct provenance *prov = sk->sk_provenance;
+
+	return prov;
+}
+
+#define ihlen(ih) (ih->ihl * 4)
+
+static inline void __extract_tcp_info(struct sk_buff *skb,
+				      struct iphdr *ih,
+				      int offset,
+				      struct packet_identifier *id)
+{
+	struct tcphdr _tcph;
+	struct tcphdr *th;
+	int tcpoff;
+
+	if (ntohs(ih->frag_off) & IP_OFFSET)
+		return;
+	tcpoff = offset + ihlen(ih); //point to tcp packet
+	th = skb_header_pointer(skb, tcpoff, sizeof(_tcph), &_tcph);
+	if (!th)
+		return;
+	id->snd_port = th->source;
+	id->rcv_port = th->dest;
+	id->seq = th->seq;
+}
+
+static inline void __extract_udp_info(struct sk_buff *skb,
+				      struct iphdr *ih,
+				      int offset,
+				      struct packet_identifier *id)
+{
+	struct udphdr _udph;
+	struct udphdr   *uh;
+	int udpoff;
+
+	if (ntohs(ih->frag_off) & IP_OFFSET)
+		return;
+	udpoff = offset + ihlen(ih); //point to udp packet
+	uh = skb_header_pointer(skb, udpoff, sizeof(_udph), &_udph);
+	if (!uh)
+		return;
+	id->snd_port = uh->source;
+	id->rcv_port = uh->dest;
+}
+
+static inline unsigned int provenance_parse_skb_ipv4(struct sk_buff *skb, union prov_elt *prov)
+{
+	struct packet_identifier *id;
+	int offset;
+	struct iphdr _iph;
+	struct iphdr *ih;
+
+	offset = skb_network_offset(skb);
+	ih = skb_header_pointer(skb, offset, sizeof(_iph), &_iph); // we obtain the ip header
+	if (!ih)
+		return -EINVAL;
+
+	if (ihlen(ih) < sizeof(_iph))
+		return -EINVAL;
+
+	memset(prov, 0, sizeof(union prov_elt));
+	id = &packet_identifier(prov); // we are going fo fill this
+
+	id->type = ENT_PACKET;
+	// collect IP element of prov identifier
+	id->id = ih->id;
+	id->snd_ip = ih->saddr;
+	id->rcv_ip = ih->daddr;
+	id->protocol = ih->protocol;
+	prov->pck_info.length = ih->tot_len;
+
+	// now we collect
+	switch (ih->protocol) {
+	case IPPROTO_TCP:
+		__extract_tcp_info(skb, ih, offset, id);
+		break;
+	case IPPROTO_UDP:
+		__extract_udp_info(skb, ih, offset, id);
+		break;
+	default:
+		break;
+	}
+	return 0;
+}
+
+struct ipv4_filters {
+	struct list_head list;
+	struct prov_ipv4_filter filter;
+};
+
+extern struct list_head ingress_ipv4filters;
+extern struct list_head egress_ipv4filters;
+
+#define prov_ipv4_ingressOP(ip, port) prov_ipv4_whichOP(&ingress_ipv4filters, ip, port)
+#define prov_ipv4_egressOP(ip, port) prov_ipv4_whichOP(&egress_ipv4filters, ip, port)
+
+static inline uint8_t prov_ipv4_whichOP(struct list_head *filters, uint32_t ip, uint32_t port)
+{
+	struct list_head *listentry, *listtmp;
+	struct ipv4_filters *tmp;
+
+	list_for_each_safe(listentry, listtmp, filters) {
+		tmp = list_entry(listentry, struct ipv4_filters, list);
+		if ((tmp->filter.mask & ip) == (tmp->filter.mask & tmp->filter.ip))     // ip match filter
+			if (tmp->filter.port == 0 || tmp->filter.port == port)          // any port or match
+				return tmp->filter.op;
+	}
+	return 0; // do nothing
+}
+
+static inline uint8_t prov_ipv4_delete(struct list_head *filters, struct ipv4_filters *f)
+{
+	struct list_head *listentry, *listtmp;
+	struct ipv4_filters *tmp;
+
+	list_for_each_safe(listentry, listtmp, filters) {
+		tmp = list_entry(listentry, struct ipv4_filters, list);
+		if (tmp->filter.mask == f->filter.mask &&
+		    tmp->filter.ip == f->filter.ip &&
+		    tmp->filter.port == f->filter.port) {
+			list_del(listentry);
+			kfree(tmp);
+			return 0; // you should only get one
+		}
+	}
+	return 0; // do nothing
+}
+
+static inline uint8_t prov_ipv4_add_or_update(struct list_head *filters, struct ipv4_filters *f)
+{
+	struct list_head *listentry, *listtmp;
+	struct ipv4_filters *tmp;
+
+	list_for_each_safe(listentry, listtmp, filters) {
+		tmp = list_entry(listentry, struct ipv4_filters, list);
+		if (tmp->filter.mask == f->filter.mask &&
+		    tmp->filter.ip == f->filter.ip &&
+		    tmp->filter.port == f->filter.port) {
+			tmp->filter.op |= f->filter.op;
+			return 0; // you should only get one
+		}
+	}
+	list_add_tail(&(f->list), filters); // not already on the list, we add it
+	return 0;
+}
+
+// incoming packet
+static inline int record_pck_to_inode(union prov_elt *pck, struct provenance *inode)
+{
+	int rc = 0;
+
+	if (unlikely(!pck || !inode)) // should not occur
+		return 0;
+	if (!provenance_is_tracked(prov_elt(inode)) && !prov_policy.prov_all)
+		return 0;
+	if (!should_record_relation(RL_RCV_PACKET, pck, prov_elt(inode)))
+		return 0;
+	rc = __update_version(RL_RCV_PACKET, inode);
+	if (rc < 0)
+		return rc;
+	write_node(prov_elt(inode));
+	prov_write(pck);
+	rc = write_relation(RL_RCV_PACKET, pck, prov_elt(inode), NULL);
+	return rc;
+}
+
+// outgoing packet
+static inline int record_inode_to_pck(struct provenance *inode, union prov_elt *pck)
+{
+	int rc = 0;
+
+	if (unlikely(!pck || !inode)) // should not occur
+		return 0;
+	if (!provenance_is_tracked(prov_elt(inode)) && !prov_policy.prov_all)
+		return 0;
+	if (!should_record_relation(RL_SND_PACKET, prov_elt(inode), pck))
+		return 0;
+	write_node(prov_elt(inode));
+	prov_write(pck);
+	rc = write_relation(RL_SND_PACKET, prov_elt(inode), pck, NULL);
+	inode->has_outgoing = true;
+	return rc;
+}
+
+static inline int provenance_record_address(struct sockaddr *address, int addrlen, struct provenance *prov)
+{
+	union long_prov_elt *addr_info;
+	int rc = 0;
+
+	if (provenance_is_name_recorded(prov_elt(prov)) || !provenance_is_recorded(prov_elt(prov)))
+		return 0;
+	addr_info = alloc_long_provenance(ENT_ADDR);
+	if (!addr_info) {
+		rc = -ENOMEM;
+		goto out;
+	}
+	addr_info->address_info.length = addrlen;
+	memcpy(&(addr_info->address_info.addr), address, addrlen);
+	write_long_node(addr_info);
+	rc = write_relation(RL_NAMED, addr_info, prov_elt(prov), NULL);
+	set_name_recorded(prov_elt(prov));
+out:
+	free_long_provenance(addr_info);
+	return rc;
+}
+
+static inline int record_packet_content(union prov_elt *pck, const struct sk_buff *skb)
+{
+	union long_prov_elt *cnt = alloc_long_provenance(ENT_PCKCNT);
+	int rc;
+
+	cnt->pckcnt_info.length = skb_end_offset(skb);
+	if (cnt->pckcnt_info.length > PATH_MAX) {
+		cnt->pckcnt_info.truncated = PROV_TRUNCATED;
+		memcpy(cnt->pckcnt_info.content, skb->head, PATH_MAX);
+	} else
+		memcpy(cnt->pckcnt_info.content, skb->head, cnt->pckcnt_info.length);
+	write_long_node(cnt);
+	rc = write_relation(RL_READ, cnt, pck, NULL);
+	free_long_provenance(cnt);
+	return rc;
+}
+#endif
diff -uprN -b -B ./pristine/linux-4.11.2/security/provenance/include/provenance_ns.h ./linux-4.11.2/security/provenance/include/provenance_ns.h
--- ./pristine/linux-4.11.2/security/provenance/include/provenance_ns.h	1970-01-01 01:00:00.000000000 +0100
+++ ./linux-4.11.2/security/provenance/include/provenance_ns.h	2017-05-22 10:47:47.574666483 +0100
@@ -0,0 +1,89 @@
+/*
+ *
+ * Author: Thomas Pasquier <tfjmp@seas.harvard.edu>
+ *
+ * Copyright (C) 2017 Harvard University
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2, as
+ * published by the Free Software Foundation; either version 2 of the License,
+ * or (at your option) any later version.
+ *
+ */
+#ifndef CONFIG_SECURITY_PROVENANCE_NS
+#define CONFIG_SECURITY_PROVENANCE_NS
+
+struct ns_filters {
+	struct list_head list;
+	struct nsinfo filter;
+};
+
+extern struct list_head ns_filters;
+
+static inline uint8_t prov_ns_whichOP(uint32_t utsns,
+																	uint32_t ipcns,
+																	uint32_t mntns,
+																	uint32_t pidns,
+																	uint32_t netns,
+																	uint32_t cgroupns)
+{
+	struct list_head *listentry, *listtmp;
+	struct ns_filters *tmp;
+
+	list_for_each_safe(listentry, listtmp, &ns_filters) {
+		tmp = list_entry(listentry, struct ns_filters, list);
+		if ( (tmp->filter.cgroupns == cgroupns || tmp->filter.cgroupns == IGNORE_NS)
+			&& (tmp->filter.utsns == utsns || tmp->filter.utsns == IGNORE_NS)
+			&& (tmp->filter.ipcns == ipcns || tmp->filter.ipcns == IGNORE_NS)
+			&& (tmp->filter.mntns == mntns || tmp->filter.mntns == IGNORE_NS)
+			&& (tmp->filter.pidns == pidns || tmp->filter.pidns == IGNORE_NS)
+			&& (tmp->filter.netns == netns || tmp->filter.netns == IGNORE_NS))
+			return tmp->filter.op;
+	}
+	return 0; // do nothing
+}
+
+static inline uint8_t prov_ns_delete(struct ns_filters *f)
+{
+	struct list_head *listentry, *listtmp;
+	struct ns_filters *tmp;
+
+	list_for_each_safe(listentry, listtmp, &ns_filters) {
+		tmp = list_entry(listentry, struct ns_filters, list);
+		if (tmp->filter.cgroupns == f->filter.cgroupns
+		  && tmp->filter.utsns == f->filter.utsns
+			&& tmp->filter.ipcns == f->filter.ipcns
+			&& tmp->filter.mntns == f->filter.mntns
+			&& tmp->filter.pidns == f->filter.pidns
+			&& tmp->filter.netns == f->filter.netns
+		) {
+			list_del(listentry);
+			kfree(tmp);
+			return 0; // you should only get one
+		}
+	}
+	return 0; // do nothing
+}
+
+static inline uint8_t prov_ns_add_or_update(struct ns_filters *f)
+{
+	struct list_head *listentry, *listtmp;
+	struct ns_filters *tmp;
+
+	list_for_each_safe(listentry, listtmp, &ns_filters) {
+		tmp = list_entry(listentry, struct ns_filters, list);
+		if (tmp->filter.cgroupns == f->filter.cgroupns
+		  && tmp->filter.utsns == f->filter.utsns
+			&& tmp->filter.ipcns == f->filter.ipcns
+			&& tmp->filter.mntns == f->filter.mntns
+			&& tmp->filter.pidns == f->filter.pidns
+			&& tmp->filter.netns == f->filter.netns
+		) {
+			tmp->filter.op = f->filter.op;
+			return 0; // you should only get one
+		}
+	}
+	list_add_tail(&(f->list), &ns_filters); // not already on the list, we add it
+	return 0;
+}
+#endif
diff -uprN -b -B ./pristine/linux-4.11.2/security/provenance/include/provenance_policy.h ./linux-4.11.2/security/provenance/include/provenance_policy.h
--- ./pristine/linux-4.11.2/security/provenance/include/provenance_policy.h	1970-01-01 01:00:00.000000000 +0100
+++ ./linux-4.11.2/security/provenance/include/provenance_policy.h	2017-05-22 10:47:47.574666483 +0100
@@ -0,0 +1,27 @@
+/*
+ *
+ * Author: Thomas Pasquier <tfjmp@seas.harvard.edu>
+ *
+ * Copyright (C) 2017 Harvard University
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2, as
+ * published by the Free Software Foundation; either version 2 of the License,
+ * or (at your option) any later version.
+ *
+ */
+#ifndef CONFIG_SECURITY_PROVENANCE_POLICY
+#define CONFIG_SECURITY_PROVENANCE_POLICY
+
+struct capture_policy {
+  bool prov_enabled;
+  bool prov_all;
+  uint64_t prov_node_filter;
+  uint64_t prov_propagate_node_filter;
+  uint64_t prov_relation_filter;
+  uint64_t prov_propagate_relation_filter;
+};
+
+extern struct capture_policy prov_policy;
+
+#endif
diff -uprN -b -B ./pristine/linux-4.11.2/security/provenance/include/provenance_query.h ./linux-4.11.2/security/provenance/include/provenance_query.h
--- ./pristine/linux-4.11.2/security/provenance/include/provenance_query.h	1970-01-01 01:00:00.000000000 +0100
+++ ./linux-4.11.2/security/provenance/include/provenance_query.h	2017-05-22 10:47:47.574666483 +0100
@@ -0,0 +1,71 @@
+/*
+ *
+ * Author: Thomas Pasquier <tfjmp@g.harvard.edu>
+ *
+ * Copyright (C) 2017 Harvard University
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2, as
+ * published by the Free Software Foundation; either version 2 of the License,
+ * or (at your option) any later version.
+ *
+ */
+#ifndef CONFIG_SECURITY_PROVENANCE_QUERY_H
+#define CONFIG_SECURITY_PROVENANCE_QUERY_H
+#include <linux/camflow_query.h>
+
+static inline int call_camflow_out_edge(prov_entry_t *node,
+					prov_entry_t *edge)
+{
+	int rc = 0;
+	struct list_head *listentry, *listtmp;
+	struct provenance_query_hooks *fcn;
+
+	list_for_each_safe(listentry, listtmp, &provenance_query_hooks) {
+		fcn = list_entry(listentry, struct provenance_query_hooks, list);
+		if (fcn->out_edge)
+			rc |= fcn->out_edge(node, edge);
+	}
+	return rc;
+}
+
+static inline int call_camflow_in_edge(prov_entry_t *edge,
+				       prov_entry_t *node)
+{
+	int rc = 0;
+	struct list_head *listentry, *listtmp;
+	struct provenance_query_hooks *fcn;
+
+	list_for_each_safe(listentry, listtmp, &provenance_query_hooks) {
+		fcn = list_entry(listentry, struct provenance_query_hooks, list);
+		if (fcn->in_edge)
+			rc |= fcn->in_edge(edge, node);
+	}
+	return rc;
+}
+
+static inline int call_query_hooks(prov_entry_t *from,
+				   prov_entry_t *to,
+				   prov_entry_t *edge)
+{
+	int rc = 0;
+
+	rc = call_camflow_out_edge(from, edge);
+	if ((rc & CAMFLOW_RAISE_WARNING) == CAMFLOW_RAISE_WARNING)
+		pr_warning("Provenance: warning raised.\n");
+	if ((rc & CAMFLOW_PREVENT_FLOW) == CAMFLOW_PREVENT_FLOW) {
+		pr_err("Provenance: error raised.\n");
+		edge->relation_info.allowed = FLOW_DISALLOWED;
+		return -EPERM;
+	}
+	rc = call_camflow_in_edge(edge, to);
+	if ((rc & CAMFLOW_RAISE_WARNING) == CAMFLOW_RAISE_WARNING)
+		pr_warning("Provenance: warning raised.\n");
+	if ((rc & CAMFLOW_PREVENT_FLOW) == CAMFLOW_PREVENT_FLOW) {
+		pr_err("Provenance: error raised.\n");
+		edge->relation_info.allowed = FLOW_DISALLOWED;
+		return -EPERM;
+	}
+	return 0;
+}
+#endif
diff -uprN -b -B ./pristine/linux-4.11.2/security/provenance/include/provenance_relay.h ./linux-4.11.2/security/provenance/include/provenance_relay.h
--- ./pristine/linux-4.11.2/security/provenance/include/provenance_relay.h	1970-01-01 01:00:00.000000000 +0100
+++ ./linux-4.11.2/security/provenance/include/provenance_relay.h	2017-05-22 10:47:47.576666500 +0100
@@ -0,0 +1,136 @@
+/*
+ *
+ * Author: Thomas Pasquier <tfjmp@seas.harvard.edu>
+ *
+ * Copyright (C) 2016 Harvard University
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2, as
+ * published by the Free Software Foundation; either version 2 of the License,
+ * or (at your option) any later version.
+ *
+ */
+#ifndef CONFIG_SECURITY_PROVENANCE_RELAY_H
+#define CONFIG_SECURITY_PROVENANCE_RELAY_H
+
+#include <linux/relay.h>
+#include <linux/spinlock.h>
+#include <linux/jiffies.h>
+
+#include "provenance_filter.h"
+#include "provenance_query.h"
+
+#define PROV_RELAY_BUFF_EXP         22 // 4MB
+#define PROV_RELAY_BUFF_SIZE        ((1 << PROV_RELAY_BUFF_EXP) * sizeof(uint8_t))
+#define PROV_NB_SUBBUF              32
+#define PROV_INITIAL_BUFF_SIZE      (1024 * 4)
+#define PROV_INITIAL_LONG_BUFF_SIZE 256
+
+extern bool relay_ready;
+
+struct prov_boot_buffer {
+	union prov_elt buffer[PROV_INITIAL_BUFF_SIZE];
+	uint32_t nb_entry;
+};
+
+struct prov_long_boot_buffer {
+	union long_prov_elt buffer[PROV_INITIAL_LONG_BUFF_SIZE];
+	uint32_t nb_entry;
+};
+
+extern struct prov_boot_buffer *boot_buffer;
+extern struct rchan *prov_chan;
+
+static inline void prov_write(union prov_elt *msg)
+{
+	prov_jiffies(msg) = get_jiffies_64();
+	if (unlikely(!relay_ready)) {
+		if (likely(boot_buffer->nb_entry < PROV_INITIAL_BUFF_SIZE)) {
+			memcpy(&(boot_buffer->buffer[boot_buffer->nb_entry]), msg, sizeof(union prov_elt));
+			boot_buffer->nb_entry++;
+		} else
+			pr_err("Provenance: boot buffer is full.\n");
+	} else
+		relay_write(prov_chan, msg, sizeof(union prov_elt));
+}
+
+
+extern struct prov_long_boot_buffer *long_boot_buffer;
+extern struct rchan *long_prov_chan;
+
+static inline void long_prov_write(union long_prov_elt *msg)
+{
+	prov_jiffies(msg) = get_jiffies_64();
+	if (unlikely(!relay_ready)) {
+		if (likely(long_boot_buffer->nb_entry < PROV_INITIAL_LONG_BUFF_SIZE))
+			memcpy(&(long_boot_buffer->buffer[long_boot_buffer->nb_entry++]), msg, sizeof(union long_prov_elt));
+		else
+			pr_err("Provenance: long boot buffer is full.\n");
+	} else
+		relay_write(long_prov_chan, msg, sizeof(union long_prov_elt));
+}
+
+/* force sub-buffer switch */
+static inline void prov_flush(void)
+{
+	relay_flush(prov_chan);
+	relay_flush(long_prov_chan);
+}
+
+extern atomic64_t prov_relation_id;
+extern atomic64_t prov_node_id;
+extern uint32_t prov_machine_id;
+extern uint32_t prov_boot_id;
+
+#define prov_next_relation_id() ((uint64_t)atomic64_inc_return(&prov_relation_id))
+#define prov_next_node_id() ((uint64_t)atomic64_inc_return(&prov_node_id))
+
+static inline void write_node(union prov_elt *node)
+{
+	if (filter_node((prov_entry_t *)node) || provenance_is_recorded(node))  // filtered or already recorded
+		return;
+	set_recorded(node);
+	if (unlikely(node_identifier(node).machine_id != prov_machine_id))
+		node_identifier(node).machine_id = prov_machine_id;
+	prov_write(node);
+}
+
+static inline void write_long_node(union long_prov_elt *node)
+{
+	if (provenance_is_recorded(node))
+		return;
+	set_recorded(node);
+	long_prov_write(node);
+}
+
+static inline void copy_identifier(union prov_identifier *dest, union prov_identifier *src)
+{
+	memcpy(dest, src, sizeof(union prov_identifier));
+}
+
+static inline int write_relation(uint64_t type,
+				      void *from,
+				      void *to,
+				      struct file *file)
+{
+	union prov_elt relation;
+	prov_entry_t *f = from;
+	prov_entry_t *t = to;
+	int rc = 0;
+
+	memset(&relation, 0, sizeof(union prov_elt));
+	prov_type(&relation) = type;
+	relation_identifier(&relation).id = prov_next_relation_id();
+	relation_identifier(&relation).boot_id = prov_boot_id;
+	relation_identifier(&relation).machine_id = prov_machine_id;
+	copy_identifier(&relation.relation_info.snd, &get_prov_identifier(f));
+	copy_identifier(&relation.relation_info.rcv, &get_prov_identifier(t));
+	if (file) {
+		relation.relation_info.set = FILE_INFO_SET;
+		relation.relation_info.offset = file->f_pos;
+	}
+	rc = call_query_hooks(f, t, (prov_entry_t *)&relation);
+	prov_write(&relation);
+	return rc;
+}
+#endif
diff -uprN -b -B ./pristine/linux-4.11.2/security/provenance/include/provenance_secctx.h ./linux-4.11.2/security/provenance/include/provenance_secctx.h
--- ./pristine/linux-4.11.2/security/provenance/include/provenance_secctx.h	1970-01-01 01:00:00.000000000 +0100
+++ ./linux-4.11.2/security/provenance/include/provenance_secctx.h	2017-05-22 10:47:47.587666594 +0100
@@ -0,0 +1,67 @@
+/*
+ *
+ * Author: Thomas Pasquier <tfjmp@seas.harvard.edu>
+ *
+ * Copyright (C) 2016 Harvard University
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2, as
+ * published by the Free Software Foundation; either version 2 of the License,
+ * or (at your option) any later version.
+ *
+ */
+#ifndef CONFIG_SECURITY_PROVENANCE_SECCTX
+#define CONFIG_SECURITY_PROVENANCE_SECCTX
+
+struct secctx_filters {
+	struct list_head list;
+	struct secinfo filter;
+};
+
+extern struct list_head secctx_filters;
+
+static inline uint8_t prov_secctx_whichOP(uint32_t secid)
+{
+	struct list_head *listentry, *listtmp;
+	struct secctx_filters *tmp;
+
+	list_for_each_safe(listentry, listtmp, &secctx_filters) {
+		tmp = list_entry(listentry, struct secctx_filters, list);
+		if (tmp->filter.secid == secid)
+			return tmp->filter.op;
+	}
+	return 0; // do nothing
+}
+
+static inline uint8_t prov_secctx_delete(struct secctx_filters  *f)
+{
+	struct list_head *listentry, *listtmp;
+	struct secctx_filters *tmp;
+
+	list_for_each_safe(listentry, listtmp, &secctx_filters) {
+		tmp = list_entry(listentry, struct secctx_filters, list);
+		if (tmp->filter.secid == f->filter.secid) {
+			list_del(listentry);
+			kfree(tmp);
+			return 0; // you should only get one
+		}
+	}
+	return 0; // do nothing
+}
+
+static inline uint8_t prov_secctx_add_or_update(struct secctx_filters *f)
+{
+	struct list_head *listentry, *listtmp;
+	struct secctx_filters *tmp;
+
+	list_for_each_safe(listentry, listtmp, &secctx_filters) {
+		tmp = list_entry(listentry, struct secctx_filters, list);
+		if (tmp->filter.secid == f->filter.secid) {
+			tmp->filter.op = f->filter.op;
+			return 0; // you should only get one
+		}
+	}
+	list_add_tail(&(f->list), &secctx_filters); // not already on the list, we add it
+	return 0;
+}
+#endif
diff -uprN -b -B ./pristine/linux-4.11.2/security/provenance/include/provenance_task.h ./linux-4.11.2/security/provenance/include/provenance_task.h
--- ./pristine/linux-4.11.2/security/provenance/include/provenance_task.h	1970-01-01 01:00:00.000000000 +0100
+++ ./linux-4.11.2/security/provenance/include/provenance_task.h	2017-05-22 10:47:47.574666483 +0100
@@ -0,0 +1,280 @@
+/*
+ *
+ * Author: Thomas Pasquier <tfjmp@seas.harvard.edu>
+ *
+ * Copyright (C) 2016 Harvard University
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2, as
+ * published by the Free Software Foundation; either version 2 of the License,
+ * or (at your option) any later version.
+ *
+ */
+#ifndef CONFIG_SECURITY_PROVENANCE_TASK
+#define CONFIG_SECURITY_PROVENANCE_TASK
+
+#include <linux/cred.h>
+#include <linux/binfmts.h>
+#include <linux/sched.h>
+#include <linux/sched/task.h>
+#include <linux/sched/mm.h>
+#include <linux/utsname.h>
+#include <linux/ipc_namespace.h>
+#include <linux/mnt_namespace.h>
+#include <net/net_namespace.h>
+#include <linux/pid_namespace.h>
+#include "../../../fs/mount.h" // nasty
+
+#include "provenance_inode.h"
+#include "provenance_policy.h"
+
+#define current_pid() (current->pid)
+static inline uint32_t current_cgroupns(void)
+{
+	uint32_t id = 0;
+	struct cgroup_namespace *cns;
+
+	task_lock(current);
+	if (current->nsproxy) {
+		cns = current->nsproxy->cgroup_ns;
+		if (cns) {
+			get_cgroup_ns(cns);
+			id = cns->ns.inum;
+			put_cgroup_ns(cns);
+		}
+	}
+	task_unlock(current);
+	return id;
+}
+
+static inline uint32_t current_utsns(void)
+{
+	uint32_t id = 0;
+	struct uts_namespace *ns;
+
+	task_lock(current);
+	if (current->nsproxy) {
+		ns = current->nsproxy->uts_ns;
+		if (ns) {
+			get_uts_ns(ns);
+			id = ns->ns.inum;
+			put_uts_ns(ns);
+		}
+	}
+	task_unlock(current);
+	return id;
+}
+
+static inline uint32_t current_ipcns(void)
+{
+	uint32_t id = 0;
+	struct ipc_namespace *ns;
+
+	task_lock(current);
+	if (current->nsproxy) {
+		ns = current->nsproxy->ipc_ns;
+		if (ns) {
+			get_ipc_ns(ns);
+			id = ns->ns.inum;
+			put_ipc_ns(ns);
+		}
+	}
+	task_unlock(current);
+	return id;
+}
+
+static inline uint32_t current_mntns(void)
+{
+	uint32_t id = 0;
+	struct mnt_namespace *ns;
+
+	task_lock(current);
+	if (current->nsproxy) {
+		ns = current->nsproxy->mnt_ns;
+		if (ns) {
+			get_mnt_ns(ns);
+			id = ns->ns.inum;
+			put_mnt_ns(ns);
+		}
+	}
+	task_unlock(current);
+	return id;
+}
+
+static inline uint32_t current_netns(void)
+{
+	uint32_t id = 0;
+	struct net *ns;
+
+	task_lock(current);
+	if (current->nsproxy) {
+		ns = current->nsproxy->net_ns;
+		if (ns) {
+			get_net(ns);
+			id = ns->ns.inum;
+			put_net(ns);
+		}
+	}
+	task_unlock(current);
+	return id;
+}
+
+static inline uint32_t current_pidns(void)
+{
+	uint32_t id = 0;
+	struct pid_namespace *ns;
+
+	task_lock(current);
+	ns = task_active_pid_ns(current);
+	if (ns) {
+		id = ns->ns.inum;
+		put_pid_ns(ns);
+	}
+	task_unlock(current);
+	return id;
+}
+
+#define vm_write(flags)   ((flags & VM_WRITE) == VM_WRITE)
+#define vm_read(flags)    ((flags & VM_READ) == VM_READ)
+#define vm_exec(flags)    ((flags & VM_EXEC) == VM_EXEC)
+#define vm_mayshare(flags) ((flags & (VM_SHARED | VM_MAYSHARE)) != 0)
+#define vm_write_mayshare(flags) (vm_write(flags) && vm_mayshare(flags))
+#define vm_read_exec_mayshare(flags) ((vm_write(flags) || vm_exec(flags)) && vm_mayshare(flags))
+
+
+static inline void current_update_shst(struct provenance *cprov)
+{
+	struct mm_struct *mm = get_task_mm(current);
+	struct vm_area_struct *vma;
+	struct file *mmapf;
+	vm_flags_t flags;
+	struct provenance *mmprov;
+
+	if (!mm)
+		return;
+	cprov->has_mmap = 0;
+	vma = mm->mmap;
+	while (vma) { // we go through mmaped files
+		mmapf = vma->vm_file;
+		if (mmapf) {
+			flags = vma->vm_flags;
+			mmprov = file_inode(mmapf)->i_provenance;
+			if (mmprov) {
+				cprov->has_mmap = 1;
+				spin_lock_nested(prov_lock(mmprov), PROVENANCE_LOCK_INODE);
+				if (vm_read_exec_mayshare(flags))
+					record_relation(RL_SH_READ, mmprov, cprov, NULL);
+				if (vm_write_mayshare(flags))
+					record_relation(RL_SH_WRITE, cprov, mmprov, NULL);
+				spin_unlock(prov_lock(mmprov));
+			}
+		}
+		vma = vma->vm_next;
+	}
+	mmput_async(mm);
+}
+
+static inline int record_task_name(struct task_struct *task, struct provenance *prov)
+{
+	const struct cred *cred;
+	struct provenance *fprov;
+	struct mm_struct *mm;
+	struct file *exe_file;
+	char *buffer;
+	char *ptr;
+	int rc = 0;
+
+	if (provenance_is_name_recorded(prov_elt(prov)) ||
+	    !provenance_is_recorded(prov_elt(prov)))
+		return 0;
+	cred = get_task_cred(task);
+	if (!cred)
+		return rc;
+	mm = get_task_mm(task);
+	if (!mm)
+		goto out;
+	exe_file = get_mm_exe_file(mm);
+	mmput_async(mm);
+	if (exe_file) {
+		fprov = file_inode(exe_file)->i_provenance;
+		if (provenance_is_opaque(prov_elt(fprov))) {
+			set_opaque(prov_elt(prov));
+			goto out;
+		}
+		// should not sleep
+		buffer = kcalloc(PATH_MAX, sizeof(char), GFP_ATOMIC);
+		if (!buffer) {
+			pr_err("Provenance: could not allocate memory\n");
+			fput(exe_file);
+			goto out;
+		}
+		ptr = file_path(exe_file, buffer, PATH_MAX);
+		fput(exe_file);
+		rc = record_node_name(prov, ptr);
+		kfree(buffer);
+	}
+out:
+	put_cred(cred);
+	return rc;
+}
+
+static inline void refresh_current_provenance(void)
+{
+	struct provenance *prov = current_provenance();
+	unsigned long irqflags;
+
+	// will not be recorded
+	if (provenance_is_opaque(prov_elt(prov)))
+		return;
+	record_task_name(current, prov);
+	spin_lock_irqsave_nested(prov_lock(prov), irqflags, PROVENANCE_LOCK_TASK);
+	if (unlikely(prov_elt(prov)->task_info.pid == 0))
+		prov_elt(prov)->task_info.pid = task_pid_nr(current);
+	if (unlikely(prov_elt(prov)->task_info.vpid == 0))
+		prov_elt(prov)->task_info.vpid = task_pid_vnr(current);
+	prov_elt(prov)->task_info.utsns = current_utsns();
+	prov_elt(prov)->task_info.ipcns = current_ipcns();
+	prov_elt(prov)->task_info.mntns = current_mntns();
+	prov_elt(prov)->task_info.pidns = current_pidns();
+	prov_elt(prov)->task_info.netns = current_netns();
+	prov_elt(prov)->task_info.cgroupns = current_cgroupns();
+	security_task_getsecid(current, &(prov_elt(prov)->task_info.secid));
+	if (prov->updt_mmap && prov->has_mmap) {
+		current_update_shst(prov);
+		prov->updt_mmap = 0;
+	}
+	spin_unlock_irqrestore(prov_lock(prov), irqflags);
+}
+
+static inline struct provenance *prov_from_vpid(pid_t pid)
+{
+	struct provenance *tprov;
+	struct task_struct *dest = find_task_by_vpid(pid);
+
+	if (!dest)
+		return NULL;
+
+	tprov = __task_cred(dest)->provenance;
+	if (!tprov)
+		return NULL;
+	return tprov;
+}
+
+static inline int terminate_task(struct provenance *tprov)
+{
+	union prov_elt old_prov;
+	int rc;
+	if (!provenance_is_tracked(prov_elt(tprov)) && !prov_policy.prov_all)
+		return 0;
+	if (filter_node(prov_entry(tprov)))
+		return 0;
+	memcpy(&old_prov, prov_elt(tprov), sizeof(union prov_elt));
+	node_identifier(prov_elt(tprov)).version++;
+	clear_recorded(prov_elt(tprov));
+	write_node(&old_prov);
+	write_node(prov_elt(tprov));
+	rc = write_relation(RL_TERMINATE_PROCESS, &old_prov, prov_elt(tprov), NULL);
+	tprov->has_outgoing = false;
+	return rc;
+}
+#endif
diff -uprN -b -B ./pristine/linux-4.11.2/security/provenance/Kconfig ./linux-4.11.2/security/provenance/Kconfig
--- ./pristine/linux-4.11.2/security/provenance/Kconfig	1970-01-01 01:00:00.000000000 +0100
+++ ./linux-4.11.2/security/provenance/Kconfig	2017-05-22 10:47:47.560666363 +0100
@@ -0,0 +1,29 @@
+config SECURITY_PROVENANCE
+         bool "CamFlow - Provenance"
+         depends on SECURITY
+         select RELAY
+         select SECURITYFS
+         select NETFILTER
+         select CRYPTO_SHA256
+         default y
+         help
+          This selects CamFlow provenance modules. It captures provenance through
+          a Linux Security Module.
+
+config SECURITY_PROVENANCE_WHOLE_SYSTEM
+	bool "CamFlow - Whole system provenance"
+	depends on SECURITY_PROVENANCE
+	default n
+	help
+	  This option activate whole system provenance capture from boot.
+
+	  If you are unsure how to answer this question, answer N.
+
+config SECURITY_PROVENANCE_PERSISTENCE
+	bool "CamFlow - Persistence"
+	depends on SECURITY_PROVENANCE
+	default n
+	help
+	  This option persist inode provenance state across reboot.
+
+	  If you are unsure how to answer this question, answer N.
diff -uprN -b -B ./pristine/linux-4.11.2/security/provenance/Makefile ./linux-4.11.2/security/provenance/Makefile
--- ./pristine/linux-4.11.2/security/provenance/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ ./linux-4.11.2/security/provenance/Makefile	2017-05-22 10:47:47.572666466 +0100
@@ -0,0 +1,8 @@
+#
+# Makefile for Provenance LSM
+#
+obj-$(CONFIG_SECURITY_PROVENANCE) := provenance.o
+
+provenance-y := relay.o hooks.o query.o fs.o netfilter.o propagate.o
+
+ccflags-y := -I$(srctree)/security/provenance/include
diff -uprN -b -B ./pristine/linux-4.11.2/security/provenance/netfilter.c ./linux-4.11.2/security/provenance/netfilter.c
--- ./pristine/linux-4.11.2/security/provenance/netfilter.c	1970-01-01 01:00:00.000000000 +0100
+++ ./linux-4.11.2/security/provenance/netfilter.c	2017-05-22 10:47:47.561666371 +0100
@@ -0,0 +1,70 @@
+/*
+ *
+ * Author: Thomas Pasquier <tfjmp@seas.harvard.edu>
+ *
+ * Copyright (C) 2016 Havard University
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2, as
+ * published by the Free Software Foundation; either version 2 of the License,
+ * or (at your option) any later version.
+ *
+ */
+#include "provenance.h"
+#include "provenance_net.h"
+#include "provenance_task.h"
+
+static inline unsigned int __ipv4_out(struct sk_buff *skb)
+{
+	struct provenance *cprov = current_provenance();
+	struct provenance *iprov = NULL;
+	union prov_elt pckprov;
+	unsigned long irqflags;
+
+	if (!cprov)
+		return NF_ACCEPT;
+
+	if (provenance_is_tracked(prov_elt(cprov))) {
+		iprov = sk_inode_provenance(skb->sk);
+		if (!iprov)
+			return NF_ACCEPT;
+		provenance_parse_skb_ipv4(skb, &pckprov);
+		spin_lock_irqsave_nested(prov_lock(cprov), irqflags, PROVENANCE_LOCK_TASK);
+		spin_lock_nested(prov_lock(iprov), PROVENANCE_LOCK_INODE);
+		record_inode_to_pck(iprov, &pckprov);
+		if (provenance_records_packet(prov_elt(iprov)))
+			record_packet_content(&pckprov, skb);
+		spin_unlock(prov_lock(iprov));
+		spin_unlock_irqrestore(prov_lock(cprov), irqflags);
+	}
+	return NF_ACCEPT;
+}
+
+static unsigned int provenance_ipv4_out(void *priv,
+					struct sk_buff *skb,
+					const struct nf_hook_state *state)
+{
+	return __ipv4_out(skb);
+}
+
+static struct nf_hook_ops provenance_nf_ops[] = {
+	{
+		.hook = provenance_ipv4_out,
+		.pf = NFPROTO_IPV4,
+		.hooknum = NF_INET_LOCAL_OUT,
+		.priority = NF_IP_PRI_LAST,
+	},
+};
+
+// will initialise the hooks
+static int __init provenance_nf_init(void)
+{
+	int err;
+
+	err = nf_register_hooks(provenance_nf_ops, ARRAY_SIZE(provenance_nf_ops));
+	if (err)
+		panic("Provenance: nf_register_hooks: error %d\n", err);
+	pr_info("Provenance: netfilter ready.\n");
+	return 0;
+}
+subsys_initcall(provenance_nf_init);
diff -uprN -b -B ./pristine/linux-4.11.2/security/provenance/propagate.c ./linux-4.11.2/security/provenance/propagate.c
--- ./pristine/linux-4.11.2/security/provenance/propagate.c	1970-01-01 01:00:00.000000000 +0100
+++ ./linux-4.11.2/security/provenance/propagate.c	2017-05-22 10:47:47.562666380 +0100
@@ -0,0 +1,50 @@
+/*
+ *
+ * Author: Thomas Pasquier <tfjmp@g.harvard.edu>
+ *
+ * Copyright (C) 2017 Harvard University
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2, as
+ * published by the Free Software Foundation; either version 2 of the License,
+ * or (at your option) any later version.
+ *
+ */
+#include "provenance.h"
+
+static int out_edge(prov_entry_t *node, prov_entry_t *edge)
+{
+	if (provenance_does_propagate(node) && provenance_is_tracked(node)) {
+		// can propagate over edge?
+		if (!filter_propagate_relation(prov_type(edge))) {
+			set_tracked(edge);
+			set_propagate(edge);
+		}
+	}
+	return 0;
+}
+
+static int in_edge(prov_entry_t *edge, prov_entry_t *node)
+{
+	if (provenance_does_propagate(edge) && provenance_is_tracked(edge)) {
+		// can propagate to node?
+		if (!filter_propagate_node(node)) {
+			set_tracked(node);
+			set_propagate(node);
+		}
+	}
+	return 0;
+}
+
+struct provenance_query_hooks hooks = {
+	QUERY_HOOK_INIT(out_edge, out_edge),
+	QUERY_HOOK_INIT(in_edge,  in_edge),
+};
+
+static int __init init_prov_propagate(void)
+{
+	register_camflow_query_hook(&hooks);
+	pr_info("Provenance: propagate ready.\n");
+	return 0;
+}
+security_initcall(init_prov_propagate);
diff -uprN -b -B ./pristine/linux-4.11.2/security/provenance/query.c ./linux-4.11.2/security/provenance/query.c
--- ./pristine/linux-4.11.2/security/provenance/query.c	1970-01-01 01:00:00.000000000 +0100
+++ ./linux-4.11.2/security/provenance/query.c	2017-05-22 10:47:47.587666594 +0100
@@ -0,0 +1,32 @@
+/*
+ *
+ * Author: Thomas Pasquier <tfjmp@g.harvard.edu>
+ *
+ * Copyright (C) 2017 Harvard University
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2, as
+ * published by the Free Software Foundation; either version 2 of the License,
+ * or (at your option) any later version.
+ *
+ */
+#include <linux/rculist.h>
+
+#include "provenance_query.h"
+
+int register_camflow_query_hook(struct provenance_query_hooks *hook)
+{
+	if (!hook)
+		return -ENOMEM;
+	pr_info("Provenance: registering policy hook...\n");
+	list_add_tail_rcu(&(hook->list), &provenance_query_hooks);
+	return 0;
+}
+EXPORT_SYMBOL_GPL(register_camflow_query_hook);
+
+int unregister_camflow_query_hook(struct provenance_query_hooks *hook)
+{
+	list_del_rcu(&(hook->list));
+	return 0;
+}
+EXPORT_SYMBOL_GPL(unregister_camflow_query_hook);
diff -uprN -b -B ./pristine/linux-4.11.2/security/provenance/relay.c ./linux-4.11.2/security/provenance/relay.c
--- ./pristine/linux-4.11.2/security/provenance/relay.c	1970-01-01 01:00:00.000000000 +0100
+++ ./linux-4.11.2/security/provenance/relay.c	2017-05-22 10:47:47.588666602 +0100
@@ -0,0 +1,90 @@
+/*
+ *
+ * Author: Thomas Pasquier <thomas.pasquier@cl.cam.ac.uk>
+ *
+ * Copyright (C) 2015 University of Cambridge
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2, as
+ * published by the Free Software Foundation; either version 2 of the License,
+ * or (at your option) any later version.
+ *
+ */
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/debugfs.h>
+
+#include "provenance.h"
+
+#define PROV_BASE_NAME "provenance"
+#define LONG_PROV_BASE_NAME "long_provenance"
+
+/* global variable, extern in provenance.h */
+struct rchan *prov_chan;
+struct rchan *long_prov_chan;
+atomic64_t prov_relation_id = ATOMIC64_INIT(0);
+atomic64_t prov_node_id = ATOMIC64_INIT(0);
+
+/*
+ * create_buf_file() callback.  Creates relay file in debugfs.
+ */
+static struct dentry *create_buf_file_handler(const char *filename,
+					      struct dentry *parent,
+					      umode_t mode,
+					      struct rchan_buf *buf,
+					      int *is_global)
+{
+	return debugfs_create_file(filename, mode, parent, buf,
+				   &relay_file_operations);
+}
+
+/*
+ * remove_buf_file() callback.  Removes relay file from debugfs.
+ */
+static int remove_buf_file_handler(struct dentry *dentry)
+{
+	debugfs_remove(dentry);
+	return 0;
+}
+
+/*
+ * relay interface callbacks
+ */
+static struct rchan_callbacks relay_callbacks = {
+
+	.create_buf_file	= create_buf_file_handler,
+	.remove_buf_file	= remove_buf_file_handler,
+};
+
+static void write_boot_buffer(void)
+{
+	if (boot_buffer->nb_entry > 0)
+		relay_write(prov_chan, boot_buffer->buffer, boot_buffer->nb_entry * sizeof(union prov_elt));
+	kfree(boot_buffer);
+	boot_buffer = NULL;
+
+	if (long_boot_buffer->nb_entry > 0)
+		relay_write(long_prov_chan, long_boot_buffer->buffer, long_boot_buffer->nb_entry * sizeof(union long_prov_elt));
+	kfree(long_boot_buffer);
+	long_boot_buffer = NULL;
+}
+
+bool relay_ready;
+extern struct workqueue_struct *prov_queue;
+
+static int __init relay_prov_init(void)
+{
+	prov_chan = relay_open(PROV_BASE_NAME, NULL, PROV_RELAY_BUFF_SIZE, PROV_NB_SUBBUF, &relay_callbacks, NULL);
+	if (!prov_chan)
+		panic("Provenance: relay_open failure\n");
+
+	long_prov_chan = relay_open(LONG_PROV_BASE_NAME, NULL, PROV_RELAY_BUFF_SIZE, PROV_NB_SUBBUF, &relay_callbacks, NULL);
+	if (!long_prov_chan)
+		panic("Provenance: relay_open failure\n");
+	relay_ready = true;
+	// relay buffer are ready, we can write down the boot buffer
+	write_boot_buffer();
+	pr_info("Provenance: relay ready.\n");
+	return 0;
+}
+core_initcall(relay_prov_init);
diff -uprN -b -B ./pristine/linux-4.11.2/security/security.c ./linux-4.11.2/security/security.c
--- ./pristine/linux-4.11.2/security/security.c	2017-05-20 13:50:04.000000000 +0100
+++ ./linux-4.11.2/security/security.c	2017-05-22 10:47:47.542666209 +0100
@@ -20,6 +20,7 @@
 #include <linux/integrity.h>
 #include <linux/ima.h>
 #include <linux/evm.h>
+#include <linux/camflow.h>
 #include <linux/fsnotify.h>
 #include <linux/mman.h>
 #include <linux/mount.h>
@@ -68,6 +69,10 @@ int __init security_init(void)
 	 */
 	do_security_initcalls();
 
+	/*
+	* Provenance is the last module to be loaded
+	*/
+	provenance_add_hooks();
 	return 0;
 }
