diff -uprN ./pristine/linux-4.4.25/include/linux/camflow.h ./linux-4.4.25/include/linux/camflow.h
--- ./pristine/linux-4.4.25/include/linux/camflow.h	1969-12-31 16:00:00.000000000 -0800
+++ ./linux-4.4.25/include/linux/camflow.h	2016-10-19 03:14:47.588690477 -0700
@@ -0,0 +1,83 @@
+/*
+*
+* Author: Thomas Pasquier <thomas.pasquier@cl.cam.ac.uk>
+*
+* Copyright (C) 2016 University of Cambridge
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License version 2, as
+* published by the Free Software Foundation; either version 2 of the License, or
+*	(at your option) any later version.
+*
+*/
+
+#ifndef _LINUX_CAMFLOW_HEAD_H
+#define _LINUX_CAMFLOW_HEAD_H
+
+#include <linux/security.h>
+#include <linux/fs.h>
+
+#include <uapi/linux/provenance.h>
+#include <uapi/linux/ifc.h>
+
+// cause softlockup if both pointer directly added to inode
+// no time to figure out why, work around
+struct camflow_i_ptr{
+  void* provenance;
+  void* ifc;
+};
+
+extern struct kmem_cache *camflow_cache;
+
+static inline void alloc_camflow(struct inode *inode, gfp_t priority){
+  if(!inode->i_camflow){ // if not already set
+    inode->i_camflow = kmem_cache_zalloc(camflow_cache, priority);
+  }
+}
+
+static inline prov_msg_t* __raw_inode_provenance(const struct inode *inode){
+  if(inode->i_camflow == NULL){
+    return NULL;
+  }
+  return ((prov_msg_t*)((struct camflow_i_ptr*)inode->i_camflow)->provenance);
+}
+
+static inline void inode_set_provenance(struct inode *inode, prov_msg_t *v){
+  if(inode->i_camflow == NULL){
+    return;
+  }
+  ((struct camflow_i_ptr*)inode->i_camflow)->provenance=v;
+}
+
+
+static inline struct ifc_struct* inode_get_ifc(const struct inode *inode){
+  if(inode->i_camflow == NULL){
+    return NULL;
+  }
+  return ((struct ifc_struct*)((struct camflow_i_ptr*)inode->i_camflow)->ifc);
+}
+
+static inline void inode_set_ifc(struct inode *inode, struct ifc_struct *v){
+  if(inode->i_camflow == NULL){
+    return;
+  }
+  ((struct camflow_i_ptr*)inode->i_camflow)->ifc=v;
+}
+
+// free only if both ptr have been freed
+static inline void free_camflow(struct inode *inode){
+  struct camflow_i_ptr* camflow;
+  if(!inode->i_camflow){
+    camflow = inode->i_camflow;
+    if(camflow->provenance==NULL&&camflow->ifc==NULL){ // nothing left in the structure
+      kmem_cache_free(camflow_cache, camflow);
+      inode->i_camflow = NULL;
+    }
+  }
+}
+
+int provenance_inode_init_security(struct inode *inode, struct inode *dir,
+				       const struct qstr *qstr,
+				       const char **name,
+				       void **value, size_t *len);
+#endif
diff -uprN ./pristine/linux-4.4.25/include/linux/cred.h ./linux-4.4.25/include/linux/cred.h
--- ./pristine/linux-4.4.25/include/linux/cred.h	2016-10-16 08:48:03.000000000 -0700
+++ ./linux-4.4.25/include/linux/cred.h	2016-10-19 03:14:47.588690477 -0700
@@ -149,6 +149,12 @@ struct cred {
 #ifdef CONFIG_SECURITY
 	void		*security;	/* subjective LSM security */
 #endif
+#ifdef CONFIG_SECURITY_PROVENANCE
+	void 		*provenance; /* subjective LSM provenance */
+#endif
+#ifdef CONFIG_SECURITY_IFC
+	void 		*ifc; /* subjective LSM ifc */
+#endif
 	struct user_struct *user;	/* real user ID subscription */
 	struct user_namespace *user_ns; /* user_ns the caps and keyrings are relative to. */
 	struct group_info *group_info;	/* supplementary groups for euid/fsgid */
@@ -372,6 +378,8 @@ static inline void put_cred(const struct
 #define current_cap()		(current_cred_xxx(cap_effective))
 #define current_user()		(current_cred_xxx(user))
 #define current_security()	(current_cred_xxx(security))
+#define current_provenance()	(current_cred_xxx(provenance))
+#define current_ifc()	(current_cred_xxx(ifc))
 
 extern struct user_namespace init_user_ns;
 #ifdef CONFIG_USER_NS
diff -uprN ./pristine/linux-4.4.25/include/linux/fs.h ./linux-4.4.25/include/linux/fs.h
--- ./pristine/linux-4.4.25/include/linux/fs.h	2016-10-16 08:48:03.000000000 -0700
+++ ./linux-4.4.25/include/linux/fs.h	2016-10-19 03:14:47.588690477 -0700
@@ -272,7 +272,7 @@ struct iattr {
  */
 #define FILESYSTEM_MAX_STACK_DEPTH 2
 
-/** 
+/**
  * enum positive_aop_returns - aop return codes with specific semantics
  *
  * @AOP_WRITEPAGE_ACTIVATE: Informs the caller that page writeback has
@@ -282,7 +282,7 @@ struct iattr {
  * 			    be a candidate for writeback again in the near
  * 			    future.  Other callers must be careful to unlock
  * 			    the page if they get this return.  Returned by
- * 			    writepage(); 
+ * 			    writepage();
  *
  * @AOP_TRUNCATED_PAGE: The AOP method that was handed a locked page has
  *  			unlocked it and the page might have been truncated.
@@ -599,6 +599,7 @@ struct inode {
 
 #ifdef CONFIG_SECURITY
 	void			*i_security;
+	void 			*i_camflow;
 #endif
 
 	/* Stat data, not accessed from path walking */
@@ -917,10 +918,10 @@ static inline struct file *get_file(stru
 
 #define	MAX_NON_LFS	((1UL<<31) - 1)
 
-/* Page cache limit. The filesystems should put that into their s_maxbytes 
-   limits, otherwise bad things can happen in VM. */ 
+/* Page cache limit. The filesystems should put that into their s_maxbytes
+   limits, otherwise bad things can happen in VM. */
 #if BITS_PER_LONG==32
-#define MAX_LFS_FILESIZE	(((loff_t)PAGE_CACHE_SIZE << (BITS_PER_LONG-1))-1) 
+#define MAX_LFS_FILESIZE	(((loff_t)PAGE_CACHE_SIZE << (BITS_PER_LONG-1))-1)
 #elif BITS_PER_LONG==64
 #define MAX_LFS_FILESIZE 	((loff_t)0x7fffffffffffffffLL)
 #endif
@@ -1329,6 +1330,9 @@ struct super_block {
 #ifdef CONFIG_SECURITY
 	void                    *s_security;
 #endif
+#ifdef CONFIG_SECURITY_PROVENANCE
+	void										*s_provenance;
+#endif
 	const struct xattr_handler **s_xattr;
 
 	struct hlist_bl_head	s_anon;		/* anonymous dentries for (nfs) exporting */
@@ -1957,7 +1961,7 @@ int sync_inode_metadata(struct inode *in
 struct file_system_type {
 	const char *name;
 	int fs_flags;
-#define FS_REQUIRES_DEV		1 
+#define FS_REQUIRES_DEV		1
 #define FS_BINARY_MOUNTDATA	2
 #define FS_HAS_SUBTYPE		4
 #define FS_USERNS_MOUNT		8	/* Can be mounted by userns root */
@@ -2565,7 +2569,7 @@ extern int kernel_read(struct file *, lo
 extern ssize_t kernel_write(struct file *, const char *, size_t, loff_t);
 extern ssize_t __kernel_write(struct file *, const char *, size_t, loff_t *);
 extern struct file * open_exec(const char *);
- 
+
 /* fs/dcache.c -- generic fs support functions */
 extern int is_subdir(struct dentry *, struct dentry *);
 extern int path_is_under(struct path *, struct path *);
diff -uprN ./pristine/linux-4.4.25/include/linux/ipc.h ./linux-4.4.25/include/linux/ipc.h
--- ./pristine/linux-4.4.25/include/linux/ipc.h	2016-10-16 08:48:03.000000000 -0700
+++ ./linux-4.4.25/include/linux/ipc.h	2016-10-19 03:14:47.589690486 -0700
@@ -18,9 +18,15 @@ struct kern_ipc_perm
 	kgid_t		gid;
 	kuid_t		cuid;
 	kgid_t		cgid;
-	umode_t		mode; 
+	umode_t		mode;
 	unsigned long	seq;
 	void		*security;
+#ifdef CONFIG_SECURITY_PROVENANCE
+	void		*provenance;
+#endif
+#ifdef CONFIG_SECURITY_IFC
+	void		*ifc;
+#endif
 };
 
 #endif /* _LINUX_IPC_H */
diff -uprN ./pristine/linux-4.4.25/include/linux/lsm_hooks.h ./linux-4.4.25/include/linux/lsm_hooks.h
--- ./pristine/linux-4.4.25/include/linux/lsm_hooks.h	2016-10-16 08:48:03.000000000 -0700
+++ ./linux-4.4.25/include/linux/lsm_hooks.h	2016-10-19 03:14:47.589690486 -0700
@@ -1887,4 +1887,16 @@ extern void __init yama_add_hooks(void);
 static inline void __init yama_add_hooks(void) { }
 #endif
 
+#ifdef CONFIG_SECURITY_PROVENANCE
+extern void __init provenance_add_hooks(void);
+#else
+static inline void __init provenance_add_hooks(void) { }
+#endif
+
+#ifdef CONFIG_SECURITY_IFC
+extern void __init ifc_add_hooks(void);
+#else
+static inline void __init ifc_add_hooks(void) { }
+#endif
+
 #endif /* ! __LINUX_LSM_HOOKS_H */
diff -uprN ./pristine/linux-4.4.25/include/linux/msg.h ./linux-4.4.25/include/linux/msg.h
--- ./pristine/linux-4.4.25/include/linux/msg.h	2016-10-16 08:48:03.000000000 -0700
+++ ./linux-4.4.25/include/linux/msg.h	2016-10-19 03:14:47.589690486 -0700
@@ -11,6 +11,12 @@ struct msg_msg {
 	size_t m_ts;		/* message text size */
 	struct msg_msgseg *next;
 	void *security;
+#ifdef CONFIG_SECURITY_PROVENANCE
+	void *provenance;
+#endif
+#ifdef CONFIG_SECURITY_IFC
+	void *ifc;
+#endif
 	/* the actual message follows immediately */
 };
 
diff -uprN ./pristine/linux-4.4.25/include/net/sock.h ./linux-4.4.25/include/net/sock.h
--- ./pristine/linux-4.4.25/include/net/sock.h	2016-10-16 08:48:03.000000000 -0700
+++ ./linux-4.4.25/include/net/sock.h	2016-10-19 03:14:47.589690486 -0700
@@ -307,6 +307,8 @@ struct cg_proto;
   *	@sk_peek_off: current peek_offset value
   *	@sk_send_head: front of stuff to transmit
   *	@sk_security: used by security modules
+	*	@sk_provenance: used by provenance modules
+	*	@sk_ifc: used by ifc modules
   *	@sk_mark: generic packet mark
   *	@sk_classid: this socket's cgroup classid
   *	@sk_cgrp: this socket's cgroup-specific proto data
@@ -445,6 +447,12 @@ struct sock {
 #ifdef CONFIG_SECURITY
 	void			*sk_security;
 #endif
+#ifdef CONFIG_SECURITY_PROVENANCE
+	void			*sk_provenance;
+#endif
+#ifdef CONFIG_SECURITY_IFC
+	void			*sk_ifc;
+#endif
 	__u32			sk_mark;
 #ifdef CONFIG_CGROUP_NET_CLASSID
 	u32			sk_classid;
diff -uprN ./pristine/linux-4.4.25/include/uapi/linux/camflow.h ./linux-4.4.25/include/uapi/linux/camflow.h
--- ./pristine/linux-4.4.25/include/uapi/linux/camflow.h	1969-12-31 16:00:00.000000000 -0800
+++ ./linux-4.4.25/include/uapi/linux/camflow.h	2016-10-19 03:14:47.589690486 -0700
@@ -0,0 +1,25 @@
+/*
+*
+* Author: Thomas Pasquier <thomas.pasquier@cl.cam.ac.uk>
+*
+* Copyright (C) 2016 University of Cambridge
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License version 2, as
+* published by the Free Software Foundation; either version 2 of the License, or
+*	(at your option) any later version.
+*
+*/
+#ifndef _UAPI_LINUX_CAMFLOW_H
+#define _UAPI_LINUX_CAMFLOW_H
+
+#define xstr(s) str(s)
+#define str(s) #s
+
+#define CAMFLOW_VERSION_MAJOR     0
+#define CAMFLOW_VERSION_MINOR     1
+#define CAMFLOW_VERSION_PATCH     8
+#define CAMFLOW_VERSION_STR       "v"xstr(CAMFLOW_VERSION_MAJOR)"."xstr(CAMFLOW_VERSION_MINOR)"."xstr(CAMFLOW_VERSION_PATCH)
+
+
+#endif
diff -uprN ./pristine/linux-4.4.25/include/uapi/linux/ifc.h ./linux-4.4.25/include/uapi/linux/ifc.h
--- ./pristine/linux-4.4.25/include/uapi/linux/ifc.h	1969-12-31 16:00:00.000000000 -0800
+++ ./linux-4.4.25/include/uapi/linux/ifc.h	2016-10-19 03:14:47.589690486 -0700
@@ -0,0 +1,100 @@
+/*
+*
+* Author: Thomas Pasquier <thomas.pasquier@cl.cam.ac.uk>
+*
+* Copyright (C) 2015 University of Cambridge
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License version 2, as
+* published by the Free Software Foundation; either version 2 of the License, or
+*	(at your option) any later version.
+*
+*/
+#ifndef _UAPI_LINUX_IFC_H
+#define _UAPI_LINUX_IFC_H
+
+#ifndef __KERNEL__
+#include <linux/limits.h>
+#else
+#include <uapi/linux/limits.h>
+#endif
+
+#define IFC_LABEL_MAX_SIZE  32
+
+#define IFC_SECRECY         1
+#define IFC_INTEGRITY       2
+#define IFC_SECRECY_P       3
+#define IFC_INTEGRITY_P     4
+#define IFC_SECRECY_N       5
+#define IFC_INTEGRITY_N     6
+
+#define IFC_ADD_TAG         1
+#define IFC_REMOVE_TAG      2
+#define IFC_ADD_BRIDGE      3
+#define IFC_START_BRIDGE    4
+#define IFC_ADD_TRUSTED     5
+
+#define IFC_TRUSTED         1
+#define IFC_UNTRUSTED       0
+
+#define IFC_SELF_FILE             "/sys/kernel/security/ifc/self"
+#define IFC_TAG_FILE              "/sys/kernel/security/ifc/tag"
+#define IFC_PROCESS_FILE          "/sys/kernel/security/ifc/process"
+#define IFC_BRIDGE_FILE           "/sys/kernel/security/ifc/bridge"
+#define IFC_FILE_FILE             "/sys/kernel/security/ifc/file"
+
+typedef uint64_t tag_t;
+
+struct ifc_label{
+  tag_t array[IFC_LABEL_MAX_SIZE];
+  uint8_t size;
+};
+
+struct ifc_context{
+  struct ifc_label secrecy;
+  struct ifc_label integrity;
+  struct ifc_label secrecy_p;
+  struct ifc_label integrity_p;
+  struct ifc_label secrecy_n;
+  struct ifc_label integrity_n;
+  uint8_t trusted;
+};
+
+struct ifc_tag_msg{
+  tag_t tag;
+  uint8_t tag_type;
+  uint8_t op;
+  uint32_t pid;
+};
+
+struct ifc_context_msg{
+  struct ifc_context context;
+  uint32_t pid;
+};
+
+struct ifc_bridge_msg{
+  uint32_t remote_pid;
+  uint64_t msg_id; /* contain provenance id if active */
+};
+
+
+#define PARAM_MAX 256
+struct ifc_bridge_config{
+  char path[PATH_MAX];
+  char param[PARAM_MAX];
+  uint8_t op;
+};
+
+struct ifc_file_config{
+  char name[PATH_MAX];
+  struct ifc_context context;
+};
+
+struct ifc_file_change{
+  char name[PATH_MAX];
+  tag_t tag;
+  uint8_t tag_type;
+  uint8_t op;
+};
+
+#endif
diff -uprN ./pristine/linux-4.4.25/include/uapi/linux/Kbuild ./linux-4.4.25/include/uapi/linux/Kbuild
--- ./pristine/linux-4.4.25/include/uapi/linux/Kbuild	2016-10-16 08:48:03.000000000 -0700
+++ ./linux-4.4.25/include/uapi/linux/Kbuild	2016-10-19 03:14:47.589690486 -0700
@@ -75,6 +75,7 @@ header-y += bpf.h
 header-y += bpqether.h
 header-y += bsg.h
 header-y += btrfs.h
+header-y += camflow.h
 header-y += can.h
 header-y += capability.h
 header-y += capi.h
@@ -185,6 +186,7 @@ header-y += if_tun.h
 header-y += if_tunnel.h
 header-y += if_vlan.h
 header-y += if_x25.h
+header-y += ifc.h
 header-y += igmp.h
 header-y += ila.h
 header-y += in6.h
@@ -337,6 +339,7 @@ header-y += ppp_defs.h
 header-y += ppp-ioctl.h
 header-y += pps.h
 header-y += prctl.h
+header-y += provenance.h
 header-y += psci.h
 header-y += ptp_clock.h
 header-y += ptrace.h
diff -uprN ./pristine/linux-4.4.25/include/uapi/linux/netlink.h ./linux-4.4.25/include/uapi/linux/netlink.h
--- ./pristine/linux-4.4.25/include/uapi/linux/netlink.h	2016-10-16 08:48:03.000000000 -0700
+++ ./linux-4.4.25/include/uapi/linux/netlink.h	2016-10-19 03:14:47.590690494 -0700
@@ -15,7 +15,7 @@
 #define NETLINK_SELINUX		7	/* SELinux event notifications */
 #define NETLINK_ISCSI		8	/* Open-iSCSI */
 #define NETLINK_AUDIT		9	/* auditing */
-#define NETLINK_FIB_LOOKUP	10	
+#define NETLINK_FIB_LOOKUP	10
 #define NETLINK_CONNECTOR	11
 #define NETLINK_NETFILTER	12	/* netfilter subsystem */
 #define NETLINK_IP6_FW		13
@@ -27,10 +27,11 @@
 #define NETLINK_ECRYPTFS	19
 #define NETLINK_RDMA		20
 #define NETLINK_CRYPTO		21	/* Crypto layer */
+#define NETLINK_CAMFLOW_IFC_BRIDGE 25 /* CAMFLOW IFC BRIDGE */
 
 #define NETLINK_INET_DIAG	NETLINK_SOCK_DIAG
 
-#define MAX_LINKS 32		
+#define MAX_LINKS 32
 
 struct sockaddr_nl {
 	__kernel_sa_family_t	nl_family;	/* AF_NETLINK	*/
diff -uprN ./pristine/linux-4.4.25/include/uapi/linux/provenance.h ./linux-4.4.25/include/uapi/linux/provenance.h
--- ./pristine/linux-4.4.25/include/uapi/linux/provenance.h	1969-12-31 16:00:00.000000000 -0800
+++ ./linux-4.4.25/include/uapi/linux/provenance.h	2016-10-19 03:14:47.590690494 -0700
@@ -0,0 +1,386 @@
+/*
+*
+* Author: Thomas Pasquier <thomas.pasquier@cl.cam.ac.uk>
+*
+* Copyright (C) 2015 University of Cambridge
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License version 2, as
+* published by the Free Software Foundation; either version 2 of the License, or
+*	(at your option) any later version.
+*
+*/
+#ifndef _UAPI_LINUX_PROVENANCE_H
+#define _UAPI_LINUX_PROVENANCE_H
+
+#ifndef __KERNEL__
+#include <linux/limits.h>
+#include <linux/ifc.h>
+#else
+#include <linux/socket.h>
+#include <uapi/linux/ifc.h>
+#include <uapi/linux/limits.h>
+#include <linux/mutex.h>
+#endif
+
+#define GOLDEN_RATIO_64 0x61C8864680B583EBull
+static inline uint32_t prov_hash(uint64_t val){
+  return (val * GOLDEN_RATIO_64) >> (64-8);
+}
+
+#define PROV_K_HASH 7
+#define PROV_M_BITS 256
+#define PROV_N_BYTES (PROV_M_BITS/8)
+#define PROV_BYTE_INDEX(a) (a/8)
+#define PROV_BIT_INDEX(a) (a%8)
+
+static inline void prov_bloom_add(uint8_t bloom[PROV_N_BYTES], uint64_t val){
+  uint8_t i;
+  uint32_t pos;
+  for(i=0; i < PROV_K_HASH; i++){
+    pos= prov_hash(val+i) % PROV_M_BITS;
+    bloom[PROV_BYTE_INDEX(pos)] |= 1 << PROV_BIT_INDEX(pos);
+  }
+}
+
+/* element in set belong to super */
+static inline bool prov_bloom_match(const uint8_t super[PROV_N_BYTES], const uint8_t set[PROV_N_BYTES]){
+    uint8_t i;
+    for(i=0; i<PROV_N_BYTES; i++){
+        if((super[i]&set[i]) != set[i]){
+            return false;
+        }
+    }
+    return true;
+}
+
+static inline bool prov_bloom_in(const uint8_t bloom[PROV_N_BYTES], uint64_t val){
+    uint8_t tmp[PROV_N_BYTES];
+
+    memset(tmp, 0, PROV_N_BYTES);
+    prov_bloom_add(tmp, val);
+    return prov_bloom_match(bloom, tmp);
+}
+
+/* merge src into dest (dest=dest U src) */
+static inline void prov_bloom_merge(uint8_t dest[PROV_N_BYTES], const uint8_t src[PROV_N_BYTES]){
+    uint8_t i;
+    for(i=0; i<PROV_N_BYTES; i++){
+        dest[i] |= src[i];
+    }
+}
+
+
+static inline bool prov_bloom_empty(const uint8_t bloom[PROV_N_BYTES]){
+  uint8_t i;
+  for(i=0; i<PROV_N_BYTES; i++){
+      if( bloom[i] != 0 ){
+          return false;
+      }
+  }
+  return true;
+}
+
+#define PROV_ENABLE_FILE                      "/sys/kernel/security/provenance/enable"
+#define PROV_ALL_FILE                         "/sys/kernel/security/provenance/all"
+#define PROV_NODE_FILE                        "/sys/kernel/security/provenance/node"
+#define PROV_RELATION_FILE                    "/sys/kernel/security/provenance/relation"
+#define PROV_SELF_FILE                        "/sys/kernel/security/provenance/self"
+#define PROV_MACHINE_ID_FILE                  "/sys/kernel/security/provenance/machine_id"
+#define PROV_NODE_FILTER_FILE                 "/sys/kernel/security/provenance/node_filter"
+#define PROV_RELATION_FILTER_FILE             "/sys/kernel/security/provenance/relation_filter"
+#define PROV_PROPAGATE_NODE_FILTER_FILE       "/sys/kernel/security/provenance/propagate_node_filter"
+#define PROV_PROPAGATE_RELATION_FILTER_FILE   "/sys/kernel/security/provenance/propagate_relation_filter"
+#define PROV_FLUSH_FILE                       "/sys/kernel/security/provenance/flush"
+#define PROV_FILE_FILE                        "/sys/kernel/security/provenance/file"
+
+#define PROV_RELAY_NAME                       "/sys/kernel/debug/provenance"
+#define PROV_LONG_RELAY_NAME                  "/sys/kernel/debug/long_provenance"
+
+#define MSG_STR               0x00000001UL
+#define MSG_RELATION          0x00000002UL
+#define MSG_TASK              0x00000004UL
+#define MSG_INODE_UNKNOWN     0x00000008UL
+#define MSG_INODE_LINK        0x00000010UL
+#define MSG_INODE_FILE        0x00000020UL
+#define MSG_INODE_DIRECTORY   0x00000040UL
+#define MSG_INODE_CHAR        0x00000080UL
+#define MSG_INODE_BLOCK       0x00000100UL
+#define MSG_INODE_FIFO        0x00000200UL
+#define MSG_INODE_SOCKET      0x00000400UL
+#define MSG_MSG               0x00000800UL
+#define MSG_SHM               0x00001000UL
+#define MSG_SOCK              0x00002000UL
+#define MSG_ADDR              0x00004000UL
+#define MSG_SB                0x00008000UL
+#define MSG_FILE_NAME         0x00010000UL
+#define MSG_IFC               0x00020000UL
+#define MSG_DISC_ENTITY       0x00040000UL
+#define MSG_DISC_ACTIVITY     0x00080000UL
+#define MSG_DISC_AGENT        0x00100000UL
+#define MSG_DISC_NODE         0x00200000UL
+#define MSG_PACKET            0x00400000UL
+#define MSG_INODE_MMAP        0x00800000UL
+
+#define RL_READ               0x00000001UL
+#define RL_WRITE              0x00000002UL
+#define RL_CREATE             0x00000004UL
+#define RL_PASS               0x00000008UL
+#define RL_CHANGE             0x00000010UL
+#define RL_MMAP_WRITE         0x00000020UL
+#define RL_ATTACH             0x00000040UL
+#define RL_ASSOCIATE          0x00000080UL
+#define RL_BIND               0x00000100UL
+#define RL_CONNECT            0x00000200UL
+#define RL_LISTEN             0x00000400UL
+#define RL_ACCEPT             0x00000800UL
+#define RL_OPEN               0x00001000UL
+#define RL_PARENT             0x00002000UL
+#define RL_VERSION            0x00004000UL
+#define RL_LINK               0x00008000UL
+#define RL_NAMED              0x00010000UL
+#define RL_IFC                0x00020000UL
+#define RL_EXEC               0x00040000UL
+#define RL_CLONE              0x00080000UL
+#define RL_UNKNOWN            0x00100000UL
+#define RL_VERSION_PROCESS    0x00200000UL
+#define RL_SEARCH             0x00400000UL
+#define RL_ALLOWED            0x00800000UL
+#define RL_DISALLOWED         0x01000000UL
+#define RL_MMAP_READ          0x02000000UL
+#define RL_MMAP_EXEC          0x04000000UL
+#define RL_SND                0x08000000UL
+#define RL_RCV                0x10000000UL
+#define RL_PERM_READ          0x20000000UL
+#define RL_PERM_WRITE         0x40000000UL
+#define RL_PERM_EXEC          0x80000000UL
+
+#define FLOW_ALLOWED        1
+#define FLOW_DISALLOWED     0
+
+#define prov_type(prov) ((prov)->node_info.identifier.node_id.type)
+#define prov_id_buffer(prov) ((prov)->node_info.identifier.buffer)
+#define node_identifier(node) ((node)->node_info.identifier.node_id)
+#define relation_identifier(relation) ((relation)->relation_info.identifier.relation_id)
+#define packet_identifier(packet) ((packet)->pck_info.identifier.packet_id)
+#define prov_flag(prov) ((prov)->msg_info.flag)
+#define prov_taint(prov) ((prov)->msg_info.taint)
+#define prov_jiffies(prov) ((prov)->msg_info.jiffies)
+
+struct node_identifier{
+  uint32_t type;
+  uint64_t id;
+  uint32_t boot_id;
+  uint32_t machine_id;
+  uint32_t version;
+};
+
+struct relation_identifier{
+  uint32_t type;
+  uint64_t id;
+  uint32_t boot_id;
+  uint32_t machine_id;
+};
+
+struct packet_identifier{
+  uint32_t type;
+  uint16_t id;
+  uint32_t snd_ip;
+  uint32_t rcv_ip;
+  uint16_t snd_port;
+  uint16_t rcv_port;
+  uint8_t protocol;
+  uint32_t seq;
+};
+
+#define PROV_IDENTIFIER_BUFFER_LENGTH sizeof(struct node_identifier)
+
+typedef union prov_identifier{
+  struct node_identifier node_id;
+  struct relation_identifier relation_id;
+  struct packet_identifier packet_id;
+  uint8_t buffer[PROV_IDENTIFIER_BUFFER_LENGTH];
+} prov_identifier_t;
+
+#define prov_set_flag(node, nbit) prov_flag(node) |= 1 << nbit
+#define prov_clear_flag(node, nbit) prov_flag(node) &= ~(1 << nbit)
+#define prov_check_flag(node, nbit) ((prov_flag(node) & (1 << nbit)) == (1 << nbit))
+
+#define RECORDED_BIT 0
+#define set_recorded(node)                  prov_set_flag(node, RECORDED_BIT)
+#define clear_recorded(node)                prov_clear_flag(node, RECORDED_BIT)
+#define provenance_is_recorded(node)        prov_check_flag(node, RECORDED_BIT)
+
+#define NAME_RECORDED_BIT 1
+#define set_name_recorded(node)             prov_set_flag(node, NAME_RECORDED_BIT)
+#define clear__name_recorded(node)          prov_clear_flag(node, NAME_RECORDED_BIT)
+#define provenance_is_name_recorded(node)   prov_check_flag(node, NAME_RECORDED_BIT)
+
+#define TRACKED_BIT 2
+#define set_tracked(node)                   prov_set_flag(node, TRACKED_BIT)
+#define clear_tracked(node)                 prov_clear_flag(node, TRACKED_BIT)
+#define provenance_is_tracked(node)         prov_check_flag(node, TRACKED_BIT)
+
+#define OPAQUE_BIT 3
+#define set_opaque(node)                    prov_set_flag(node, OPAQUE_BIT)
+#define clear_opaque(node)                  prov_clear_flag(node, OPAQUE_BIT)
+#define provenance_is_opaque(node)          prov_check_flag(node, OPAQUE_BIT)
+
+#define PROPAGATE_BIT 4
+#define set_propagate(node)                 prov_set_flag(node, PROPAGATE_BIT)
+#define clear_propagate(node)               prov_clear_flag(node, PROPAGATE_BIT)
+#define provenance_propagate(node)          prov_check_flag(node, PROPAGATE_BIT)
+
+#define basic_elements prov_identifier_t identifier; uint8_t flag; uint64_t jiffies; uint8_t taint[PROV_N_BYTES]
+
+struct msg_struct{
+  basic_elements;
+};
+
+#define FILE_INFO_SET 0x01
+
+struct relation_struct{
+  basic_elements;
+  uint32_t type;
+  uint8_t allowed;
+  prov_identifier_t snd;
+  prov_identifier_t rcv;
+  uint8_t set;
+  int64_t offset;
+};
+
+union provmutex{
+#ifdef __KERNEL__
+  struct mutex l;
+#endif
+  uint8_t placeholder[70];
+};
+
+struct node_struct{
+  basic_elements;
+  union provmutex lprov;
+};
+
+struct task_prov_struct{
+  basic_elements;
+  union provmutex lprov;
+  uint32_t uid;
+  uint32_t gid;
+};
+
+struct inode_prov_struct{
+  basic_elements;
+  union provmutex lprov;
+  uint32_t uid;
+  uint32_t gid;
+  uint16_t mode;
+  uint8_t sb_uuid[16];
+};
+
+struct msg_msg_struct{
+  basic_elements;
+  union provmutex lprov;
+  long type;
+};
+
+struct shm_struct{
+  basic_elements;
+  union provmutex lprov;
+  uint16_t mode;
+};
+
+struct sock_struct{
+  basic_elements;
+  union provmutex lprov;
+  uint16_t type;
+  uint16_t family;
+  uint8_t protocol;
+};
+
+struct sb_struct{
+  basic_elements;
+  union provmutex lprov;
+  uint8_t uuid[16];
+};
+
+struct pck_struct{
+  basic_elements;
+  union provmutex lprov;
+  uint16_t length;
+};
+
+typedef union prov_msg{
+  struct msg_struct           msg_info;
+  struct relation_struct      relation_info;
+  struct node_struct          node_info;
+  struct task_prov_struct     task_info;
+  struct inode_prov_struct    inode_info;
+  struct msg_msg_struct       msg_msg_info;
+  struct shm_struct           shm_info;
+  struct sock_struct          sock_info;
+  struct sb_struct            sb_info;
+  struct pck_struct           pck_info;
+} prov_msg_t;
+
+struct str_struct{
+  basic_elements;
+  char str[PATH_MAX];
+  size_t length;
+};
+
+struct file_name_struct{
+  basic_elements;
+  char name[PATH_MAX];
+  size_t length;
+};
+
+struct address_struct{
+  basic_elements;
+  struct sockaddr addr;
+  size_t length;
+};
+
+struct ifc_context_struct{
+  basic_elements;
+  struct ifc_context context;
+};
+
+struct disc_node_struct{
+  basic_elements;
+  size_t length;
+  char content[PATH_MAX];
+  prov_identifier_t parent;
+};
+
+typedef union long_msg{
+  struct msg_struct           msg_info;
+  struct node_struct          node_info;
+  struct str_struct           str_info;
+  struct file_name_struct     file_name_info;
+  struct address_struct       address_info;
+  struct ifc_context_struct   ifc_info;
+  struct disc_node_struct     disc_node_info;
+} long_prov_msg_t;
+
+struct prov_filter{
+  uint32_t filter;
+  uint8_t add;
+};
+
+#define PROV_SET_TRACKED		  0x01
+#define PROV_SET_OPAQUE 		  0x02
+#define PROV_SET_PROPAGATE    0x04
+#define PROV_SET_TAINT        0x08
+
+struct prov_file_config{
+  char name[PATH_MAX];
+  prov_msg_t prov;
+  uint8_t op;
+};
+
+struct prov_self_config{
+  prov_msg_t prov;
+  uint8_t op;
+};
+
+#endif
diff -uprN ./pristine/linux-4.4.25/include/uapi/linux/xattr.h ./linux-4.4.25/include/uapi/linux/xattr.h
--- ./pristine/linux-4.4.25/include/uapi/linux/xattr.h	2016-10-16 08:48:03.000000000 -0700
+++ ./linux-4.4.25/include/uapi/linux/xattr.h	2016-10-19 03:14:47.590690494 -0700
@@ -52,6 +52,11 @@
 #define XATTR_SELINUX_SUFFIX "selinux"
 #define XATTR_NAME_SELINUX XATTR_SECURITY_PREFIX XATTR_SELINUX_SUFFIX
 
+#define XATTR_PROVENANCE_SUFFIX "provenance"
+#define XATTR_NAME_PROVENANCE XATTR_SECURITY_PREFIX XATTR_PROVENANCE_SUFFIX
+#define XATTR_IFC_SUFFIX "ifc"
+#define XATTR_NAME_IFC XATTR_SECURITY_PREFIX XATTR_IFC_SUFFIX
+
 #define XATTR_SMACK_SUFFIX "SMACK64"
 #define XATTR_SMACK_IPIN "SMACK64IPIN"
 #define XATTR_SMACK_IPOUT "SMACK64IPOUT"
diff -uprN ./pristine/linux-4.4.25/security/camflow/include/av_utils.h ./linux-4.4.25/security/camflow/include/av_utils.h
--- ./pristine/linux-4.4.25/security/camflow/include/av_utils.h	1969-12-31 16:00:00.000000000 -0800
+++ ./linux-4.4.25/security/camflow/include/av_utils.h	2016-10-19 03:14:47.581690419 -0700
@@ -0,0 +1,1067 @@
+/*
+*
+* Author: Thomas Pasquier <tfjmp@seas.harvard.edu>
+*
+* Copyright (C) 2016 Harvard University
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License version 2, as
+* published by the Free Software Foundation.
+*
+*/
+
+#ifndef _AV_UTILS_PROVENANCE_H
+#define _AV_UTILS_PROVENANCE_H
+
+// that is nasty, need to replace at some point
+#define COMMON_FILE__IOCTL                               0x00000001UL
+#define COMMON_FILE__READ                                0x00000002UL
+#define COMMON_FILE__WRITE                               0x00000004UL
+#define COMMON_FILE__CREATE                              0x00000008UL
+#define COMMON_FILE__GETATTR                             0x00000010UL
+#define COMMON_FILE__SETATTR                             0x00000020UL
+#define COMMON_FILE__LOCK                                0x00000040UL
+#define COMMON_FILE__RELABELFROM                         0x00000080UL
+#define COMMON_FILE__RELABELTO                           0x00000100UL
+#define COMMON_FILE__APPEND                              0x00000200UL
+#define COMMON_FILE__UNLINK                              0x00000400UL
+#define COMMON_FILE__LINK                                0x00000800UL
+#define COMMON_FILE__RENAME                              0x00001000UL
+#define COMMON_FILE__EXECUTE                             0x00002000UL
+#define COMMON_FILE__SWAPON                              0x00004000UL
+#define COMMON_FILE__QUOTAON                             0x00008000UL
+#define COMMON_FILE__MOUNTON                             0x00010000UL
+#define COMMON_SOCKET__IOCTL                             0x00000001UL
+#define COMMON_SOCKET__READ                              0x00000002UL
+#define COMMON_SOCKET__WRITE                             0x00000004UL
+#define COMMON_SOCKET__CREATE                            0x00000008UL
+#define COMMON_SOCKET__GETATTR                           0x00000010UL
+#define COMMON_SOCKET__SETATTR                           0x00000020UL
+#define COMMON_SOCKET__LOCK                              0x00000040UL
+#define COMMON_SOCKET__RELABELFROM                       0x00000080UL
+#define COMMON_SOCKET__RELABELTO                         0x00000100UL
+#define COMMON_SOCKET__APPEND                            0x00000200UL
+#define COMMON_SOCKET__BIND                              0x00000400UL
+#define COMMON_SOCKET__CONNECT                           0x00000800UL
+#define COMMON_SOCKET__LISTEN                            0x00001000UL
+#define COMMON_SOCKET__ACCEPT                            0x00002000UL
+#define COMMON_SOCKET__GETOPT                            0x00004000UL
+#define COMMON_SOCKET__SETOPT                            0x00008000UL
+#define COMMON_SOCKET__SHUTDOWN                          0x00010000UL
+#define COMMON_SOCKET__RECVFROM                          0x00020000UL
+#define COMMON_SOCKET__SENDTO                            0x00040000UL
+#define COMMON_SOCKET__RECV_MSG                          0x00080000UL
+#define COMMON_SOCKET__SEND_MSG                          0x00100000UL
+#define COMMON_SOCKET__NAME_BIND                         0x00200000UL
+#define COMMON_IPC__CREATE                               0x00000001UL
+#define COMMON_IPC__DESTROY                              0x00000002UL
+#define COMMON_IPC__GETATTR                              0x00000004UL
+#define COMMON_IPC__SETATTR                              0x00000008UL
+#define COMMON_IPC__READ                                 0x00000010UL
+#define COMMON_IPC__WRITE                                0x00000020UL
+#define COMMON_IPC__ASSOCIATE                            0x00000040UL
+#define COMMON_IPC__UNIX_READ                            0x00000080UL
+#define COMMON_IPC__UNIX_WRITE                           0x00000100UL
+#define COMMON_DATABASE__CREATE                          0x00000001UL
+#define COMMON_DATABASE__DROP                            0x00000002UL
+#define COMMON_DATABASE__GETATTR                         0x00000004UL
+#define COMMON_DATABASE__SETATTR                         0x00000008UL
+#define COMMON_DATABASE__RELABELFROM                     0x00000010UL
+#define COMMON_DATABASE__RELABELTO                       0x00000020UL
+#define FILESYSTEM__MOUNT                         0x00000001UL
+#define FILESYSTEM__REMOUNT                       0x00000002UL
+#define FILESYSTEM__UNMOUNT                       0x00000004UL
+#define FILESYSTEM__GETATTR                       0x00000008UL
+#define FILESYSTEM__RELABELFROM                   0x00000010UL
+#define FILESYSTEM__RELABELTO                     0x00000020UL
+#define FILESYSTEM__TRANSITION                    0x00000040UL
+#define FILESYSTEM__ASSOCIATE                     0x00000080UL
+#define FILESYSTEM__QUOTAMOD                      0x00000100UL
+#define FILESYSTEM__QUOTAGET                      0x00000200UL
+#define DIR__IOCTL                                0x00000001UL
+#define DIR__READ                                 0x00000002UL
+#define DIR__WRITE                                0x00000004UL
+#define DIR__CREATE                               0x00000008UL
+#define DIR__GETATTR                              0x00000010UL
+#define DIR__SETATTR                              0x00000020UL
+#define DIR__LOCK                                 0x00000040UL
+#define DIR__RELABELFROM                          0x00000080UL
+#define DIR__RELABELTO                            0x00000100UL
+#define DIR__APPEND                               0x00000200UL
+#define DIR__UNLINK                               0x00000400UL
+#define DIR__LINK                                 0x00000800UL
+#define DIR__RENAME                               0x00001000UL
+#define DIR__EXECUTE                              0x00002000UL
+#define DIR__SWAPON                               0x00004000UL
+#define DIR__QUOTAON                              0x00008000UL
+#define DIR__MOUNTON                              0x00010000UL
+#define DIR__ADD_NAME                             0x00020000UL
+#define DIR__REMOVE_NAME                          0x00040000UL
+#define DIR__REPARENT                             0x00080000UL
+#define DIR__SEARCH                               0x00100000UL
+#define DIR__RMDIR                                0x00200000UL
+#define DIR__OPEN                                 0x00400000UL
+#define FILE__IOCTL                               0x00000001UL
+#define FILE__READ                                0x00000002UL
+#define FILE__WRITE                               0x00000004UL
+#define FILE__CREATE                              0x00000008UL
+#define FILE__GETATTR                             0x00000010UL
+#define FILE__SETATTR                             0x00000020UL
+#define FILE__LOCK                                0x00000040UL
+#define FILE__RELABELFROM                         0x00000080UL
+#define FILE__RELABELTO                           0x00000100UL
+#define FILE__APPEND                              0x00000200UL
+#define FILE__UNLINK                              0x00000400UL
+#define FILE__LINK                                0x00000800UL
+#define FILE__RENAME                              0x00001000UL
+#define FILE__EXECUTE                             0x00002000UL
+#define FILE__SWAPON                              0x00004000UL
+#define FILE__QUOTAON                             0x00008000UL
+#define FILE__MOUNTON                             0x00010000UL
+#define FILE__EXECUTE_NO_TRANS                    0x00020000UL
+#define FILE__ENTRYPOINT                          0x00040000UL
+#define FILE__EXECMOD                             0x00080000UL
+#define FILE__OPEN                                0x00100000UL
+#define LNK_FILE__IOCTL                           0x00000001UL
+#define LNK_FILE__READ                            0x00000002UL
+#define LNK_FILE__WRITE                           0x00000004UL
+#define LNK_FILE__CREATE                          0x00000008UL
+#define LNK_FILE__GETATTR                         0x00000010UL
+#define LNK_FILE__SETATTR                         0x00000020UL
+#define LNK_FILE__LOCK                            0x00000040UL
+#define LNK_FILE__RELABELFROM                     0x00000080UL
+#define LNK_FILE__RELABELTO                       0x00000100UL
+#define LNK_FILE__APPEND                          0x00000200UL
+#define LNK_FILE__UNLINK                          0x00000400UL
+#define LNK_FILE__LINK                            0x00000800UL
+#define LNK_FILE__RENAME                          0x00001000UL
+#define LNK_FILE__EXECUTE                         0x00002000UL
+#define LNK_FILE__SWAPON                          0x00004000UL
+#define LNK_FILE__QUOTAON                         0x00008000UL
+#define LNK_FILE__MOUNTON                         0x00010000UL
+#define CHR_FILE__IOCTL                           0x00000001UL
+#define CHR_FILE__READ                            0x00000002UL
+#define CHR_FILE__WRITE                           0x00000004UL
+#define CHR_FILE__CREATE                          0x00000008UL
+#define CHR_FILE__GETATTR                         0x00000010UL
+#define CHR_FILE__SETATTR                         0x00000020UL
+#define CHR_FILE__LOCK                            0x00000040UL
+#define CHR_FILE__RELABELFROM                     0x00000080UL
+#define CHR_FILE__RELABELTO                       0x00000100UL
+#define CHR_FILE__APPEND                          0x00000200UL
+#define CHR_FILE__UNLINK                          0x00000400UL
+#define CHR_FILE__LINK                            0x00000800UL
+#define CHR_FILE__RENAME                          0x00001000UL
+#define CHR_FILE__EXECUTE                         0x00002000UL
+#define CHR_FILE__SWAPON                          0x00004000UL
+#define CHR_FILE__QUOTAON                         0x00008000UL
+#define CHR_FILE__MOUNTON                         0x00010000UL
+#define CHR_FILE__EXECUTE_NO_TRANS                0x00020000UL
+#define CHR_FILE__ENTRYPOINT                      0x00040000UL
+#define CHR_FILE__EXECMOD                         0x00080000UL
+#define CHR_FILE__OPEN                            0x00100000UL
+#define BLK_FILE__IOCTL                           0x00000001UL
+#define BLK_FILE__READ                            0x00000002UL
+#define BLK_FILE__WRITE                           0x00000004UL
+#define BLK_FILE__CREATE                          0x00000008UL
+#define BLK_FILE__GETATTR                         0x00000010UL
+#define BLK_FILE__SETATTR                         0x00000020UL
+#define BLK_FILE__LOCK                            0x00000040UL
+#define BLK_FILE__RELABELFROM                     0x00000080UL
+#define BLK_FILE__RELABELTO                       0x00000100UL
+#define BLK_FILE__APPEND                          0x00000200UL
+#define BLK_FILE__UNLINK                          0x00000400UL
+#define BLK_FILE__LINK                            0x00000800UL
+#define BLK_FILE__RENAME                          0x00001000UL
+#define BLK_FILE__EXECUTE                         0x00002000UL
+#define BLK_FILE__SWAPON                          0x00004000UL
+#define BLK_FILE__QUOTAON                         0x00008000UL
+#define BLK_FILE__MOUNTON                         0x00010000UL
+#define BLK_FILE__OPEN                            0x00020000UL
+#define SOCK_FILE__IOCTL                          0x00000001UL
+#define SOCK_FILE__READ                           0x00000002UL
+#define SOCK_FILE__WRITE                          0x00000004UL
+#define SOCK_FILE__CREATE                         0x00000008UL
+#define SOCK_FILE__GETATTR                        0x00000010UL
+#define SOCK_FILE__SETATTR                        0x00000020UL
+#define SOCK_FILE__LOCK                           0x00000040UL
+#define SOCK_FILE__RELABELFROM                    0x00000080UL
+#define SOCK_FILE__RELABELTO                      0x00000100UL
+#define SOCK_FILE__APPEND                         0x00000200UL
+#define SOCK_FILE__UNLINK                         0x00000400UL
+#define SOCK_FILE__LINK                           0x00000800UL
+#define SOCK_FILE__RENAME                         0x00001000UL
+#define SOCK_FILE__EXECUTE                        0x00002000UL
+#define SOCK_FILE__SWAPON                         0x00004000UL
+#define SOCK_FILE__QUOTAON                        0x00008000UL
+#define SOCK_FILE__MOUNTON                        0x00010000UL
+#define FIFO_FILE__IOCTL                          0x00000001UL
+#define FIFO_FILE__READ                           0x00000002UL
+#define FIFO_FILE__WRITE                          0x00000004UL
+#define FIFO_FILE__CREATE                         0x00000008UL
+#define FIFO_FILE__GETATTR                        0x00000010UL
+#define FIFO_FILE__SETATTR                        0x00000020UL
+#define FIFO_FILE__LOCK                           0x00000040UL
+#define FIFO_FILE__RELABELFROM                    0x00000080UL
+#define FIFO_FILE__RELABELTO                      0x00000100UL
+#define FIFO_FILE__APPEND                         0x00000200UL
+#define FIFO_FILE__UNLINK                         0x00000400UL
+#define FIFO_FILE__LINK                           0x00000800UL
+#define FIFO_FILE__RENAME                         0x00001000UL
+#define FIFO_FILE__EXECUTE                        0x00002000UL
+#define FIFO_FILE__SWAPON                         0x00004000UL
+#define FIFO_FILE__QUOTAON                        0x00008000UL
+#define FIFO_FILE__MOUNTON                        0x00010000UL
+#define FIFO_FILE__OPEN                           0x00020000UL
+#define FD__USE                                   0x00000001UL
+#define SOCKET__IOCTL                             0x00000001UL
+#define SOCKET__READ                              0x00000002UL
+#define SOCKET__WRITE                             0x00000004UL
+#define SOCKET__CREATE                            0x00000008UL
+#define SOCKET__GETATTR                           0x00000010UL
+#define SOCKET__SETATTR                           0x00000020UL
+#define SOCKET__LOCK                              0x00000040UL
+#define SOCKET__RELABELFROM                       0x00000080UL
+#define SOCKET__RELABELTO                         0x00000100UL
+#define SOCKET__APPEND                            0x00000200UL
+#define SOCKET__BIND                              0x00000400UL
+#define SOCKET__CONNECT                           0x00000800UL
+#define SOCKET__LISTEN                            0x00001000UL
+#define SOCKET__ACCEPT                            0x00002000UL
+#define SOCKET__GETOPT                            0x00004000UL
+#define SOCKET__SETOPT                            0x00008000UL
+#define SOCKET__SHUTDOWN                          0x00010000UL
+#define SOCKET__RECVFROM                          0x00020000UL
+#define SOCKET__SENDTO                            0x00040000UL
+#define SOCKET__RECV_MSG                          0x00080000UL
+#define SOCKET__SEND_MSG                          0x00100000UL
+#define SOCKET__NAME_BIND                         0x00200000UL
+#define TCP_SOCKET__IOCTL                         0x00000001UL
+#define TCP_SOCKET__READ                          0x00000002UL
+#define TCP_SOCKET__WRITE                         0x00000004UL
+#define TCP_SOCKET__CREATE                        0x00000008UL
+#define TCP_SOCKET__GETATTR                       0x00000010UL
+#define TCP_SOCKET__SETATTR                       0x00000020UL
+#define TCP_SOCKET__LOCK                          0x00000040UL
+#define TCP_SOCKET__RELABELFROM                   0x00000080UL
+#define TCP_SOCKET__RELABELTO                     0x00000100UL
+#define TCP_SOCKET__APPEND                        0x00000200UL
+#define TCP_SOCKET__BIND                          0x00000400UL
+#define TCP_SOCKET__CONNECT                       0x00000800UL
+#define TCP_SOCKET__LISTEN                        0x00001000UL
+#define TCP_SOCKET__ACCEPT                        0x00002000UL
+#define TCP_SOCKET__GETOPT                        0x00004000UL
+#define TCP_SOCKET__SETOPT                        0x00008000UL
+#define TCP_SOCKET__SHUTDOWN                      0x00010000UL
+#define TCP_SOCKET__RECVFROM                      0x00020000UL
+#define TCP_SOCKET__SENDTO                        0x00040000UL
+#define TCP_SOCKET__RECV_MSG                      0x00080000UL
+#define TCP_SOCKET__SEND_MSG                      0x00100000UL
+#define TCP_SOCKET__NAME_BIND                     0x00200000UL
+#define TCP_SOCKET__CONNECTTO                     0x00400000UL
+#define TCP_SOCKET__NEWCONN                       0x00800000UL
+#define TCP_SOCKET__ACCEPTFROM                    0x01000000UL
+#define TCP_SOCKET__NODE_BIND                     0x02000000UL
+#define TCP_SOCKET__NAME_CONNECT                  0x04000000UL
+#define UDP_SOCKET__IOCTL                         0x00000001UL
+#define UDP_SOCKET__READ                          0x00000002UL
+#define UDP_SOCKET__WRITE                         0x00000004UL
+#define UDP_SOCKET__CREATE                        0x00000008UL
+#define UDP_SOCKET__GETATTR                       0x00000010UL
+#define UDP_SOCKET__SETATTR                       0x00000020UL
+#define UDP_SOCKET__LOCK                          0x00000040UL
+#define UDP_SOCKET__RELABELFROM                   0x00000080UL
+#define UDP_SOCKET__RELABELTO                     0x00000100UL
+#define UDP_SOCKET__APPEND                        0x00000200UL
+#define UDP_SOCKET__BIND                          0x00000400UL
+#define UDP_SOCKET__CONNECT                       0x00000800UL
+#define UDP_SOCKET__LISTEN                        0x00001000UL
+#define UDP_SOCKET__ACCEPT                        0x00002000UL
+#define UDP_SOCKET__GETOPT                        0x00004000UL
+#define UDP_SOCKET__SETOPT                        0x00008000UL
+#define UDP_SOCKET__SHUTDOWN                      0x00010000UL
+#define UDP_SOCKET__RECVFROM                      0x00020000UL
+#define UDP_SOCKET__SENDTO                        0x00040000UL
+#define UDP_SOCKET__RECV_MSG                      0x00080000UL
+#define UDP_SOCKET__SEND_MSG                      0x00100000UL
+#define UDP_SOCKET__NAME_BIND                     0x00200000UL
+#define UDP_SOCKET__NODE_BIND                     0x00400000UL
+#define RAWIP_SOCKET__IOCTL                       0x00000001UL
+#define RAWIP_SOCKET__READ                        0x00000002UL
+#define RAWIP_SOCKET__WRITE                       0x00000004UL
+#define RAWIP_SOCKET__CREATE                      0x00000008UL
+#define RAWIP_SOCKET__GETATTR                     0x00000010UL
+#define RAWIP_SOCKET__SETATTR                     0x00000020UL
+#define RAWIP_SOCKET__LOCK                        0x00000040UL
+#define RAWIP_SOCKET__RELABELFROM                 0x00000080UL
+#define RAWIP_SOCKET__RELABELTO                   0x00000100UL
+#define RAWIP_SOCKET__APPEND                      0x00000200UL
+#define RAWIP_SOCKET__BIND                        0x00000400UL
+#define RAWIP_SOCKET__CONNECT                     0x00000800UL
+#define RAWIP_SOCKET__LISTEN                      0x00001000UL
+#define RAWIP_SOCKET__ACCEPT                      0x00002000UL
+#define RAWIP_SOCKET__GETOPT                      0x00004000UL
+#define RAWIP_SOCKET__SETOPT                      0x00008000UL
+#define RAWIP_SOCKET__SHUTDOWN                    0x00010000UL
+#define RAWIP_SOCKET__RECVFROM                    0x00020000UL
+#define RAWIP_SOCKET__SENDTO                      0x00040000UL
+#define RAWIP_SOCKET__RECV_MSG                    0x00080000UL
+#define RAWIP_SOCKET__SEND_MSG                    0x00100000UL
+#define RAWIP_SOCKET__NAME_BIND                   0x00200000UL
+#define RAWIP_SOCKET__NODE_BIND                   0x00400000UL
+#define NODE__TCP_RECV                            0x00000001UL
+#define NODE__TCP_SEND                            0x00000002UL
+#define NODE__UDP_RECV                            0x00000004UL
+#define NODE__UDP_SEND                            0x00000008UL
+#define NODE__RAWIP_RECV                          0x00000010UL
+#define NODE__RAWIP_SEND                          0x00000020UL
+#define NODE__ENFORCE_DEST                        0x00000040UL
+#define NODE__DCCP_RECV                           0x00000080UL
+#define NODE__DCCP_SEND                           0x00000100UL
+#define NODE__RECVFROM                            0x00000200UL
+#define NODE__SENDTO                              0x00000400UL
+#define NETIF__TCP_RECV                           0x00000001UL
+#define NETIF__TCP_SEND                           0x00000002UL
+#define NETIF__UDP_RECV                           0x00000004UL
+#define NETIF__UDP_SEND                           0x00000008UL
+#define NETIF__RAWIP_RECV                         0x00000010UL
+#define NETIF__RAWIP_SEND                         0x00000020UL
+#define NETIF__DCCP_RECV                          0x00000040UL
+#define NETIF__DCCP_SEND                          0x00000080UL
+#define NETIF__INGRESS                            0x00000100UL
+#define NETIF__EGRESS                             0x00000200UL
+#define NETLINK_SOCKET__IOCTL                     0x00000001UL
+#define NETLINK_SOCKET__READ                      0x00000002UL
+#define NETLINK_SOCKET__WRITE                     0x00000004UL
+#define NETLINK_SOCKET__CREATE                    0x00000008UL
+#define NETLINK_SOCKET__GETATTR                   0x00000010UL
+#define NETLINK_SOCKET__SETATTR                   0x00000020UL
+#define NETLINK_SOCKET__LOCK                      0x00000040UL
+#define NETLINK_SOCKET__RELABELFROM               0x00000080UL
+#define NETLINK_SOCKET__RELABELTO                 0x00000100UL
+#define NETLINK_SOCKET__APPEND                    0x00000200UL
+#define NETLINK_SOCKET__BIND                      0x00000400UL
+#define NETLINK_SOCKET__CONNECT                   0x00000800UL
+#define NETLINK_SOCKET__LISTEN                    0x00001000UL
+#define NETLINK_SOCKET__ACCEPT                    0x00002000UL
+#define NETLINK_SOCKET__GETOPT                    0x00004000UL
+#define NETLINK_SOCKET__SETOPT                    0x00008000UL
+#define NETLINK_SOCKET__SHUTDOWN                  0x00010000UL
+#define NETLINK_SOCKET__RECVFROM                  0x00020000UL
+#define NETLINK_SOCKET__SENDTO                    0x00040000UL
+#define NETLINK_SOCKET__RECV_MSG                  0x00080000UL
+#define NETLINK_SOCKET__SEND_MSG                  0x00100000UL
+#define NETLINK_SOCKET__NAME_BIND                 0x00200000UL
+#define PACKET_SOCKET__IOCTL                      0x00000001UL
+#define PACKET_SOCKET__READ                       0x00000002UL
+#define PACKET_SOCKET__WRITE                      0x00000004UL
+#define PACKET_SOCKET__CREATE                     0x00000008UL
+#define PACKET_SOCKET__GETATTR                    0x00000010UL
+#define PACKET_SOCKET__SETATTR                    0x00000020UL
+#define PACKET_SOCKET__LOCK                       0x00000040UL
+#define PACKET_SOCKET__RELABELFROM                0x00000080UL
+#define PACKET_SOCKET__RELABELTO                  0x00000100UL
+#define PACKET_SOCKET__APPEND                     0x00000200UL
+#define PACKET_SOCKET__BIND                       0x00000400UL
+#define PACKET_SOCKET__CONNECT                    0x00000800UL
+#define PACKET_SOCKET__LISTEN                     0x00001000UL
+#define PACKET_SOCKET__ACCEPT                     0x00002000UL
+#define PACKET_SOCKET__GETOPT                     0x00004000UL
+#define PACKET_SOCKET__SETOPT                     0x00008000UL
+#define PACKET_SOCKET__SHUTDOWN                   0x00010000UL
+#define PACKET_SOCKET__RECVFROM                   0x00020000UL
+#define PACKET_SOCKET__SENDTO                     0x00040000UL
+#define PACKET_SOCKET__RECV_MSG                   0x00080000UL
+#define PACKET_SOCKET__SEND_MSG                   0x00100000UL
+#define PACKET_SOCKET__NAME_BIND                  0x00200000UL
+#define KEY_SOCKET__IOCTL                         0x00000001UL
+#define KEY_SOCKET__READ                          0x00000002UL
+#define KEY_SOCKET__WRITE                         0x00000004UL
+#define KEY_SOCKET__CREATE                        0x00000008UL
+#define KEY_SOCKET__GETATTR                       0x00000010UL
+#define KEY_SOCKET__SETATTR                       0x00000020UL
+#define KEY_SOCKET__LOCK                          0x00000040UL
+#define KEY_SOCKET__RELABELFROM                   0x00000080UL
+#define KEY_SOCKET__RELABELTO                     0x00000100UL
+#define KEY_SOCKET__APPEND                        0x00000200UL
+#define KEY_SOCKET__BIND                          0x00000400UL
+#define KEY_SOCKET__CONNECT                       0x00000800UL
+#define KEY_SOCKET__LISTEN                        0x00001000UL
+#define KEY_SOCKET__ACCEPT                        0x00002000UL
+#define KEY_SOCKET__GETOPT                        0x00004000UL
+#define KEY_SOCKET__SETOPT                        0x00008000UL
+#define KEY_SOCKET__SHUTDOWN                      0x00010000UL
+#define KEY_SOCKET__RECVFROM                      0x00020000UL
+#define KEY_SOCKET__SENDTO                        0x00040000UL
+#define KEY_SOCKET__RECV_MSG                      0x00080000UL
+#define KEY_SOCKET__SEND_MSG                      0x00100000UL
+#define KEY_SOCKET__NAME_BIND                     0x00200000UL
+#define UNIX_STREAM_SOCKET__IOCTL                 0x00000001UL
+#define UNIX_STREAM_SOCKET__READ                  0x00000002UL
+#define UNIX_STREAM_SOCKET__WRITE                 0x00000004UL
+#define UNIX_STREAM_SOCKET__CREATE                0x00000008UL
+#define UNIX_STREAM_SOCKET__GETATTR               0x00000010UL
+#define UNIX_STREAM_SOCKET__SETATTR               0x00000020UL
+#define UNIX_STREAM_SOCKET__LOCK                  0x00000040UL
+#define UNIX_STREAM_SOCKET__RELABELFROM           0x00000080UL
+#define UNIX_STREAM_SOCKET__RELABELTO             0x00000100UL
+#define UNIX_STREAM_SOCKET__APPEND                0x00000200UL
+#define UNIX_STREAM_SOCKET__BIND                  0x00000400UL
+#define UNIX_STREAM_SOCKET__CONNECT               0x00000800UL
+#define UNIX_STREAM_SOCKET__LISTEN                0x00001000UL
+#define UNIX_STREAM_SOCKET__ACCEPT                0x00002000UL
+#define UNIX_STREAM_SOCKET__GETOPT                0x00004000UL
+#define UNIX_STREAM_SOCKET__SETOPT                0x00008000UL
+#define UNIX_STREAM_SOCKET__SHUTDOWN              0x00010000UL
+#define UNIX_STREAM_SOCKET__RECVFROM              0x00020000UL
+#define UNIX_STREAM_SOCKET__SENDTO                0x00040000UL
+#define UNIX_STREAM_SOCKET__RECV_MSG              0x00080000UL
+#define UNIX_STREAM_SOCKET__SEND_MSG              0x00100000UL
+#define UNIX_STREAM_SOCKET__NAME_BIND             0x00200000UL
+#define UNIX_STREAM_SOCKET__CONNECTTO             0x00400000UL
+#define UNIX_STREAM_SOCKET__NEWCONN               0x00800000UL
+#define UNIX_STREAM_SOCKET__ACCEPTFROM            0x01000000UL
+#define UNIX_DGRAM_SOCKET__IOCTL                  0x00000001UL
+#define UNIX_DGRAM_SOCKET__READ                   0x00000002UL
+#define UNIX_DGRAM_SOCKET__WRITE                  0x00000004UL
+#define UNIX_DGRAM_SOCKET__CREATE                 0x00000008UL
+#define UNIX_DGRAM_SOCKET__GETATTR                0x00000010UL
+#define UNIX_DGRAM_SOCKET__SETATTR                0x00000020UL
+#define UNIX_DGRAM_SOCKET__LOCK                   0x00000040UL
+#define UNIX_DGRAM_SOCKET__RELABELFROM            0x00000080UL
+#define UNIX_DGRAM_SOCKET__RELABELTO              0x00000100UL
+#define UNIX_DGRAM_SOCKET__APPEND                 0x00000200UL
+#define UNIX_DGRAM_SOCKET__BIND                   0x00000400UL
+#define UNIX_DGRAM_SOCKET__CONNECT                0x00000800UL
+#define UNIX_DGRAM_SOCKET__LISTEN                 0x00001000UL
+#define UNIX_DGRAM_SOCKET__ACCEPT                 0x00002000UL
+#define UNIX_DGRAM_SOCKET__GETOPT                 0x00004000UL
+#define UNIX_DGRAM_SOCKET__SETOPT                 0x00008000UL
+#define UNIX_DGRAM_SOCKET__SHUTDOWN               0x00010000UL
+#define UNIX_DGRAM_SOCKET__RECVFROM               0x00020000UL
+#define UNIX_DGRAM_SOCKET__SENDTO                 0x00040000UL
+#define UNIX_DGRAM_SOCKET__RECV_MSG               0x00080000UL
+#define UNIX_DGRAM_SOCKET__SEND_MSG               0x00100000UL
+#define UNIX_DGRAM_SOCKET__NAME_BIND              0x00200000UL
+#define PROCESS__FORK                             0x00000001UL
+#define PROCESS__TRANSITION                       0x00000002UL
+#define PROCESS__SIGCHLD                          0x00000004UL
+#define PROCESS__SIGKILL                          0x00000008UL
+#define PROCESS__SIGSTOP                          0x00000010UL
+#define PROCESS__SIGNULL                          0x00000020UL
+#define PROCESS__SIGNAL                           0x00000040UL
+#define PROCESS__PTRACE                           0x00000080UL
+#define PROCESS__GETSCHED                         0x00000100UL
+#define PROCESS__SETSCHED                         0x00000200UL
+#define PROCESS__GETSESSION                       0x00000400UL
+#define PROCESS__GETPGID                          0x00000800UL
+#define PROCESS__SETPGID                          0x00001000UL
+#define PROCESS__GETCAP                           0x00002000UL
+#define PROCESS__SETCAP                           0x00004000UL
+#define PROCESS__SHARE                            0x00008000UL
+#define PROCESS__GETATTR                          0x00010000UL
+#define PROCESS__SETEXEC                          0x00020000UL
+#define PROCESS__SETFSCREATE                      0x00040000UL
+#define PROCESS__NOATSECURE                       0x00080000UL
+#define PROCESS__SIGINH                           0x00100000UL
+#define PROCESS__SETRLIMIT                        0x00200000UL
+#define PROCESS__RLIMITINH                        0x00400000UL
+#define PROCESS__DYNTRANSITION                    0x00800000UL
+#define PROCESS__SETCURRENT                       0x01000000UL
+#define PROCESS__EXECMEM                          0x02000000UL
+#define PROCESS__EXECSTACK                        0x04000000UL
+#define PROCESS__EXECHEAP                         0x08000000UL
+#define PROCESS__SETKEYCREATE                     0x10000000UL
+#define PROCESS__SETSOCKCREATE                    0x20000000UL
+#define IPC__CREATE                               0x00000001UL
+#define IPC__DESTROY                              0x00000002UL
+#define IPC__GETATTR                              0x00000004UL
+#define IPC__SETATTR                              0x00000008UL
+#define IPC__READ                                 0x00000010UL
+#define IPC__WRITE                                0x00000020UL
+#define IPC__ASSOCIATE                            0x00000040UL
+#define IPC__UNIX_READ                            0x00000080UL
+#define IPC__UNIX_WRITE                           0x00000100UL
+#define SEM__CREATE                               0x00000001UL
+#define SEM__DESTROY                              0x00000002UL
+#define SEM__GETATTR                              0x00000004UL
+#define SEM__SETATTR                              0x00000008UL
+#define SEM__READ                                 0x00000010UL
+#define SEM__WRITE                                0x00000020UL
+#define SEM__ASSOCIATE                            0x00000040UL
+#define SEM__UNIX_READ                            0x00000080UL
+#define SEM__UNIX_WRITE                           0x00000100UL
+#define MSGQ__CREATE                              0x00000001UL
+#define MSGQ__DESTROY                             0x00000002UL
+#define MSGQ__GETATTR                             0x00000004UL
+#define MSGQ__SETATTR                             0x00000008UL
+#define MSGQ__READ                                0x00000010UL
+#define MSGQ__WRITE                               0x00000020UL
+#define MSGQ__ASSOCIATE                           0x00000040UL
+#define MSGQ__UNIX_READ                           0x00000080UL
+#define MSGQ__UNIX_WRITE                          0x00000100UL
+#define MSGQ__ENQUEUE                             0x00000200UL
+#define MSG__SEND                                 0x00000001UL
+#define MSG__RECEIVE                              0x00000002UL
+#define SHM__CREATE                               0x00000001UL
+#define SHM__DESTROY                              0x00000002UL
+#define SHM__GETATTR                              0x00000004UL
+#define SHM__SETATTR                              0x00000008UL
+#define SHM__READ                                 0x00000010UL
+#define SHM__WRITE                                0x00000020UL
+#define SHM__ASSOCIATE                            0x00000040UL
+#define SHM__UNIX_READ                            0x00000080UL
+#define SHM__UNIX_WRITE                           0x00000100UL
+#define SHM__LOCK                                 0x00000200UL
+#define SECURITY__COMPUTE_AV                      0x00000001UL
+#define SECURITY__COMPUTE_CREATE                  0x00000002UL
+#define SECURITY__COMPUTE_MEMBER                  0x00000004UL
+#define SECURITY__CHECK_CONTEXT                   0x00000008UL
+#define SECURITY__LOAD_POLICY                     0x00000010UL
+#define SECURITY__COMPUTE_RELABEL                 0x00000020UL
+#define SECURITY__COMPUTE_USER                    0x00000040UL
+#define SECURITY__SETENFORCE                      0x00000080UL
+#define SECURITY__SETBOOL                         0x00000100UL
+#define SECURITY__SETSECPARAM                     0x00000200UL
+#define SECURITY__SETCHECKREQPROT                 0x00000400UL
+#define SYSTEM__IPC_INFO                          0x00000001UL
+#define SYSTEM__SYSLOG_READ                       0x00000002UL
+#define SYSTEM__SYSLOG_MOD                        0x00000004UL
+#define SYSTEM__SYSLOG_CONSOLE                    0x00000008UL
+#define CAPABILITY__CHOWN                         0x00000001UL
+#define CAPABILITY__DAC_OVERRIDE                  0x00000002UL
+#define CAPABILITY__DAC_READ_SEARCH               0x00000004UL
+#define CAPABILITY__FOWNER                        0x00000008UL
+#define CAPABILITY__FSETID                        0x00000010UL
+#define CAPABILITY__KILL                          0x00000020UL
+#define CAPABILITY__SETGID                        0x00000040UL
+#define CAPABILITY__SETUID                        0x00000080UL
+#define CAPABILITY__SETPCAP                       0x00000100UL
+#define CAPABILITY__LINUX_IMMUTABLE               0x00000200UL
+#define CAPABILITY__NET_BIND_SERVICE              0x00000400UL
+#define CAPABILITY__NET_BROADCAST                 0x00000800UL
+#define CAPABILITY__NET_ADMIN                     0x00001000UL
+#define CAPABILITY__NET_RAW                       0x00002000UL
+#define CAPABILITY__IPC_LOCK                      0x00004000UL
+#define CAPABILITY__IPC_OWNER                     0x00008000UL
+#define CAPABILITY__SYS_MODULE                    0x00010000UL
+#define CAPABILITY__SYS_RAWIO                     0x00020000UL
+#define CAPABILITY__SYS_CHROOT                    0x00040000UL
+#define CAPABILITY__SYS_PTRACE                    0x00080000UL
+#define CAPABILITY__SYS_PACCT                     0x00100000UL
+#define CAPABILITY__SYS_ADMIN                     0x00200000UL
+#define CAPABILITY__SYS_BOOT                      0x00400000UL
+#define CAPABILITY__SYS_NICE                      0x00800000UL
+#define CAPABILITY__SYS_RESOURCE                  0x01000000UL
+#define CAPABILITY__SYS_TIME                      0x02000000UL
+#define CAPABILITY__SYS_TTY_CONFIG                0x04000000UL
+#define CAPABILITY__MKNOD                         0x08000000UL
+#define CAPABILITY__LEASE                         0x10000000UL
+#define CAPABILITY__AUDIT_WRITE                   0x20000000UL
+#define CAPABILITY__AUDIT_CONTROL                 0x40000000UL
+#define CAPABILITY__SETFCAP                       0x80000000UL
+#define CAPABILITY2__MAC_OVERRIDE                 0x00000001UL
+#define CAPABILITY2__MAC_ADMIN                    0x00000002UL
+#define PASSWD__PASSWD                            0x00000001UL
+#define PASSWD__CHFN                              0x00000002UL
+#define PASSWD__CHSH                              0x00000004UL
+#define PASSWD__ROOTOK                            0x00000008UL
+#define PASSWD__CRONTAB                           0x00000010UL
+#define X_DRAWABLE__CREATE                        0x00000001UL
+#define X_DRAWABLE__DESTROY                       0x00000002UL
+#define X_DRAWABLE__READ                          0x00000004UL
+#define X_DRAWABLE__WRITE                         0x00000008UL
+#define X_DRAWABLE__BLEND                         0x00000010UL
+#define X_DRAWABLE__GETATTR                       0x00000020UL
+#define X_DRAWABLE__SETATTR                       0x00000040UL
+#define X_DRAWABLE__LIST_CHILD                    0x00000080UL
+#define X_DRAWABLE__ADD_CHILD                     0x00000100UL
+#define X_DRAWABLE__REMOVE_CHILD                  0x00000200UL
+#define X_DRAWABLE__LIST_PROPERTY                 0x00000400UL
+#define X_DRAWABLE__GET_PROPERTY                  0x00000800UL
+#define X_DRAWABLE__SET_PROPERTY                  0x00001000UL
+#define X_DRAWABLE__MANAGE                        0x00002000UL
+#define X_DRAWABLE__OVERRIDE                      0x00004000UL
+#define X_DRAWABLE__SHOW                          0x00008000UL
+#define X_DRAWABLE__HIDE                          0x00010000UL
+#define X_DRAWABLE__SEND                          0x00020000UL
+#define X_DRAWABLE__RECEIVE                       0x00040000UL
+#define X_SCREEN__GETATTR                         0x00000001UL
+#define X_SCREEN__SETATTR                         0x00000002UL
+#define X_SCREEN__HIDE_CURSOR                     0x00000004UL
+#define X_SCREEN__SHOW_CURSOR                     0x00000008UL
+#define X_SCREEN__SAVER_GETATTR                   0x00000010UL
+#define X_SCREEN__SAVER_SETATTR                   0x00000020UL
+#define X_SCREEN__SAVER_HIDE                      0x00000040UL
+#define X_SCREEN__SAVER_SHOW                      0x00000080UL
+#define X_GC__CREATE                              0x00000001UL
+#define X_GC__DESTROY                             0x00000002UL
+#define X_GC__GETATTR                             0x00000004UL
+#define X_GC__SETATTR                             0x00000008UL
+#define X_GC__USE                                 0x00000010UL
+#define X_FONT__CREATE                            0x00000001UL
+#define X_FONT__DESTROY                           0x00000002UL
+#define X_FONT__GETATTR                           0x00000004UL
+#define X_FONT__ADD_GLYPH                         0x00000008UL
+#define X_FONT__REMOVE_GLYPH                      0x00000010UL
+#define X_FONT__USE                               0x00000020UL
+#define X_COLORMAP__CREATE                        0x00000001UL
+#define X_COLORMAP__DESTROY                       0x00000002UL
+#define X_COLORMAP__READ                          0x00000004UL
+#define X_COLORMAP__WRITE                         0x00000008UL
+#define X_COLORMAP__GETATTR                       0x00000010UL
+#define X_COLORMAP__ADD_COLOR                     0x00000020UL
+#define X_COLORMAP__REMOVE_COLOR                  0x00000040UL
+#define X_COLORMAP__INSTALL                       0x00000080UL
+#define X_COLORMAP__UNINSTALL                     0x00000100UL
+#define X_COLORMAP__USE                           0x00000200UL
+#define X_PROPERTY__CREATE                        0x00000001UL
+#define X_PROPERTY__DESTROY                       0x00000002UL
+#define X_PROPERTY__READ                          0x00000004UL
+#define X_PROPERTY__WRITE                         0x00000008UL
+#define X_PROPERTY__APPEND                        0x00000010UL
+#define X_PROPERTY__GETATTR                       0x00000020UL
+#define X_PROPERTY__SETATTR                       0x00000040UL
+#define X_SELECTION__READ                         0x00000001UL
+#define X_SELECTION__WRITE                        0x00000002UL
+#define X_SELECTION__GETATTR                      0x00000004UL
+#define X_SELECTION__SETATTR                      0x00000008UL
+#define X_CURSOR__CREATE                          0x00000001UL
+#define X_CURSOR__DESTROY                         0x00000002UL
+#define X_CURSOR__READ                            0x00000004UL
+#define X_CURSOR__WRITE                           0x00000008UL
+#define X_CURSOR__GETATTR                         0x00000010UL
+#define X_CURSOR__SETATTR                         0x00000020UL
+#define X_CURSOR__USE                             0x00000040UL
+#define X_CLIENT__DESTROY                         0x00000001UL
+#define X_CLIENT__GETATTR                         0x00000002UL
+#define X_CLIENT__SETATTR                         0x00000004UL
+#define X_CLIENT__MANAGE                          0x00000008UL
+#define X_DEVICE__GETATTR                         0x00000001UL
+#define X_DEVICE__SETATTR                         0x00000002UL
+#define X_DEVICE__USE                             0x00000004UL
+#define X_DEVICE__READ                            0x00000008UL
+#define X_DEVICE__WRITE                           0x00000010UL
+#define X_DEVICE__GETFOCUS                        0x00000020UL
+#define X_DEVICE__SETFOCUS                        0x00000040UL
+#define X_DEVICE__BELL                            0x00000080UL
+#define X_DEVICE__FORCE_CURSOR                    0x00000100UL
+#define X_DEVICE__FREEZE                          0x00000200UL
+#define X_DEVICE__GRAB                            0x00000400UL
+#define X_DEVICE__MANAGE                          0x00000800UL
+#define X_SERVER__GETATTR                         0x00000001UL
+#define X_SERVER__SETATTR                         0x00000002UL
+#define X_SERVER__RECORD                          0x00000004UL
+#define X_SERVER__DEBUG                           0x00000008UL
+#define X_SERVER__GRAB                            0x00000010UL
+#define X_SERVER__MANAGE                          0x00000020UL
+#define X_EXTENSION__QUERY                        0x00000001UL
+#define X_EXTENSION__USE                          0x00000002UL
+#define X_RESOURCE__READ                          0x00000001UL
+#define X_RESOURCE__WRITE                         0x00000002UL
+#define X_EVENT__SEND                             0x00000001UL
+#define X_EVENT__RECEIVE                          0x00000002UL
+#define X_SYNTHETIC_EVENT__SEND                   0x00000001UL
+#define X_SYNTHETIC_EVENT__RECEIVE                0x00000002UL
+#define NETLINK_ROUTE_SOCKET__IOCTL               0x00000001UL
+#define NETLINK_ROUTE_SOCKET__READ                0x00000002UL
+#define NETLINK_ROUTE_SOCKET__WRITE               0x00000004UL
+#define NETLINK_ROUTE_SOCKET__CREATE              0x00000008UL
+#define NETLINK_ROUTE_SOCKET__GETATTR             0x00000010UL
+#define NETLINK_ROUTE_SOCKET__SETATTR             0x00000020UL
+#define NETLINK_ROUTE_SOCKET__LOCK                0x00000040UL
+#define NETLINK_ROUTE_SOCKET__RELABELFROM         0x00000080UL
+#define NETLINK_ROUTE_SOCKET__RELABELTO           0x00000100UL
+#define NETLINK_ROUTE_SOCKET__APPEND              0x00000200UL
+#define NETLINK_ROUTE_SOCKET__BIND                0x00000400UL
+#define NETLINK_ROUTE_SOCKET__CONNECT             0x00000800UL
+#define NETLINK_ROUTE_SOCKET__LISTEN              0x00001000UL
+#define NETLINK_ROUTE_SOCKET__ACCEPT              0x00002000UL
+#define NETLINK_ROUTE_SOCKET__GETOPT              0x00004000UL
+#define NETLINK_ROUTE_SOCKET__SETOPT              0x00008000UL
+#define NETLINK_ROUTE_SOCKET__SHUTDOWN            0x00010000UL
+#define NETLINK_ROUTE_SOCKET__RECVFROM            0x00020000UL
+#define NETLINK_ROUTE_SOCKET__SENDTO              0x00040000UL
+#define NETLINK_ROUTE_SOCKET__RECV_MSG            0x00080000UL
+#define NETLINK_ROUTE_SOCKET__SEND_MSG            0x00100000UL
+#define NETLINK_ROUTE_SOCKET__NAME_BIND           0x00200000UL
+#define NETLINK_ROUTE_SOCKET__NLMSG_READ          0x00400000UL
+#define NETLINK_ROUTE_SOCKET__NLMSG_WRITE         0x00800000UL
+#define NETLINK_FIREWALL_SOCKET__IOCTL            0x00000001UL
+#define NETLINK_FIREWALL_SOCKET__READ             0x00000002UL
+#define NETLINK_FIREWALL_SOCKET__WRITE            0x00000004UL
+#define NETLINK_FIREWALL_SOCKET__CREATE           0x00000008UL
+#define NETLINK_FIREWALL_SOCKET__GETATTR          0x00000010UL
+#define NETLINK_FIREWALL_SOCKET__SETATTR          0x00000020UL
+#define NETLINK_FIREWALL_SOCKET__LOCK             0x00000040UL
+#define NETLINK_FIREWALL_SOCKET__RELABELFROM      0x00000080UL
+#define NETLINK_FIREWALL_SOCKET__RELABELTO        0x00000100UL
+#define NETLINK_FIREWALL_SOCKET__APPEND           0x00000200UL
+#define NETLINK_FIREWALL_SOCKET__BIND             0x00000400UL
+#define NETLINK_FIREWALL_SOCKET__CONNECT          0x00000800UL
+#define NETLINK_FIREWALL_SOCKET__LISTEN           0x00001000UL
+#define NETLINK_FIREWALL_SOCKET__ACCEPT           0x00002000UL
+#define NETLINK_FIREWALL_SOCKET__GETOPT           0x00004000UL
+#define NETLINK_FIREWALL_SOCKET__SETOPT           0x00008000UL
+#define NETLINK_FIREWALL_SOCKET__SHUTDOWN         0x00010000UL
+#define NETLINK_FIREWALL_SOCKET__RECVFROM         0x00020000UL
+#define NETLINK_FIREWALL_SOCKET__SENDTO           0x00040000UL
+#define NETLINK_FIREWALL_SOCKET__RECV_MSG         0x00080000UL
+#define NETLINK_FIREWALL_SOCKET__SEND_MSG         0x00100000UL
+#define NETLINK_FIREWALL_SOCKET__NAME_BIND        0x00200000UL
+#define NETLINK_FIREWALL_SOCKET__NLMSG_READ       0x00400000UL
+#define NETLINK_FIREWALL_SOCKET__NLMSG_WRITE      0x00800000UL
+#define NETLINK_TCPDIAG_SOCKET__IOCTL             0x00000001UL
+#define NETLINK_TCPDIAG_SOCKET__READ              0x00000002UL
+#define NETLINK_TCPDIAG_SOCKET__WRITE             0x00000004UL
+#define NETLINK_TCPDIAG_SOCKET__CREATE            0x00000008UL
+#define NETLINK_TCPDIAG_SOCKET__GETATTR           0x00000010UL
+#define NETLINK_TCPDIAG_SOCKET__SETATTR           0x00000020UL
+#define NETLINK_TCPDIAG_SOCKET__LOCK              0x00000040UL
+#define NETLINK_TCPDIAG_SOCKET__RELABELFROM       0x00000080UL
+#define NETLINK_TCPDIAG_SOCKET__RELABELTO         0x00000100UL
+#define NETLINK_TCPDIAG_SOCKET__APPEND            0x00000200UL
+#define NETLINK_TCPDIAG_SOCKET__BIND              0x00000400UL
+#define NETLINK_TCPDIAG_SOCKET__CONNECT           0x00000800UL
+#define NETLINK_TCPDIAG_SOCKET__LISTEN            0x00001000UL
+#define NETLINK_TCPDIAG_SOCKET__ACCEPT            0x00002000UL
+#define NETLINK_TCPDIAG_SOCKET__GETOPT            0x00004000UL
+#define NETLINK_TCPDIAG_SOCKET__SETOPT            0x00008000UL
+#define NETLINK_TCPDIAG_SOCKET__SHUTDOWN          0x00010000UL
+#define NETLINK_TCPDIAG_SOCKET__RECVFROM          0x00020000UL
+#define NETLINK_TCPDIAG_SOCKET__SENDTO            0x00040000UL
+#define NETLINK_TCPDIAG_SOCKET__RECV_MSG          0x00080000UL
+#define NETLINK_TCPDIAG_SOCKET__SEND_MSG          0x00100000UL
+#define NETLINK_TCPDIAG_SOCKET__NAME_BIND         0x00200000UL
+#define NETLINK_TCPDIAG_SOCKET__NLMSG_READ        0x00400000UL
+#define NETLINK_TCPDIAG_SOCKET__NLMSG_WRITE       0x00800000UL
+#define NETLINK_NFLOG_SOCKET__IOCTL               0x00000001UL
+#define NETLINK_NFLOG_SOCKET__READ                0x00000002UL
+#define NETLINK_NFLOG_SOCKET__WRITE               0x00000004UL
+#define NETLINK_NFLOG_SOCKET__CREATE              0x00000008UL
+#define NETLINK_NFLOG_SOCKET__GETATTR             0x00000010UL
+#define NETLINK_NFLOG_SOCKET__SETATTR             0x00000020UL
+#define NETLINK_NFLOG_SOCKET__LOCK                0x00000040UL
+#define NETLINK_NFLOG_SOCKET__RELABELFROM         0x00000080UL
+#define NETLINK_NFLOG_SOCKET__RELABELTO           0x00000100UL
+#define NETLINK_NFLOG_SOCKET__APPEND              0x00000200UL
+#define NETLINK_NFLOG_SOCKET__BIND                0x00000400UL
+#define NETLINK_NFLOG_SOCKET__CONNECT             0x00000800UL
+#define NETLINK_NFLOG_SOCKET__LISTEN              0x00001000UL
+#define NETLINK_NFLOG_SOCKET__ACCEPT              0x00002000UL
+#define NETLINK_NFLOG_SOCKET__GETOPT              0x00004000UL
+#define NETLINK_NFLOG_SOCKET__SETOPT              0x00008000UL
+#define NETLINK_NFLOG_SOCKET__SHUTDOWN            0x00010000UL
+#define NETLINK_NFLOG_SOCKET__RECVFROM            0x00020000UL
+#define NETLINK_NFLOG_SOCKET__SENDTO              0x00040000UL
+#define NETLINK_NFLOG_SOCKET__RECV_MSG            0x00080000UL
+#define NETLINK_NFLOG_SOCKET__SEND_MSG            0x00100000UL
+#define NETLINK_NFLOG_SOCKET__NAME_BIND           0x00200000UL
+#define NETLINK_XFRM_SOCKET__IOCTL                0x00000001UL
+#define NETLINK_XFRM_SOCKET__READ                 0x00000002UL
+#define NETLINK_XFRM_SOCKET__WRITE                0x00000004UL
+#define NETLINK_XFRM_SOCKET__CREATE               0x00000008UL
+#define NETLINK_XFRM_SOCKET__GETATTR              0x00000010UL
+#define NETLINK_XFRM_SOCKET__SETATTR              0x00000020UL
+#define NETLINK_XFRM_SOCKET__LOCK                 0x00000040UL
+#define NETLINK_XFRM_SOCKET__RELABELFROM          0x00000080UL
+#define NETLINK_XFRM_SOCKET__RELABELTO            0x00000100UL
+#define NETLINK_XFRM_SOCKET__APPEND               0x00000200UL
+#define NETLINK_XFRM_SOCKET__BIND                 0x00000400UL
+#define NETLINK_XFRM_SOCKET__CONNECT              0x00000800UL
+#define NETLINK_XFRM_SOCKET__LISTEN               0x00001000UL
+#define NETLINK_XFRM_SOCKET__ACCEPT               0x00002000UL
+#define NETLINK_XFRM_SOCKET__GETOPT               0x00004000UL
+#define NETLINK_XFRM_SOCKET__SETOPT               0x00008000UL
+#define NETLINK_XFRM_SOCKET__SHUTDOWN             0x00010000UL
+#define NETLINK_XFRM_SOCKET__RECVFROM             0x00020000UL
+#define NETLINK_XFRM_SOCKET__SENDTO               0x00040000UL
+#define NETLINK_XFRM_SOCKET__RECV_MSG             0x00080000UL
+#define NETLINK_XFRM_SOCKET__SEND_MSG             0x00100000UL
+#define NETLINK_XFRM_SOCKET__NAME_BIND            0x00200000UL
+#define NETLINK_XFRM_SOCKET__NLMSG_READ           0x00400000UL
+#define NETLINK_XFRM_SOCKET__NLMSG_WRITE          0x00800000UL
+#define NETLINK_SELINUX_SOCKET__IOCTL             0x00000001UL
+#define NETLINK_SELINUX_SOCKET__READ              0x00000002UL
+#define NETLINK_SELINUX_SOCKET__WRITE             0x00000004UL
+#define NETLINK_SELINUX_SOCKET__CREATE            0x00000008UL
+#define NETLINK_SELINUX_SOCKET__GETATTR           0x00000010UL
+#define NETLINK_SELINUX_SOCKET__SETATTR           0x00000020UL
+#define NETLINK_SELINUX_SOCKET__LOCK              0x00000040UL
+#define NETLINK_SELINUX_SOCKET__RELABELFROM       0x00000080UL
+#define NETLINK_SELINUX_SOCKET__RELABELTO         0x00000100UL
+#define NETLINK_SELINUX_SOCKET__APPEND            0x00000200UL
+#define NETLINK_SELINUX_SOCKET__BIND              0x00000400UL
+#define NETLINK_SELINUX_SOCKET__CONNECT           0x00000800UL
+#define NETLINK_SELINUX_SOCKET__LISTEN            0x00001000UL
+#define NETLINK_SELINUX_SOCKET__ACCEPT            0x00002000UL
+#define NETLINK_SELINUX_SOCKET__GETOPT            0x00004000UL
+#define NETLINK_SELINUX_SOCKET__SETOPT            0x00008000UL
+#define NETLINK_SELINUX_SOCKET__SHUTDOWN          0x00010000UL
+#define NETLINK_SELINUX_SOCKET__RECVFROM          0x00020000UL
+#define NETLINK_SELINUX_SOCKET__SENDTO            0x00040000UL
+#define NETLINK_SELINUX_SOCKET__RECV_MSG          0x00080000UL
+#define NETLINK_SELINUX_SOCKET__SEND_MSG          0x00100000UL
+#define NETLINK_SELINUX_SOCKET__NAME_BIND         0x00200000UL
+#define NETLINK_AUDIT_SOCKET__IOCTL               0x00000001UL
+#define NETLINK_AUDIT_SOCKET__READ                0x00000002UL
+#define NETLINK_AUDIT_SOCKET__WRITE               0x00000004UL
+#define NETLINK_AUDIT_SOCKET__CREATE              0x00000008UL
+#define NETLINK_AUDIT_SOCKET__GETATTR             0x00000010UL
+#define NETLINK_AUDIT_SOCKET__SETATTR             0x00000020UL
+#define NETLINK_AUDIT_SOCKET__LOCK                0x00000040UL
+#define NETLINK_AUDIT_SOCKET__RELABELFROM         0x00000080UL
+#define NETLINK_AUDIT_SOCKET__RELABELTO           0x00000100UL
+#define NETLINK_AUDIT_SOCKET__APPEND              0x00000200UL
+#define NETLINK_AUDIT_SOCKET__BIND                0x00000400UL
+#define NETLINK_AUDIT_SOCKET__CONNECT             0x00000800UL
+#define NETLINK_AUDIT_SOCKET__LISTEN              0x00001000UL
+#define NETLINK_AUDIT_SOCKET__ACCEPT              0x00002000UL
+#define NETLINK_AUDIT_SOCKET__GETOPT              0x00004000UL
+#define NETLINK_AUDIT_SOCKET__SETOPT              0x00008000UL
+#define NETLINK_AUDIT_SOCKET__SHUTDOWN            0x00010000UL
+#define NETLINK_AUDIT_SOCKET__RECVFROM            0x00020000UL
+#define NETLINK_AUDIT_SOCKET__SENDTO              0x00040000UL
+#define NETLINK_AUDIT_SOCKET__RECV_MSG            0x00080000UL
+#define NETLINK_AUDIT_SOCKET__SEND_MSG            0x00100000UL
+#define NETLINK_AUDIT_SOCKET__NAME_BIND           0x00200000UL
+#define NETLINK_AUDIT_SOCKET__NLMSG_READ          0x00400000UL
+#define NETLINK_AUDIT_SOCKET__NLMSG_WRITE         0x00800000UL
+#define NETLINK_AUDIT_SOCKET__NLMSG_RELAY         0x01000000UL
+#define NETLINK_AUDIT_SOCKET__NLMSG_READPRIV      0x02000000UL
+#define NETLINK_AUDIT_SOCKET__NLMSG_TTY_AUDIT     0x04000000UL
+#define NETLINK_IP6FW_SOCKET__IOCTL               0x00000001UL
+#define NETLINK_IP6FW_SOCKET__READ                0x00000002UL
+#define NETLINK_IP6FW_SOCKET__WRITE               0x00000004UL
+#define NETLINK_IP6FW_SOCKET__CREATE              0x00000008UL
+#define NETLINK_IP6FW_SOCKET__GETATTR             0x00000010UL
+#define NETLINK_IP6FW_SOCKET__SETATTR             0x00000020UL
+#define NETLINK_IP6FW_SOCKET__LOCK                0x00000040UL
+#define NETLINK_IP6FW_SOCKET__RELABELFROM         0x00000080UL
+#define NETLINK_IP6FW_SOCKET__RELABELTO           0x00000100UL
+#define NETLINK_IP6FW_SOCKET__APPEND              0x00000200UL
+#define NETLINK_IP6FW_SOCKET__BIND                0x00000400UL
+#define NETLINK_IP6FW_SOCKET__CONNECT             0x00000800UL
+#define NETLINK_IP6FW_SOCKET__LISTEN              0x00001000UL
+#define NETLINK_IP6FW_SOCKET__ACCEPT              0x00002000UL
+#define NETLINK_IP6FW_SOCKET__GETOPT              0x00004000UL
+#define NETLINK_IP6FW_SOCKET__SETOPT              0x00008000UL
+#define NETLINK_IP6FW_SOCKET__SHUTDOWN            0x00010000UL
+#define NETLINK_IP6FW_SOCKET__RECVFROM            0x00020000UL
+#define NETLINK_IP6FW_SOCKET__SENDTO              0x00040000UL
+#define NETLINK_IP6FW_SOCKET__RECV_MSG            0x00080000UL
+#define NETLINK_IP6FW_SOCKET__SEND_MSG            0x00100000UL
+#define NETLINK_IP6FW_SOCKET__NAME_BIND           0x00200000UL
+#define NETLINK_IP6FW_SOCKET__NLMSG_READ          0x00400000UL
+#define NETLINK_IP6FW_SOCKET__NLMSG_WRITE         0x00800000UL
+#define NETLINK_DNRT_SOCKET__IOCTL                0x00000001UL
+#define NETLINK_DNRT_SOCKET__READ                 0x00000002UL
+#define NETLINK_DNRT_SOCKET__WRITE                0x00000004UL
+#define NETLINK_DNRT_SOCKET__CREATE               0x00000008UL
+#define NETLINK_DNRT_SOCKET__GETATTR              0x00000010UL
+#define NETLINK_DNRT_SOCKET__SETATTR              0x00000020UL
+#define NETLINK_DNRT_SOCKET__LOCK                 0x00000040UL
+#define NETLINK_DNRT_SOCKET__RELABELFROM          0x00000080UL
+#define NETLINK_DNRT_SOCKET__RELABELTO            0x00000100UL
+#define NETLINK_DNRT_SOCKET__APPEND               0x00000200UL
+#define NETLINK_DNRT_SOCKET__BIND                 0x00000400UL
+#define NETLINK_DNRT_SOCKET__CONNECT              0x00000800UL
+#define NETLINK_DNRT_SOCKET__LISTEN               0x00001000UL
+#define NETLINK_DNRT_SOCKET__ACCEPT               0x00002000UL
+#define NETLINK_DNRT_SOCKET__GETOPT               0x00004000UL
+#define NETLINK_DNRT_SOCKET__SETOPT               0x00008000UL
+#define NETLINK_DNRT_SOCKET__SHUTDOWN             0x00010000UL
+#define NETLINK_DNRT_SOCKET__RECVFROM             0x00020000UL
+#define NETLINK_DNRT_SOCKET__SENDTO               0x00040000UL
+#define NETLINK_DNRT_SOCKET__RECV_MSG             0x00080000UL
+#define NETLINK_DNRT_SOCKET__SEND_MSG             0x00100000UL
+#define NETLINK_DNRT_SOCKET__NAME_BIND            0x00200000UL
+#define DBUS__ACQUIRE_SVC                         0x00000001UL
+#define DBUS__SEND_MSG                            0x00000002UL
+#define NSCD__GETPWD                              0x00000001UL
+#define NSCD__GETGRP                              0x00000002UL
+#define NSCD__GETHOST                             0x00000004UL
+#define NSCD__GETSTAT                             0x00000008UL
+#define NSCD__ADMIN                               0x00000010UL
+#define NSCD__SHMEMPWD                            0x00000020UL
+#define NSCD__SHMEMGRP                            0x00000040UL
+#define NSCD__SHMEMHOST                           0x00000080UL
+#define NSCD__GETSERV                             0x00000100UL
+#define NSCD__SHMEMSERV                           0x00000200UL
+#define ASSOCIATION__SENDTO                       0x00000001UL
+#define ASSOCIATION__RECVFROM                     0x00000002UL
+#define ASSOCIATION__SETCONTEXT                   0x00000004UL
+#define ASSOCIATION__POLMATCH                     0x00000008UL
+#define NETLINK_KOBJECT_UEVENT_SOCKET__IOCTL      0x00000001UL
+#define NETLINK_KOBJECT_UEVENT_SOCKET__READ       0x00000002UL
+#define NETLINK_KOBJECT_UEVENT_SOCKET__WRITE      0x00000004UL
+#define NETLINK_KOBJECT_UEVENT_SOCKET__CREATE     0x00000008UL
+#define NETLINK_KOBJECT_UEVENT_SOCKET__GETATTR    0x00000010UL
+#define NETLINK_KOBJECT_UEVENT_SOCKET__SETATTR    0x00000020UL
+#define NETLINK_KOBJECT_UEVENT_SOCKET__LOCK       0x00000040UL
+#define NETLINK_KOBJECT_UEVENT_SOCKET__RELABELFROM 0x00000080UL
+#define NETLINK_KOBJECT_UEVENT_SOCKET__RELABELTO  0x00000100UL
+#define NETLINK_KOBJECT_UEVENT_SOCKET__APPEND     0x00000200UL
+#define NETLINK_KOBJECT_UEVENT_SOCKET__BIND       0x00000400UL
+#define NETLINK_KOBJECT_UEVENT_SOCKET__CONNECT    0x00000800UL
+#define NETLINK_KOBJECT_UEVENT_SOCKET__LISTEN     0x00001000UL
+#define NETLINK_KOBJECT_UEVENT_SOCKET__ACCEPT     0x00002000UL
+#define NETLINK_KOBJECT_UEVENT_SOCKET__GETOPT     0x00004000UL
+#define NETLINK_KOBJECT_UEVENT_SOCKET__SETOPT     0x00008000UL
+#define NETLINK_KOBJECT_UEVENT_SOCKET__SHUTDOWN   0x00010000UL
+#define NETLINK_KOBJECT_UEVENT_SOCKET__RECVFROM   0x00020000UL
+#define NETLINK_KOBJECT_UEVENT_SOCKET__SENDTO     0x00040000UL
+#define NETLINK_KOBJECT_UEVENT_SOCKET__RECV_MSG   0x00080000UL
+#define NETLINK_KOBJECT_UEVENT_SOCKET__SEND_MSG   0x00100000UL
+#define NETLINK_KOBJECT_UEVENT_SOCKET__NAME_BIND  0x00200000UL
+#define APPLETALK_SOCKET__IOCTL                   0x00000001UL
+#define APPLETALK_SOCKET__READ                    0x00000002UL
+#define APPLETALK_SOCKET__WRITE                   0x00000004UL
+#define APPLETALK_SOCKET__CREATE                  0x00000008UL
+#define APPLETALK_SOCKET__GETATTR                 0x00000010UL
+#define APPLETALK_SOCKET__SETATTR                 0x00000020UL
+#define APPLETALK_SOCKET__LOCK                    0x00000040UL
+#define APPLETALK_SOCKET__RELABELFROM             0x00000080UL
+#define APPLETALK_SOCKET__RELABELTO               0x00000100UL
+#define APPLETALK_SOCKET__APPEND                  0x00000200UL
+#define APPLETALK_SOCKET__BIND                    0x00000400UL
+#define APPLETALK_SOCKET__CONNECT                 0x00000800UL
+#define APPLETALK_SOCKET__LISTEN                  0x00001000UL
+#define APPLETALK_SOCKET__ACCEPT                  0x00002000UL
+#define APPLETALK_SOCKET__GETOPT                  0x00004000UL
+#define APPLETALK_SOCKET__SETOPT                  0x00008000UL
+#define APPLETALK_SOCKET__SHUTDOWN                0x00010000UL
+#define APPLETALK_SOCKET__RECVFROM                0x00020000UL
+#define APPLETALK_SOCKET__SENDTO                  0x00040000UL
+#define APPLETALK_SOCKET__RECV_MSG                0x00080000UL
+#define APPLETALK_SOCKET__SEND_MSG                0x00100000UL
+#define APPLETALK_SOCKET__NAME_BIND               0x00200000UL
+#define PACKET__SEND                              0x00000001UL
+#define PACKET__RECV                              0x00000002UL
+#define PACKET__RELABELTO                         0x00000004UL
+#define PACKET__FLOW_IN                           0x00000008UL
+#define PACKET__FLOW_OUT                          0x00000010UL
+#define PACKET__FORWARD_IN                        0x00000020UL
+#define PACKET__FORWARD_OUT                       0x00000040UL
+#define KEY__VIEW                                 0x00000001UL
+#define KEY__READ                                 0x00000002UL
+#define KEY__WRITE                                0x00000004UL
+#define KEY__SEARCH                               0x00000008UL
+#define KEY__LINK                                 0x00000010UL
+#define KEY__SETATTR                              0x00000020UL
+#define KEY__CREATE                               0x00000040UL
+#define CONTEXT__TRANSLATE                        0x00000001UL
+#define CONTEXT__CONTAINS                         0x00000002UL
+#define DCCP_SOCKET__IOCTL                        0x00000001UL
+#define DCCP_SOCKET__READ                         0x00000002UL
+#define DCCP_SOCKET__WRITE                        0x00000004UL
+#define DCCP_SOCKET__CREATE                       0x00000008UL
+#define DCCP_SOCKET__GETATTR                      0x00000010UL
+#define DCCP_SOCKET__SETATTR                      0x00000020UL
+#define DCCP_SOCKET__LOCK                         0x00000040UL
+#define DCCP_SOCKET__RELABELFROM                  0x00000080UL
+#define DCCP_SOCKET__RELABELTO                    0x00000100UL
+#define DCCP_SOCKET__APPEND                       0x00000200UL
+#define DCCP_SOCKET__BIND                         0x00000400UL
+#define DCCP_SOCKET__CONNECT                      0x00000800UL
+#define DCCP_SOCKET__LISTEN                       0x00001000UL
+#define DCCP_SOCKET__ACCEPT                       0x00002000UL
+#define DCCP_SOCKET__GETOPT                       0x00004000UL
+#define DCCP_SOCKET__SETOPT                       0x00008000UL
+#define DCCP_SOCKET__SHUTDOWN                     0x00010000UL
+#define DCCP_SOCKET__RECVFROM                     0x00020000UL
+#define DCCP_SOCKET__SENDTO                       0x00040000UL
+#define DCCP_SOCKET__RECV_MSG                     0x00080000UL
+#define DCCP_SOCKET__SEND_MSG                     0x00100000UL
+#define DCCP_SOCKET__NAME_BIND                    0x00200000UL
+#define DCCP_SOCKET__NODE_BIND                    0x00400000UL
+#define DCCP_SOCKET__NAME_CONNECT                 0x00800000UL
+#define MEMPROTECT__MMAP_ZERO                     0x00000001UL
+#define DB_DATABASE__CREATE                       0x00000001UL
+#define DB_DATABASE__DROP                         0x00000002UL
+#define DB_DATABASE__GETATTR                      0x00000004UL
+#define DB_DATABASE__SETATTR                      0x00000008UL
+#define DB_DATABASE__RELABELFROM                  0x00000010UL
+#define DB_DATABASE__RELABELTO                    0x00000020UL
+#define DB_DATABASE__ACCESS                       0x00000040UL
+#define DB_DATABASE__INSTALL_MODULE               0x00000080UL
+#define DB_DATABASE__LOAD_MODULE                  0x00000100UL
+#define DB_DATABASE__GET_PARAM                    0x00000200UL
+#define DB_DATABASE__SET_PARAM                    0x00000400UL
+#define DB_TABLE__CREATE                          0x00000001UL
+#define DB_TABLE__DROP                            0x00000002UL
+#define DB_TABLE__GETATTR                         0x00000004UL
+#define DB_TABLE__SETATTR                         0x00000008UL
+#define DB_TABLE__RELABELFROM                     0x00000010UL
+#define DB_TABLE__RELABELTO                       0x00000020UL
+#define DB_TABLE__USE                             0x00000040UL
+#define DB_TABLE__SELECT                          0x00000080UL
+#define DB_TABLE__UPDATE                          0x00000100UL
+#define DB_TABLE__INSERT                          0x00000200UL
+#define DB_TABLE__DELETE                          0x00000400UL
+#define DB_TABLE__LOCK                            0x00000800UL
+#define DB_PROCEDURE__CREATE                      0x00000001UL
+#define DB_PROCEDURE__DROP                        0x00000002UL
+#define DB_PROCEDURE__GETATTR                     0x00000004UL
+#define DB_PROCEDURE__SETATTR                     0x00000008UL
+#define DB_PROCEDURE__RELABELFROM                 0x00000010UL
+#define DB_PROCEDURE__RELABELTO                   0x00000020UL
+#define DB_PROCEDURE__EXECUTE                     0x00000040UL
+#define DB_PROCEDURE__ENTRYPOINT                  0x00000080UL
+#define DB_COLUMN__CREATE                         0x00000001UL
+#define DB_COLUMN__DROP                           0x00000002UL
+#define DB_COLUMN__GETATTR                        0x00000004UL
+#define DB_COLUMN__SETATTR                        0x00000008UL
+#define DB_COLUMN__RELABELFROM                    0x00000010UL
+#define DB_COLUMN__RELABELTO                      0x00000020UL
+#define DB_COLUMN__USE                            0x00000040UL
+#define DB_COLUMN__SELECT                         0x00000080UL
+#define DB_COLUMN__UPDATE                         0x00000100UL
+#define DB_COLUMN__INSERT                         0x00000200UL
+#define DB_TUPLE__RELABELFROM                     0x00000001UL
+#define DB_TUPLE__RELABELTO                       0x00000002UL
+#define DB_TUPLE__USE                             0x00000004UL
+#define DB_TUPLE__SELECT                          0x00000008UL
+#define DB_TUPLE__UPDATE                          0x00000010UL
+#define DB_TUPLE__INSERT                          0x00000020UL
+#define DB_TUPLE__DELETE                          0x00000040UL
+#define DB_BLOB__CREATE                           0x00000001UL
+#define DB_BLOB__DROP                             0x00000002UL
+#define DB_BLOB__GETATTR                          0x00000004UL
+#define DB_BLOB__SETATTR                          0x00000008UL
+#define DB_BLOB__RELABELFROM                      0x00000010UL
+#define DB_BLOB__RELABELTO                        0x00000020UL
+#define DB_BLOB__READ                             0x00000040UL
+#define DB_BLOB__WRITE                            0x00000080UL
+#define DB_BLOB__IMPORT                           0x00000100UL
+#define DB_BLOB__EXPORT                           0x00000200UL
+#define PEER__RECV                                0x00000001UL
+#define X_APPLICATION_DATA__PASTE                 0x00000001UL
+#define X_APPLICATION_DATA__PASTE_AFTER_CONFIRM   0x00000002UL
+#define X_APPLICATION_DATA__COPY                  0x00000004UL
+
+static inline uint32_t file_mask_to_perms(int mode, int mask){
+  uint32_t av = 0;
+
+  if (!S_ISDIR(mode)) {
+    if (mask & MAY_EXEC)
+      av |= FILE__EXECUTE;
+    if (mask & MAY_READ)
+      av |= FILE__READ;
+    if (mask & MAY_APPEND)
+      av |= FILE__APPEND;
+    else if (mask & MAY_WRITE)
+      av |= FILE__WRITE;
+  } else {
+    if (mask & MAY_EXEC)
+      av |= DIR__SEARCH;
+    if (mask & MAY_WRITE)
+      av |= DIR__WRITE;
+    if (mask & MAY_READ)
+      av |= DIR__READ;
+  }
+
+  return av;
+}
+
+#endif
diff -uprN ./pristine/linux-4.4.25/security/camflow/include/camflow_utils.h ./linux-4.4.25/security/camflow/include/camflow_utils.h
--- ./pristine/linux-4.4.25/security/camflow/include/camflow_utils.h	1969-12-31 16:00:00.000000000 -0800
+++ ./linux-4.4.25/security/camflow/include/camflow_utils.h	2016-10-19 03:14:47.582690427 -0700
@@ -0,0 +1,32 @@
+/*
+*
+* Author: Thomas Pasquier <tfjmp@seas.harvard.edu>
+*
+* Copyright (C) 2016 Harvard University
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License version 2, as
+* published by the Free Software Foundation; either version 2 of the License, or
+*	(at your option) any later version.
+*
+*/
+
+#ifndef _CAMFLOW_UTILS_PROVENANCE_H
+#define _CAMFLOW_UTILS_PROVENANCE_H
+
+#include <linux/fs.h>
+#include <linux/namei.h>
+
+static inline struct inode* file_name_to_inode(const char* name){
+  struct path path;
+  struct inode* inode;
+  if(kern_path(name, LOOKUP_FOLLOW, &path)){
+    printk(KERN_ERR "CamFlow: Failed file look up (%s).", name);
+    return NULL;
+  }
+  inode = path.dentry->d_inode;
+  path_put(&path);
+  return inode;
+}
+
+#endif
diff -uprN ./pristine/linux-4.4.25/security/ifc/bridge.c ./linux-4.4.25/security/ifc/bridge.c
--- ./pristine/linux-4.4.25/security/ifc/bridge.c	1969-12-31 16:00:00.000000000 -0800
+++ ./linux-4.4.25/security/ifc/bridge.c	2016-10-19 03:14:47.582690427 -0700
@@ -0,0 +1,157 @@
+/*
+*
+* Author: Thomas Pasquier <thomas.pasquier@cl.cam.ac.uk>
+*
+* Copyright (C) 2016 University of Cambridge
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License version 2, as
+* published by the Free Software Foundation; either version 2 of the License, or
+*	(at your option) any later version.
+*
+*/
+
+#include <linux/kmod.h>
+#include <linux/sched.h>
+#include <net/net_namespace.h>
+#include <net/netlink.h>
+
+#include "ifc.h"
+
+int prepare_bridge_usher(struct subprocess_info *info, struct cred *new){
+  pid_t parent_pid = (*((pid_t*)info->data));
+  struct task_struct* dest;
+  const struct cred* old;
+  struct ifc_struct *new_ifc = new->ifc;
+
+  if(new_ifc==NULL){
+    return -EFAULT;
+  }
+
+  dest = find_task_by_vpid(parent_pid);
+  if(dest==NULL){
+    return -EFAULT;
+  }
+  old = __task_cred(dest);
+
+  new_ifc->bridge.remote_pid = parent_pid;
+  new_ifc->bridge.spawner=true;
+  /* set process to run with proper uid/gid */
+  new->uid = old->uid;
+  new->gid = old->gid;
+  new->euid = old->euid;
+  new->egid = old->egid;
+  new->suid = old->suid;
+  new->sgid = old->sgid;
+  new->fsuid = old->fsuid;
+  new->fsgid = old->fsgid;
+  return 0;
+}
+
+int ifc_create_bridge(pid_t parent_pid, char **argv[]){
+  struct subprocess_info *sub_info;
+  static char *envp[] = {
+        "HOME=/",
+        "TERM=linux",
+        "PATH=/sbin:/bin:/usr/sbin:/usr/bin", NULL };
+
+  sub_info = call_usermodehelper_setup((*argv)[0], *argv, envp, GFP_KERNEL,
+    prepare_bridge_usher, NULL, &parent_pid);
+
+  if (sub_info == NULL){
+    printk(KERN_INFO "IFC: Creating bridge failed setup.");
+    return -ENOMEM;
+  }
+  return call_usermodehelper_exec(sub_info, UMH_WAIT_EXEC);
+}
+
+static struct sock *nl_sk = NULL;
+
+static inline int send_to(struct sock* sk, const pid_t target, void* data, const size_t size){
+  struct nlmsghdr *nlh;
+  struct sk_buff *skb_out = nlmsg_new(size,0);
+  if(!skb_out){
+    return -ENOMEM;
+  }
+  if(target==0){
+    return -EFAULT;
+  }
+
+  nlh=nlmsg_put(skb_out,0,0,NLMSG_DONE,size,0);
+  if(nlh==NULL){
+    printk(KERN_INFO "IFC: tailroom of the skb is insufficient to store the message header and payload.");
+    return -ENOMEM;
+  }
+  NETLINK_CB(skb_out).dst_group = 0;
+  memcpy(nlmsg_data(nlh), data, size);
+  return nlmsg_unicast(sk,skb_out,target);
+}
+
+static inline bool _bridge_can_send(pid_t remote_pid){
+  pid_t cpid;
+  struct ifc_struct *cifc = current_ifc(), *rifc;
+  struct task_struct* dest;
+  const struct cred* rcred;
+
+  /* checking permission */
+  if(cifc->bridge.bridge==true){
+    if(cifc->bridge.remote_pid!=remote_pid){
+      printk(KERN_ALERT "IFC: bridge perm refused %u-%u.", cifc->bridge.remote_pid, remote_pid);
+      return false;
+    }
+  }else{
+    cpid = task_pid_vnr(current);
+    dest = find_task_by_vpid(remote_pid);
+    if(dest==NULL){
+      return false;
+    }
+    rcred = __task_cred(dest);
+    rifc = rcred->ifc;
+    if(rifc->bridge.remote_pid!=cpid){
+      printk(KERN_ALERT "IFC: not bridge perm refused %u-%u.", rifc->bridge.remote_pid, cpid);
+      return false;
+    }
+  }
+
+  return true;
+}
+
+static void _bridge_rcv(struct sk_buff *skb)
+{
+  int rc=0;
+  struct nlmsghdr *nlh=(struct nlmsghdr*)skb->data;
+  if(_bridge_can_send(nlh->nlmsg_pid)){
+    rc = send_to(nl_sk, nlh->nlmsg_pid, nlmsg_data(nlh), nlmsg_len(nlh));
+    if(rc){
+      printk(KERN_ALERT "IFC: problem while forwarding message %d.", rc);
+    }
+  }else{
+    printk(KERN_INFO "IFC: bridge invalid target");
+  }
+}
+
+enum selinux_nlgroups {
+	CAMNLGRP_NONE,
+#define CAMNLGRP_NONE	CAMNLGRP_NONE
+	CAMNLGRP_AVC,
+#define CAMNLGRP_AVC	CAMNLGRP_AVC
+	__CAMNLGRP_MAX
+};
+#define CAMNLGRP_MAX	(__CAMNLGRP_MAX - 1)
+
+int __init ifc_bridge_init(void)
+{
+  struct netlink_kernel_cfg cfg = {
+    .input  = _bridge_rcv,
+    .groups = CAMNLGRP_MAX,
+  };
+  nl_sk = netlink_kernel_create(&init_net, NETLINK_CAMFLOW_IFC_BRIDGE, &cfg);
+  if(nl_sk==NULL){
+    printk(KERN_ERR "IFC: Cannot create bridge netlink socket.");
+    return -ENOMEM;
+  }
+  printk(KERN_INFO "IFC bridge ready.");
+  return 0;
+}
+
+__initcall(ifc_bridge_init);
diff -uprN ./pristine/linux-4.4.25/security/ifc/fs.c ./linux-4.4.25/security/ifc/fs.c
--- ./pristine/linux-4.4.25/security/ifc/fs.c	1969-12-31 16:00:00.000000000 -0800
+++ ./linux-4.4.25/security/ifc/fs.c	2016-10-19 03:14:47.582690427 -0700
@@ -0,0 +1,564 @@
+/*
+*
+* Author: Thomas Pasquier <thomas.pasquier@cl.cam.ac.uk>
+*
+* Copyright (C) 2015 University of Cambridge
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License version 2, as
+* published by the Free Software Foundation; either version 2 of the License, or
+*	(at your option) any later version.
+*
+*/
+
+#include <linux/security.h>
+#include <linux/fs.h>
+#include <linux/ifc.h>
+#include <linux/delay.h>
+#include <linux/camflow.h>
+#include <linux/list.h>
+
+#include "camflow_utils.h"
+#include "ifc.h"
+#include "provenance.h"
+#include "provenance_long.h"
+
+static bool ifc_fs_is_initialised=false;
+
+static void mark_as_trusted(const char* name){
+  struct inode* in;
+  struct ifc_struct* ifc;
+
+  in = file_name_to_inode(name);
+  if(!in){
+    printk(KERN_ERR "IFC: could not find %s file.", name);
+  }else{
+    ifc = inode_get_ifc(in);
+    ifc->context.trusted=IFC_TRUSTED;
+  }
+}
+
+static inline void initialize(void){
+  if(ifc_fs_is_initialised)
+    return;
+  printk(KERN_INFO "IFC: marking API files as trusted...");
+  mark_as_trusted(IFC_SELF_FILE);
+  mark_as_trusted(IFC_TAG_FILE);
+  mark_as_trusted(IFC_PROCESS_FILE);
+  mark_as_trusted(IFC_BRIDGE_FILE);
+  mark_as_trusted(IFC_FILE_FILE);
+  ifc_fs_is_initialised=true;
+}
+
+static ssize_t ifc_write_self(struct file *file, const char __user *buf,
+				 size_t count, loff_t *ppos)
+
+{
+  struct ifc_struct *cifc = current_ifc();
+  struct ifc_tag_msg *msg;
+  int rv=-EINVAL;
+#ifdef CONFIG_SECURITY_PROVENANCE
+  prov_msg_t* cprov=NULL;
+#endif
+
+  initialize();
+
+  if(count < sizeof(struct ifc_tag_msg)){
+    return -ENOMEM;
+  }
+
+  msg = (struct ifc_tag_msg*)buf;
+
+  if(!ifc_tag_valid(msg->tag)){
+    return -EINVAL;
+  }
+
+  if(msg->op==IFC_ADD_TAG){
+    switch(msg->tag_type){
+      case IFC_SECRECY:
+        rv=ifc_add_tag(&cifc->context, IFC_SECRECY, msg->tag);
+        break;
+      case IFC_INTEGRITY:
+        rv=ifc_add_tag(&cifc->context, IFC_INTEGRITY, msg->tag);
+        break;
+      case IFC_SECRECY_P:
+        if(__kuid_val(current_euid())!=0)
+          return -EPERM;
+        rv=ifc_add_privilege(&cifc->context, IFC_SECRECY_P, msg->tag);
+        break;
+      case IFC_INTEGRITY_P:
+        if(__kuid_val(current_euid())!=0)
+          return -EPERM;
+        rv=ifc_add_privilege(&cifc->context, IFC_INTEGRITY_P, msg->tag);
+        break;
+      case IFC_SECRECY_N:
+        if(__kuid_val(current_euid())!=0)
+          return -EPERM;
+        rv=ifc_add_privilege(&cifc->context, IFC_SECRECY_N, msg->tag);
+        break;
+      case IFC_INTEGRITY_N:
+        if(__kuid_val(current_euid())!=0)
+          return -EPERM;
+        rv=ifc_add_privilege(&cifc->context, IFC_INTEGRITY_N, msg->tag);
+        break;
+    }
+  }else{
+    switch(msg->tag_type){
+      case IFC_SECRECY:
+        rv=ifc_remove_tag(&cifc->context, IFC_SECRECY, msg->tag);
+        break;
+      case IFC_INTEGRITY:
+        rv=ifc_remove_tag(&cifc->context, IFC_INTEGRITY, msg->tag);
+        break;
+      case IFC_SECRECY_P:
+        rv=ifc_remove_privilege(&cifc->context, IFC_SECRECY_P, msg->tag);
+        break;
+      case IFC_INTEGRITY_P:
+        rv=ifc_remove_privilege(&cifc->context, IFC_INTEGRITY_P, msg->tag);
+        break;
+      case IFC_SECRECY_N:
+        rv=ifc_remove_privilege(&cifc->context, IFC_SECRECY_N, msg->tag);
+        break;
+      case IFC_INTEGRITY_N:
+        rv=ifc_remove_privilege(&cifc->context, IFC_INTEGRITY_N, msg->tag);
+        break;
+    }
+  }
+  if(!rv){
+
+#ifdef CONFIG_SECURITY_PROVENANCE
+    // mark as tracked depending of the label state
+    cprov = current_provenance();
+    prov_update_version(cprov);
+    prov_record_ifc(cprov, &cifc->context);
+    if(ifc_is_labelled(&cifc->context)){
+      set_tracked(cprov);
+    }else{
+      clear_tracked(cprov);
+    }
+#endif
+
+    return sizeof(struct ifc_tag_msg);
+  }
+  return rv; // return error
+}
+
+static ssize_t ifc_read_self(struct file *filp, char __user *buf,
+				size_t count, loff_t *ppos)
+{
+  struct ifc_struct *cifc = current_ifc();
+
+  initialize();
+
+	if(count < sizeof(struct ifc_context)){
+    return -ENOMEM;
+  }
+  if(copy_to_user(buf, &cifc->context, sizeof(struct ifc_context))){
+    return -EAGAIN;
+  }
+  return sizeof(struct ifc_context);
+}
+
+static const struct file_operations ifc_self_ops = {
+	.write		= ifc_write_self,
+  .read     = ifc_read_self,
+	.llseek		= generic_file_llseek,
+};
+
+static ssize_t ifc_write_tag(struct file *file, const char __user *buf,
+				 size_t count, loff_t *ppos)
+
+{
+	return -EPERM; // does nothing for now
+}
+
+static ssize_t ifc_read_tag(struct file *filp, char __user *buf,
+				size_t count, loff_t *ppos)
+{
+	struct ifc_struct *cifc = current_ifc();
+	tag_t tag;
+	int rv=0;
+
+	if(count<sizeof(tag_t))
+		return -ENOMEM;
+
+	tag = ifc_create_tag();
+
+	rv |= ifc_add_privilege(&cifc->context, IFC_SECRECY_P, tag);
+	rv |= ifc_add_privilege(&cifc->context, IFC_INTEGRITY_P, tag);
+	rv |= ifc_add_privilege(&cifc->context, IFC_SECRECY_N, tag);
+	rv |= ifc_add_privilege(&cifc->context, IFC_INTEGRITY_N, tag);
+
+	if(rv<0){
+		return rv;
+	}
+
+	if(copy_to_user(buf, &tag, sizeof(tag_t))){
+    return -EAGAIN;
+  }
+
+	return sizeof(tag_t);
+}
+
+static const struct file_operations ifc_tag_ops = {
+	.write		= ifc_write_tag,
+  .read     = ifc_read_tag,
+	.llseek		= generic_file_llseek,
+};
+
+static ssize_t ifc_write_process(struct file *file, const char __user *buf,
+				 size_t count, loff_t *ppos)
+
+{
+	struct ifc_struct *cifc = current_ifc();
+	struct ifc_struct *oifc = NULL;
+  struct ifc_tag_msg *msg;
+  int rv=-EINVAL;
+
+  if(count < sizeof(struct ifc_tag_msg)){
+    return -ENOMEM;
+  }
+
+  msg = (struct ifc_tag_msg*)buf;
+
+  if(!ifc_tag_valid(msg->tag)){
+    return -EINVAL;
+  }
+
+	oifc = ifc_from_pid(msg->pid);
+	if(!oifc){ // did not find anything
+		return -EINVAL;
+	}
+
+  if(msg->op==IFC_ADD_TAG){
+    switch(msg->tag_type){
+      case IFC_SECRECY_P:
+				if(!ifc_contains_value(&cifc->context.secrecy_p, msg->tag))
+					return -EPERM;
+        rv=ifc_add_privilege(&oifc->context, IFC_SECRECY_P, msg->tag);
+        break;
+      case IFC_INTEGRITY_P:
+				if(!ifc_contains_value(&cifc->context.integrity_p, msg->tag))
+					return -EPERM;
+        rv=ifc_add_privilege(&oifc->context, IFC_INTEGRITY_P, msg->tag);
+        break;
+      case IFC_SECRECY_N:
+				if(!ifc_contains_value(&cifc->context.secrecy_n, msg->tag))
+					return -EPERM;
+        rv=ifc_add_privilege(&oifc->context, IFC_SECRECY_N, msg->tag);
+        break;
+      case IFC_INTEGRITY_N:
+				if(!ifc_contains_value(&cifc->context.integrity_n, msg->tag))
+					return -EPERM;
+        rv=ifc_add_privilege(&oifc->context, IFC_INTEGRITY_N, msg->tag);
+        break;
+    }
+  }
+
+  if(!rv){
+    return sizeof(struct ifc_tag_msg);
+  }
+
+  return rv; // return error
+}
+
+static ssize_t ifc_read_process(struct file *filp, char __user *buf,
+				size_t count, loff_t *ppos)
+{
+	struct ifc_struct *oifc = NULL;
+  struct ifc_context_msg *msg;
+
+  if(__kuid_val(current_euid())!=0)
+    return -EPERM;
+
+  if(count < sizeof(struct ifc_context_msg)){
+    return -ENOMEM;
+  }
+
+  msg = (struct ifc_context_msg*)buf;
+
+  oifc = ifc_from_pid(msg->pid);
+	if(!oifc){ // did not find anything
+		return -EINVAL;
+	}
+
+  if(copy_to_user(&msg->context, &oifc->context, sizeof(struct ifc_context))){
+    return -EAGAIN;
+  }
+  return sizeof(struct ifc_context_msg);
+}
+
+static const struct file_operations ifc_process_ops = {
+	.write		= ifc_write_process,
+  .read     = ifc_read_process,
+	.llseek		= generic_file_llseek,
+};
+
+struct bridge_struct {
+    struct list_head list;
+    char name[PATH_MAX];
+};
+
+static LIST_HEAD(bridge_list);
+
+static bool list_contains(const char* name){
+  struct list_head *ptr;
+  struct bridge_struct *entry;
+
+  if(list_empty(&bridge_list)!=0)
+    return false;
+
+  list_for_each(ptr, &bridge_list) {
+        entry = list_entry(ptr, struct bridge_struct, list);
+        if(strcmp(name, entry->name)==0){
+          return true;
+        }
+    }
+    return false;
+}
+
+static int add_name_to_list(const char* name){
+  struct bridge_struct *entry;
+  if(list_contains(name)) // already in the list
+    return 0;
+
+  entry = (struct bridge_struct*)kzalloc(sizeof(struct bridge_struct), GFP_KERNEL);
+  if(copy_from_user(entry->name, name, PATH_MAX)!=0){
+    return -ENOMEM;
+  }
+  list_add(&entry->list, &bridge_list);
+  return 0;
+}
+
+static ssize_t ifc_write_bridge(struct file *file, const char __user *buf,
+				 size_t count, loff_t *ppos)
+
+{
+  pid_t pid = task_pid_vnr(current);
+  struct ifc_bridge_config *config;
+  char **argv;
+  int rc = 0;
+
+  if(count < sizeof(struct ifc_bridge_config))
+    return -ENOMEM;
+
+  config = (struct ifc_bridge_config*)buf;
+
+  switch(config->op){
+    case IFC_ADD_BRIDGE:
+      if(__kuid_val(current_euid())!=0)
+        return -EPERM;
+      rc = add_name_to_list(config->path);
+      break;
+    case IFC_START_BRIDGE:
+      argv=kzalloc(3*sizeof(char*), GFP_KERNEL);
+      argv[0]=kzalloc(PATH_MAX, GFP_KERNEL);
+      if(copy_from_user (argv[0], config->path, PATH_MAX)!=0){
+        return -ENOMEM;
+      }
+      if(!list_contains(argv[0])){
+        return -EPERM;
+      }
+      argv[1]=kzalloc(PARAM_MAX, GFP_KERNEL);
+      if(copy_from_user (argv[1], config->param, PARAM_MAX)!=0){
+        return -ENOMEM;
+      }
+      argv[2] = NULL;
+      ifc_create_bridge(pid, &argv);
+      kfree(argv[0]);
+      kfree(argv[1]);
+      kfree(argv);
+      break;
+    default:
+      return -EINVAL;
+  }
+	return rc;
+}
+
+static ssize_t ifc_read_bridge(struct file *filp, char __user *buf,
+				size_t count, loff_t *ppos)
+{
+  struct ifc_struct *cifc = current_ifc();
+  uint32_t pid=0;
+  int i=0;
+
+  if(count<sizeof(uint32_t))
+    return -EINVAL;
+
+  if(cifc->bridge.bridge==true){
+    pid = cifc->bridge.remote_pid;
+  }else{
+    /* we try to read the pid of the started bridge usher */
+    while(i<100){
+      i++;
+      if(cifc->bridge.remote_pid!=0){
+        pid = cifc->bridge.remote_pid;
+        cifc->bridge.remote_pid = 0;
+        break;
+      }
+      msleep(10);
+    }
+    if(i>=100){
+      return -EAGAIN; // could not get the remote_pid
+    }
+  }
+
+  if(copy_to_user(buf, &pid, sizeof(uint32_t))){
+    return -EAGAIN;
+  }
+	return sizeof(uint32_t);
+}
+
+static const struct file_operations ifc_bridge_ops = {
+	.write		= ifc_write_bridge,
+  .read     = ifc_read_bridge,
+	.llseek		= generic_file_llseek,
+};
+
+static ssize_t ifc_write_file(struct file *file, const char __user *buf,
+				 size_t count, loff_t *ppos)
+
+{
+  struct ifc_file_change* change;
+  struct inode* in;
+  struct ifc_struct* ifc;
+  int rv = -EINVAL;
+#ifdef CONFIG_SECURITY_PROVENANCE
+  prov_msg_t* prov=NULL;
+#endif
+
+  if(__kuid_val(current_euid())!=0)
+    return -EPERM;
+
+  if(count < sizeof(struct ifc_file_change)){
+    printk(KERN_INFO "IFC: Too short.");
+    return -EINVAL;
+  }
+
+  change = (struct ifc_file_change*)buf;
+
+  in = file_name_to_inode(change->name);
+  if(!in){
+    printk(KERN_ERR "IFC: could not find %s file.", change->name);
+    return -EINVAL;
+  }
+  ifc = inode_get_ifc(in);
+
+  if(change->op==IFC_ADD_TRUSTED){ // mark the file as trusted
+   ifc->context.trusted=IFC_TRUSTED;
+   return 0;
+  }
+
+  if(!ifc_tag_valid(change->tag)){
+    return -EINVAL;
+  }
+
+  if(change->op==IFC_ADD_TAG){
+    switch(change->tag_type){
+      case IFC_SECRECY:
+        rv=ifc_add_tag_no_check(&ifc->context, IFC_SECRECY, change->tag);
+        break;
+      case IFC_INTEGRITY:
+        rv=ifc_add_tag_no_check(&ifc->context, IFC_INTEGRITY, change->tag);
+        break;
+    }
+  }else if(change->op==IFC_REMOVE_TAG){
+    switch(change->tag_type){
+      case IFC_SECRECY:
+        rv=ifc_remove_tag_no_check(&ifc->context, IFC_SECRECY, change->tag);
+        break;
+      case IFC_INTEGRITY:
+        rv=ifc_remove_tag_no_check(&ifc->context, IFC_INTEGRITY, change->tag);
+        break;
+    }
+  }
+
+#ifdef CONFIG_SECURITY_PROVENANCE
+  // mark as tracked depending of the label state
+  prov = __raw_inode_provenance(in);
+  prov_update_version(prov);
+  prov_record_ifc(prov, &ifc->context);
+  if(ifc_is_labelled(&ifc->context)){
+    set_tracked(prov);
+  }else{
+    clear_tracked(prov);
+  }
+#endif
+
+  return rv;
+}
+
+static ssize_t ifc_read_file(struct file *filp, char __user *buf,
+				size_t count, loff_t *ppos)
+{
+  struct ifc_file_config *msg;
+  struct inode* in;
+  struct ifc_struct* ifc;
+
+  if(__kuid_val(current_euid())!=0)
+    return -EPERM;
+
+  if(count < sizeof(struct ifc_file_config)){
+    printk(KERN_INFO "IFC: Too short.");
+    return -EINVAL;
+  }
+
+  msg = (struct ifc_file_config*)buf;
+  in = file_name_to_inode(msg->name);
+  if(!in){
+    printk(KERN_ERR "IFC: could not find %s file.", msg->name);
+    return -EINVAL;
+  }
+
+  ifc = inode_get_ifc(in);
+  if(copy_to_user(&msg->context, &ifc->context, sizeof(struct ifc_context))){
+    printk(KERN_INFO "IFC: error copying.");
+    return -ENOMEM;
+  }
+
+  return sizeof(struct ifc_file_config);
+}
+
+static const struct file_operations ifc_file_ops = {
+	.write		= ifc_write_file,
+  .read     = ifc_read_file,
+	.llseek		= generic_file_llseek,
+};
+
+#define CRYPTO_DRIVER_NAME "blowfish"
+struct crypto_cipher *ifc_tfm = NULL;
+static const uint64_t ifc_key=0xAEF; // not safe
+
+int ifc_crypto_init(void){
+  ifc_tfm = crypto_alloc_cipher(CRYPTO_DRIVER_NAME, 0, 0);
+  if(IS_ERR((void *)ifc_tfm)){
+    printk(KERN_ERR "IFC: Failed to load transform for %s: %ld\n", CRYPTO_DRIVER_NAME, PTR_ERR(ifc_tfm));
+    ifc_tfm = NULL;
+    return PTR_ERR((void *)ifc_tfm);
+  }
+  return crypto_cipher_setkey(ifc_tfm, (const u8*)&ifc_key, sizeof(uint64_t));
+}
+
+static int __init init_ifc_fs(void)
+{
+  int rc;
+  struct dentry *ifc_dir= securityfs_create_dir("ifc", NULL);
+
+  securityfs_create_file("self", 0666, ifc_dir, NULL, &ifc_self_ops);
+  securityfs_create_file("tag", 0644, ifc_dir, NULL, &ifc_tag_ops);
+  securityfs_create_file("process", 0666, ifc_dir, NULL, &ifc_process_ops);
+  securityfs_create_file("bridge", 0666, ifc_dir, NULL, &ifc_bridge_ops);
+  securityfs_create_file("file", 0600, ifc_dir, NULL, &ifc_file_ops);
+  rc = ifc_crypto_init();
+  if(rc){
+    printk(KERN_ERR "IFC: cannot alloc crypto cipher. Error: %d.\n", rc);
+  }
+#ifdef CONFIG_SECURITY_PROVENANCE
+  printk(KERN_INFO "IFC: activivating provenance capture.");
+  prov_enabled = true;
+#endif
+  printk(KERN_INFO "IFC fs ready.\n");
+  return 0;
+}
+
+late_initcall_sync(init_ifc_fs);
diff -uprN ./pristine/linux-4.4.25/security/ifc/hooks.c ./linux-4.4.25/security/ifc/hooks.c
--- ./pristine/linux-4.4.25/security/ifc/hooks.c	1969-12-31 16:00:00.000000000 -0800
+++ ./linux-4.4.25/security/ifc/hooks.c	2016-10-19 03:14:47.582690427 -0700
@@ -0,0 +1,791 @@
+/*
+*
+* Author: Thomas Pasquier <thomas.pasquier@cl.cam.ac.uk>
+*
+* Copyright (C) 2015 University of Cambridge
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License version 2, as
+* published by the Free Software Foundation; either version 2 of the License, or
+*	(at your option) any later version.
+*
+*/
+
+#include <linux/camflow.h>
+#include <linux/slab.h>
+#include <linux/lsm_hooks.h>
+#include <linux/msg.h>
+#include <net/sock.h>
+#include <linux/binfmts.h>
+#include <linux/random.h>
+#include <linux/xattr.h>
+
+#include "ifc.h"
+#include "provenance.h"
+
+struct kmem_cache *ifc_cache=NULL;
+
+static inline struct ifc_struct* alloc_ifc(gfp_t gfp)
+{
+  struct ifc_struct* ifc =  kmem_cache_zalloc(ifc_cache, gfp);
+  if(!ifc){
+    return NULL;
+  }
+  return ifc;
+}
+
+static inline struct ifc_struct* inherit_ifc(struct ifc_struct* old, gfp_t gfp)
+{
+  struct ifc_struct* ifc =  kmem_cache_zalloc(ifc_cache, gfp);
+  if(!ifc)
+    return NULL;
+
+  if(!old)
+    return ifc;
+  /* copy tags */
+  memcpy(&ifc->context.secrecy, &old->context.secrecy, sizeof(struct ifc_label));
+  memcpy(&ifc->context.integrity, &old->context.integrity, sizeof(struct ifc_label));
+  return ifc;
+}
+
+static inline void free_ifc(struct ifc_struct* ifc){
+  kmem_cache_free(ifc_cache, ifc);
+}
+
+/*
+* @cred points to the credentials.
+* @gfp indicates the atomicity of any memory allocations.
+* Only allocate sufficient memory and attach to @cred such that
+* cred_transfer() will not get ENOMEM.
+*/
+static int ifc_cred_alloc_blank(struct cred *cred, gfp_t gfp)
+{
+  struct ifc_struct* ifc = alloc_ifc(gfp);
+  if(!ifc){
+    return -ENOMEM;
+  }
+  cred->ifc = ifc;
+  return 0;
+}
+
+/*
+* @cred points to the credentials.
+* Deallocate and clear the cred->security field in a set of credentials.
+*/
+static void ifc_cred_free(struct cred *cred)
+{
+  free_ifc(cred->ifc);
+  cred->ifc = NULL;
+}
+
+/*
+* @new points to the new credentials.
+* @old points to the original credentials.
+* @gfp indicates the atomicity of any memory allocations.
+* Prepare a new set of credentials by copying the data from the old set.
+*/
+static int ifc_cred_prepare(struct cred *new, const struct cred *old, gfp_t gfp)
+{
+  struct ifc_struct *old_ifc = old->ifc;
+  struct ifc_struct *new_ifc, *caller_ifc;
+  pid_t cpid;
+  struct task_struct* dest;
+  const struct cred* caller;
+
+  if(unlikely(old_ifc->bridge.spawner==true)){
+    new_ifc = alloc_ifc(gfp);
+    if(!new_ifc){
+      return -ENOMEM;
+    }
+    new_ifc->bridge.remote_pid = old_ifc->bridge.remote_pid;
+    new_ifc->bridge.bridge=true;
+    cpid = task_pid_vnr(current);
+    dest = find_task_by_vpid(new_ifc->bridge.remote_pid);
+    if(dest==NULL){
+      return -EFAULT;
+    }
+    caller = __task_cred(dest);
+    caller_ifc = caller->ifc;
+    caller_ifc->bridge.remote_pid = cpid;
+  }else{
+    new_ifc = inherit_ifc(old_ifc, gfp);
+  }
+
+  new->ifc=new_ifc;
+	return 0;
+}
+
+/*
+* @new points to the new credentials.
+* @old points to the original credentials.
+* Transfer data from original creds to new creds
+*/
+static void ifc_cred_transfer(struct cred *new, const struct cred *old)
+{
+  struct ifc_struct *old_ifc = old->ifc;
+	struct ifc_struct *ifc = new->ifc;
+
+  *old_ifc=*ifc;
+}
+
+/*
+* Allocate and attach a security structure to @inode->i_security.  The
+* i_security field is initialized to NULL when the inode structure is
+* allocated.
+* @inode contains the inode structure.
+* Return 0 if operation was successful.
+*/
+static int ifc_inode_alloc_security(struct inode *inode)
+{
+  struct ifc_struct* cifc = current_ifc();
+  struct ifc_struct* ifc = inherit_ifc(cifc, GFP_KERNEL);
+  if(!ifc){
+    return -ENOMEM;
+  }
+  alloc_camflow(inode, GFP_KERNEL);
+  inode_set_ifc(inode, ifc);
+  return 0;
+}
+
+/*
+* @inode contains the inode structure.
+* Deallocate the inode security structure and set @inode->i_security to
+* NULL.
+*/
+static void ifc_inode_free_security(struct inode *inode)
+{
+  struct ifc_struct* ifc = inode_get_ifc(inode);
+  if(!ifc)
+    free_ifc(ifc);
+	inode_set_ifc(inode, NULL);
+	free_camflow(inode);
+}
+
+/*
+* Check permission before accessing an inode.  This hook is called by the
+* existing Linux permission function, so a security module can use it to
+* provide additional checking for existing Linux permission checks.
+* Notice that this hook is called when a file is opened (as well as many
+* other operations), whereas the file_security_ops permission hook is
+* called when the actual read/write operations are performed.
+* @inode contains the inode structure to check.
+* @mask contains the permission mask.
+* Return 0 if permission is granted.
+*/
+static int ifc_inode_permission(struct inode *inode, int mask)
+{
+  struct ifc_struct* cifc = current_ifc();
+  struct ifc_struct* ifc=NULL;
+#ifdef CONFIG_SECURITY_PROVENANCE
+	prov_msg_t *i_prov=NULL;
+  prov_msg_t *p_prov=NULL;
+#endif
+
+  if((mask & MAY_EXEC)!=0)
+    return 0;
+
+  mask &= (MAY_READ|MAY_WRITE|MAY_APPEND);
+  // no permission to check. Existence test
+  if (!mask)
+		return 0;
+
+  if(unlikely(IS_PRIVATE(inode)))
+		return 0;
+
+  ifc = inode_get_ifc(inode);
+  if(!ifc){
+    ifc_inode_alloc_security(inode);
+    ifc = inode_get_ifc(inode);
+  }
+
+#ifdef CONFIG_SECURITY_PROVENANCE
+  i_prov=__raw_inode_provenance(inode);
+  p_prov=current_provenance();
+  if(ifc_is_labelled(&cifc->context)){
+    set_tracked(p_prov);
+  }
+
+  if(ifc_is_labelled(&ifc->context)){
+    set_tracked(i_prov);
+  }
+#endif
+
+  if((mask & (MAY_WRITE|MAY_APPEND)) != 0){
+    // process -> inode
+    if(!ifc_can_flow(&cifc->context, &ifc->context)){
+#ifdef CONFIG_SECURITY_PROVENANCE
+      record_relation(RL_WRITE, p_prov, i_prov, FLOW_DISALLOWED);
+#endif
+      return -EPERM;
+    }
+  }
+  if((mask & (MAY_READ)) != 0){
+    // inode -> process
+    if(!ifc_can_flow(&ifc->context, &cifc->context)){
+#ifdef CONFIG_SECURITY_PROVENANCE
+      record_relation(RL_READ, i_prov, p_prov, FLOW_DISALLOWED);
+#endif
+      return -EPERM;
+    }
+  }
+  return 0;
+}
+
+/*
+* Check file permissions before accessing an open file.  This hook is
+* called by various operations that read or write files.  A security
+* module can use this hook to perform additional checking on these
+* operations, e.g.  to revalidate permissions on use to support privilege
+* bracketing or policy changes.  Notice that this hook is used when the
+* actual read/write operations are performed, whereas the
+* inode_security_ops hook is called when a file is opened (as well as
+* many other operations).
+* Caveat:  Although this hook can be used to revalidate permissions for
+* various system call operations that read or write files, it does not
+* address the revalidation of permissions for memory-mapped files.
+* Security modules must handle this separately if they need such
+* revalidation.
+* @file contains the file structure being accessed.
+* @mask contains the requested permissions.
+* Return 0 if permission is granted.
+*/
+static int ifc_file_permission(struct file *file, int mask)
+{
+  struct inode *inode = file_inode(file);
+  return ifc_inode_permission(inode, mask);
+}
+
+/*
+* Allocate and attach a security structure to the msg->security field.
+* The security field is initialized to NULL when the structure is first
+* created.
+* @msg contains the message structure to be modified.
+* Return 0 if operation was successful and permission is granted.
+*/
+static int ifc_msg_msg_alloc_security(struct msg_msg *msg)
+{
+  struct ifc_struct* cifc = current_ifc();
+  struct ifc_struct* ifc= inherit_ifc(cifc, GFP_KERNEL);
+
+  if(!ifc)
+    return -ENOMEM;
+  msg->ifc = ifc;
+  return 0;
+}
+
+/*
+* Deallocate the security structure for this message.
+* @msg contains the message structure to be modified.
+*/
+static void ifc_msg_msg_free_security(struct msg_msg *msg)
+{
+  struct ifc_struct* ifc = msg->ifc;
+  msg->ifc=NULL;
+  free_ifc(ifc);
+}
+
+/*
+* Check permission before a message, @msg, is enqueued on the message
+* queue, @msq.
+* @msq contains the message queue to send message to.
+* @msg contains the message to be enqueued.
+* @msqflg contains operational flags.
+* Return 0 if permission is granted.
+*/
+static int ifc_msg_queue_msgsnd(struct msg_queue *msq, struct msg_msg *msg, int msqflg)
+{
+  struct ifc_struct* cifc = current_ifc();
+  struct ifc_struct* ifc = msg->ifc;
+#ifdef CONFIG_SECURITY_PROVENANCE
+	prov_msg_t *p_prov=NULL;
+  prov_msg_t *m_prov=NULL;
+#endif
+
+  if(!ifc_can_flow(&cifc->context, &ifc->context)){
+#ifdef CONFIG_SECURITY_PROVENANCE
+    p_prov=current_provenance();
+    m_prov=msg->provenance;
+    record_relation(RL_WRITE, p_prov, m_prov, FLOW_DISALLOWED);
+#endif
+    return -EPERM;
+  }
+  return 0;
+}
+
+/*
+* Check permission before a message, @msg, is removed from the message
+* queue, @msq.  The @target task structure contains a pointer to the
+* process that will be receiving the message (not equal to the current
+* process when inline receives are being performed).
+* @msq contains the message queue to retrieve message from.
+* @msg contains the message destination.
+* @target contains the task structure for recipient process.
+* @type contains the type of message requested.
+* @mode contains the operational flags.
+* Return 0 if permission is granted.
+*/
+static int ifc_msg_queue_msgrcv(struct msg_queue *msq, struct msg_msg *msg,
+				    struct task_struct *target,
+				    long type, int mode)
+{
+  struct ifc_struct* cifc = target->cred->ifc;
+  struct ifc_struct* ifc = msg->ifc;
+#ifdef CONFIG_SECURITY_PROVENANCE
+	prov_msg_t *p_prov=NULL;
+  prov_msg_t *m_prov=NULL;
+#endif
+
+
+  if(!ifc_can_flow(&ifc->context, &cifc->context)){
+#ifdef CONFIG_SECURITY_PROVENANCE
+    p_prov = target->cred->provenance;
+    m_prov = msg->provenance;
+    record_relation(RL_READ, m_prov, p_prov, FLOW_DISALLOWED);
+#endif
+    return -EPERM;
+  }
+
+  return 0;
+}
+
+/*
+* Check permissions for a mmap operation.  The @file may be NULL, e.g.
+* if mapping anonymous memory.
+* @file contains the file structure for file to map (may be NULL).
+* @reqprot contains the protection requested by the application.
+* @prot contains the protection that will be applied by the kernel.
+* @flags contains the operational flags.
+* Return 0 if permission is granted.
+*/
+static int ifc_mmap_file(struct file *file, unsigned long reqprot, unsigned long prot, unsigned long flags)
+{
+  struct ifc_struct* cifc = current_ifc();
+  struct ifc_struct* iifc;
+#ifdef CONFIG_SECURITY_PROVENANCE
+  prov_msg_t* cprov = current_provenance();
+  prov_msg_t* iprov;
+#endif
+  struct inode *inode;
+
+  if((prot & PROT_EXEC) != 0)
+    return 0;
+
+  if(file==NULL){ // what to do for NULL?
+    return 0;
+  }
+  inode = file_inode(file);
+  iifc = inode_get_ifc(inode);
+
+#ifdef CONFIG_SECURITY_PROVENANCE
+  iprov = __raw_inode_provenance(inode);
+#endif
+
+  prot &= (PROT_READ|PROT_WRITE);
+  //if((prot & (PROT_WRITE|PROT_EXEC)) != 0){
+  if((prot & PROT_WRITE) != 0){
+    if(!ifc_can_flow(&cifc->context, &iifc->context)){
+#ifdef CONFIG_SECURITY_PROVENANCE
+      record_relation(RL_MMAP_WRITE, cprov, iprov, FLOW_DISALLOWED);
+#endif
+      return -EPERM;
+    }
+  }
+
+  if((prot & (PROT_READ|PROT_WRITE)) != 0){
+    // we assume write imply read
+    if(!ifc_can_flow(&iifc->context, &cifc->context)){
+#ifdef CONFIG_SECURITY_PROVENANCE
+      record_relation(RL_MMAP_READ, iprov, cprov, FLOW_DISALLOWED);
+#endif
+      return -EPERM;
+    }
+  }
+  return 0;
+}
+
+/*
+* Allocate and attach a security structure to the shp->shm_perm.security
+* field.  The security field is initialized to NULL when the structure is
+* first created.
+* @shp contains the shared memory structure to be modified.
+* Return 0 if operation was successful and permission is granted.
+*/
+static int ifc_shm_alloc_security(struct shmid_kernel *shp)
+{
+  struct ifc_struct* cifc = current_ifc();
+  struct ifc_struct* sifc= inherit_ifc(cifc, GFP_KERNEL);
+
+  if(!sifc)
+    return -ENOMEM;
+
+  shp->shm_perm.ifc=sifc;
+	return 0;
+}
+
+/*
+* Deallocate the security struct for this memory segment.
+* @shp contains the shared memory structure to be modified.
+*/
+static void ifc_shm_free_security(struct shmid_kernel *shp)
+{
+  free_ifc(shp->shm_perm.ifc);
+  shp->shm_perm.ifc=NULL;
+}
+
+/*
+* Check permissions prior to allowing the shmat system call to attach the
+* shared memory segment @shp to the data segment of the calling process.
+* The attaching address is specified by @shmaddr.
+* @shp contains the shared memory structure to be modified.
+* @shmaddr contains the address to attach memory region to.
+* @shmflg contains the operational flags.
+* Return 0 if permission is granted.
+*/
+static int ifc_shm_shmat(struct shmid_kernel *shp,
+			     char __user *shmaddr, int shmflg)
+{
+  struct ifc_struct* cifc = current_ifc();
+  struct ifc_struct* sifc = shp->shm_perm.ifc;
+#ifdef CONFIG_SECURITY_PROVENANCE
+  prov_msg_t* cprov = current_provenance();
+	prov_msg_t* sprov = shp->shm_perm.provenance;
+#endif
+
+  if(!sprov)
+    return -ENOMEM;
+
+  if(shmflg & SHM_RDONLY){
+    if(!ifc_can_flow(&sifc->context, &cifc->context)){
+#ifdef CONFIG_SECURITY_PROVENANCE
+      record_relation(RL_ATTACH, sprov, cprov, FLOW_DISALLOWED);
+#endif
+      return -EPERM;
+    }
+  }else{
+    if(!ifc_can_flow(&sifc->context, &cifc->context) || !ifc_can_flow(&cifc->context, &sifc->context)){
+#ifdef CONFIG_SECURITY_PROVENANCE
+      record_relation(RL_ATTACH, sprov, cprov, FLOW_DISALLOWED);
+      record_relation(RL_ATTACH, cprov, sprov, FLOW_DISALLOWED);
+#endif
+      return -EPERM;
+    }
+  }
+	return 0;
+}
+
+/*
+* Save security information in the bprm->security field, typically based
+* on information about the bprm->file, for later use by the apply_creds
+* hook.  This hook may also optionally check permissions (e.g. for
+* transitions between security domains).
+* This hook may be called multiple times during a single execve, e.g. for
+* interpreters.  The hook can tell whether it has already been called by
+* checking to see if @bprm->security is non-NULL.  If so, then the hook
+* may decide either to retain the security information saved earlier or
+* to replace it.
+* @bprm contains the linux_binprm structure.
+* Return 0 if the hook is successful and permission is granted.
+*/
+static int ifc_bprm_set_creds(struct linux_binprm *bprm){
+  int rv=0;
+  struct inode *inode = file_inode(bprm->file);
+  struct ifc_struct* old_ifc = current_ifc();
+  struct ifc_struct* new_ifc = bprm->cred->ifc;
+  struct ifc_struct* file_ifc = inode_get_ifc(inode);
+
+  if(!old_ifc){
+    if(ifc_is_labelled(&old_ifc->context)){
+      printk(KERN_INFO "bprm_set_creds.\n");
+    }
+  }
+
+  if(!old_ifc && !file_ifc && !new_ifc){
+    if(ifc_is_labelled(&file_ifc->context)){
+      rv |= ifc_merge_context(&new_ifc->context, &file_ifc->context);
+    }
+    if(ifc_is_labelled(&old_ifc->context)){
+      rv |= ifc_merge_context(&new_ifc->context, &old_ifc->context);
+    }
+  }
+  return rv;
+}
+
+/*
+* Allocate and attach a security structure to the sk->sk_security field,
+* which is used to copy security attributes between local stream sockets.
+*/
+static int ifc_sk_alloc_security(struct sock *sk, int family, gfp_t priority)
+{
+  struct ifc_struct* cifc = current_ifc();
+  struct ifc_struct* ifc = alloc_ifc(priority);;
+  sk->sk_ifc=ifc;
+  if(!ifc_is_labelled(&cifc->context)){
+    return 0;
+  }
+
+  if(family!=AF_UNIX && family!=AF_NETLINK && family!=AF_ALG){
+    return -EPERM;
+  }
+  /* we trust socket to crypto stuff, should we? */
+  if(family==AF_ALG){
+    ifc->context.trusted = IFC_TRUSTED;
+  }else if(family==AF_UNIX){
+    ifc = inherit_ifc(cifc, priority);
+    sk->sk_ifc=ifc;
+  }
+  return 0;
+}
+
+/*
+* Deallocate security structure.
+*/
+static void ifc_sk_free_security(struct sock *sk)
+{
+  if(sk->sk_ifc!=NULL)
+    free_ifc(sk->sk_ifc);
+	sk->sk_ifc = NULL;
+}
+
+/*
+* This hook allows a module to update or allocate a per-socket security
+* structure. Note that the security field was not added directly to the
+* socket structure, but rather, the socket security information is stored
+* in the associated inode.  Typically, the inode alloc_security hook will
+* allocate and and attach security information to
+* sock->inode->i_security.  This hook may be used to update the
+* sock->inode->i_security field with additional information that wasn't
+* available when the inode was allocated.
+* @sock contains the newly created socket structure.
+* @family contains the requested protocol family.
+* @type contains the requested communications type.
+* @protocol contains the requested protocol.
+* @kern set to 1 if a kernel socket.
+*/
+static int ifc_socket_post_create(struct socket *sock, int family,
+				      int type, int protocol, int kern)
+{
+  struct ifc_struct* cifc  = current_ifc();
+  struct ifc_struct* iifc  = inode_get_ifc(SOCK_INODE(sock));
+  struct ifc_struct* skifc = NULL;
+  int rc;
+
+  if(kern){
+    return 0;
+  }
+
+  if(!sock->sk->sk_ifc){
+		rc = ifc_sk_alloc_security(sock->sk, family, GFP_KERNEL);
+    if(rc)
+      return rc;
+	}
+
+  if(!ifc_is_labelled(&cifc->context)){
+    return 0;
+  }
+
+  if(family!=AF_UNIX && family!=AF_NETLINK && family!=AF_ALG){
+    return -EPERM;
+  }
+
+  skifc = sock->sk->sk_ifc;
+
+  if(family==AF_NETLINK){
+    if(protocol!=NETLINK_CAMFLOW_IFC_BRIDGE){
+      return -EPERM;
+    }else{
+      skifc->context.trusted = IFC_TRUSTED;
+    }
+  }
+
+  memcpy(iifc, skifc, sizeof(struct ifc_struct));
+  return 0;
+}
+
+/*
+* Check permission before socket protocol layer bind operation is
+* performed and the socket @sock is bound to the address specified in the
+* @address parameter.
+* @sock contains the socket structure.
+* @address contains the address to bind to.
+* @addrlen contains the length of address.
+* Return 0 if permission is granted.
+*/
+static int ifc_socket_bind(struct socket *sock, struct sockaddr *address, int addrlen)
+{
+  return ifc_inode_permission(SOCK_INODE(sock), MAY_WRITE); // check if MAY_WRITE is ok
+}
+
+/*
+* Check permission before socket protocol layer connect operation
+* attempts to connect socket @sock to a remote address, @address.
+* @sock contains the socket structure.
+* @address contains the address of remote endpoint.
+* @addrlen contains the length of address.
+* Return 0 if permission is granted.
+*/
+static int ifc_socket_connect(struct socket *sock, struct sockaddr *address, int addrlen)
+{
+  return ifc_inode_permission(SOCK_INODE(sock), MAY_WRITE); // check if MAY_WRITE is ok
+}
+
+/*
+* Check permission before socket protocol layer listen operation.
+* @sock contains the socket structure.
+* @backlog contains the maximum length for the pending connection queue.
+* Return 0 if permission is granted.
+*/
+static int ifc_socket_listen(struct socket *sock, int backlog)
+{
+  return ifc_inode_permission(SOCK_INODE(sock), MAY_READ); // check if MAY_READ is ok
+}
+
+/*
+* Check permission before transmitting a message to another socket.
+* @sock contains the socket structure.
+* @msg contains the message to be transmitted.
+* @size contains the size of message.
+* Return 0 if permission is granted.
+*/
+static int ifc_socket_sendmsg(struct socket *sock, struct msghdr *msg,
+				  int size)
+{
+	return ifc_inode_permission(SOCK_INODE(sock), MAY_WRITE);
+}
+
+/*
+* Check permission before receiving a message from a socket.
+* @sock contains the socket structure.
+* @msg contains the message structure.
+* @size contains the size of message structure.
+* @flags contains the operational flags.
+* Return 0 if permission is granted.
+*/
+static int ifc_socket_recvmsg(struct socket *sock, struct msghdr *msg,
+				  int size, int flags)
+{
+	return ifc_inode_permission(SOCK_INODE(sock), MAY_READ);
+}
+
+/*
+* Check permission before accepting a new connection.  Note that the new
+* socket, @newsock, has been created and some information copied to it,
+* but the accept operation has not actually been performed.
+* @sock contains the listening socket structure.
+* @newsock contains the newly created server socket for connection.
+* Return 0 if permission is granted.
+*/
+static int ifc_socket_accept(struct socket *sock, struct socket *newsock)
+{
+  return ifc_inode_permission(SOCK_INODE(sock), MAY_READ);
+}
+
+/*
+* Check permissions before establishing a Unix domain stream connection
+* between @sock and @other.
+* @sock contains the sock structure.
+* @other contains the peer sock structure.
+* @newsk contains the new sock structure.
+* Return 0 if permission is granted.
+*/
+static int ifc_unix_stream_connect(struct sock *sock,
+					      struct sock *other,
+					      struct sock *newsk)
+{
+  struct ifc_struct* skifc = sock->sk_ifc;
+  struct ifc_struct* okifc = other->sk_ifc;
+  struct ifc_struct* nifc = newsk->sk_ifc;
+
+  if(!ifc_is_labelled(&skifc->context) && !ifc_is_labelled(&okifc->context))
+    return 0;
+
+  if(!ifc_can_flow(&skifc->context, &okifc->context))
+    return -EPERM;
+  if(!ifc_can_flow(&okifc->context, &skifc->context))
+    return -EPERM;
+  memcpy(nifc, skifc, sizeof(struct ifc_struct));
+  return 0;
+}
+
+/*
+* Check permissions before connecting or sending datagrams from @sock to
+* @other.
+* @sock contains the socket structure.
+* @other contains the peer socket structure.
+* Return 0 if permission is granted.
+*/
+static int ifc_unix_may_send(struct socket *sock,
+					struct socket *other)
+{
+  struct ifc_struct* skifc = sock->sk->sk_ifc;
+  struct ifc_struct* okifc = other->sk->sk_ifc;
+
+  if(!ifc_is_labelled(&skifc->context) && !ifc_is_labelled(&okifc->context))
+    return 0;
+
+  if(!ifc_can_flow(&skifc->context, &okifc->context))
+    return -EPERM;
+  return 0;
+}
+
+static struct security_hook_list ifc_hooks[] = {
+  LSM_HOOK_INIT(cred_alloc_blank, ifc_cred_alloc_blank),
+  LSM_HOOK_INIT(cred_free, ifc_cred_free),
+  LSM_HOOK_INIT(cred_prepare, ifc_cred_prepare),
+  LSM_HOOK_INIT(cred_transfer, ifc_cred_transfer),
+  LSM_HOOK_INIT(inode_alloc_security, ifc_inode_alloc_security),
+  LSM_HOOK_INIT(inode_free_security, ifc_inode_free_security),
+  LSM_HOOK_INIT(inode_permission, ifc_inode_permission),
+  LSM_HOOK_INIT(file_permission, ifc_file_permission),
+  LSM_HOOK_INIT(msg_msg_alloc_security, ifc_msg_msg_alloc_security),
+  LSM_HOOK_INIT(msg_msg_free_security, ifc_msg_msg_free_security),
+  LSM_HOOK_INIT(msg_queue_msgsnd, ifc_msg_queue_msgsnd),
+  LSM_HOOK_INIT(msg_queue_msgrcv, ifc_msg_queue_msgrcv),
+  LSM_HOOK_INIT(mmap_file, ifc_mmap_file),
+  LSM_HOOK_INIT(shm_alloc_security, ifc_shm_alloc_security),
+  LSM_HOOK_INIT(shm_free_security, ifc_shm_free_security),
+  LSM_HOOK_INIT(shm_shmat, ifc_shm_shmat),
+  LSM_HOOK_INIT(bprm_set_creds, ifc_bprm_set_creds),
+  LSM_HOOK_INIT(sk_alloc_security, ifc_sk_alloc_security),
+  LSM_HOOK_INIT(sk_free_security, ifc_sk_free_security),
+  LSM_HOOK_INIT(socket_post_create, ifc_socket_post_create),
+  LSM_HOOK_INIT(socket_bind, ifc_socket_bind),
+  LSM_HOOK_INIT(socket_connect, ifc_socket_connect),
+  LSM_HOOK_INIT(socket_listen, ifc_socket_listen),
+  LSM_HOOK_INIT(socket_sendmsg, ifc_socket_sendmsg),
+  LSM_HOOK_INIT(socket_recvmsg, ifc_socket_recvmsg),
+  LSM_HOOK_INIT(socket_accept, ifc_socket_accept),
+  LSM_HOOK_INIT(unix_stream_connect, ifc_unix_stream_connect),
+  LSM_HOOK_INIT(unix_may_send, ifc_unix_may_send)
+};
+
+/* init security of the first process */
+static void cred_init_security(void){
+	struct cred *cred = (struct cred *)current->real_cred;
+	struct ifc_struct *ifc;
+
+  ifc = alloc_ifc(GFP_KERNEL);
+	if(!ifc){
+		panic("IFC: Failed to initialize initial task.\n");
+	}
+	cred->ifc = ifc;
+}
+
+atomic64_t ifc_tag_count=ATOMIC64_INIT(1);
+
+struct kmem_cache *camflow_cache=NULL;
+
+void __init ifc_add_hooks(void){
+  ifc_cache = kmem_cache_create("ifc_struct",
+					    sizeof(struct ifc_struct),
+					    0, SLAB_PANIC, NULL);
+
+  camflow_cache = kmem_cache_create("camflow_i_ptr",
+					    sizeof(struct camflow_i_ptr),
+					    0, SLAB_PANIC, NULL);
+
+  cred_init_security();
+  security_add_hooks(ifc_hooks, ARRAY_SIZE(ifc_hooks));
+
+  printk(KERN_INFO "IFC Camflow %s\n", CAMFLOW_VERSION_STR);
+  printk(KERN_INFO "IFC hooks ready.\n");
+}
diff -uprN ./pristine/linux-4.4.25/security/ifc/include/ifc.h ./linux-4.4.25/security/ifc/include/ifc.h
--- ./pristine/linux-4.4.25/security/ifc/include/ifc.h	1969-12-31 16:00:00.000000000 -0800
+++ ./linux-4.4.25/security/ifc/include/ifc.h	2016-10-19 03:14:47.582690427 -0700
@@ -0,0 +1,389 @@
+/*
+*
+* Author: Thomas Pasquier <thomas.pasquier@cl.cam.ac.uk>
+*
+* Copyright (C) 2015 University of Cambridge
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License version 2, as
+* published by the Free Software Foundation; either version 2 of the License, or
+*	(at your option) any later version.
+*
+*/
+#ifndef _LINUX_IFC_H
+#define _LINUX_IFC_H
+
+#ifdef CONFIG_SECURITY_IFC
+
+#include <linux/slab.h>
+#include <linux/sort.h>
+#include <linux/bsearch.h>
+#include <uapi/linux/ifc.h>
+#include <uapi/linux/camflow.h>
+#include <linux/crypto.h>
+
+struct ifc_bridge{
+  bool spawner;
+  bool bridge;
+  pid_t remote_pid;
+};
+
+struct ifc_struct{
+  struct ifc_context context;
+  struct ifc_bridge bridge;
+};
+
+int ifc_create_bridge(pid_t parent_pid, char **argv[]);
+int ifc_bridge_send_message(void* data, size_t size);
+int ifc_bridge_init(void);
+
+extern atomic64_t ifc_tag_count;
+extern struct crypto_cipher *ifc_tfm;
+
+static inline void ifc_save_counter(tag_t counter){
+  // TODO
+}
+
+static inline uint64_t ifc_next_tag_count( void ){
+  uint64_t tag = (uint64_t)atomic64_inc_return(&ifc_tag_count);
+  ifc_save_counter(tag);
+  return tag;
+}
+
+static inline void ifc_set_tag_count(uint64_t count){
+  atomic64_set(&ifc_tag_count, count);
+}
+
+static inline tag_t ifc_create_tag(void){
+  uint64_t in = ifc_next_tag_count();
+  uint64_t out = 0;
+  crypto_cipher_encrypt_one(ifc_tfm, (u8*)&out, (u8*)&in);
+  return out;
+}
+
+static inline bool ifc_tag_valid(tag_t tag){
+  tag_t out;
+  tag_t counter = atomic64_read(&ifc_tag_count);
+  crypto_cipher_decrypt_one(ifc_tfm, (u8*)&out, (u8*)&tag);
+  if(out>counter)
+    return false;
+  return true;
+}
+
+static int ifc_compare(const void *lhs, const void *rhs) {
+    uint64_t lhs_integer = *(const uint64_t *)(lhs);
+    uint64_t rhs_integer = *(const uint64_t *)(rhs);
+
+    if (lhs_integer < rhs_integer) return -1;
+    if (lhs_integer > rhs_integer) return 1;
+    return 0;
+}
+
+static inline void ifc_sort_label(struct ifc_label* label){
+  sort(label->array, label->size, sizeof(uint64_t), &ifc_compare, NULL);
+}
+
+static inline bool ifc_is_subset(struct ifc_label* sub, struct ifc_label* set){
+  int i=0, j=0;
+
+  if(sub->size == 0) // empty set is subset of everything
+    return true;
+
+  if(set->size < sub->size)
+    return false;
+
+  while( i < sub->size && j < set->size)
+  {
+    if( set->array[j] < sub->array[i] ){
+      j++;
+    }else if( set->array[j] == sub->array[i] ){
+      j++;
+      i++;
+    }else if( set->array[j] > sub->array[i] ){
+      return false;
+    }
+  }
+
+  if(i < sub->size)
+    return false;
+  return true;
+}
+
+static inline bool ifc_can_flow(struct ifc_context *from, struct ifc_context* to){
+  if(from->trusted==IFC_TRUSTED || to->trusted==IFC_TRUSTED){
+    return true;
+  }
+  if(!ifc_is_subset(&from->secrecy, &to->secrecy)){
+    return false;
+  }
+  if(!ifc_is_subset(&to->integrity, &from->integrity)){
+    return false;
+  }
+  return true;
+}
+
+static inline bool ifc_contains_value(struct ifc_label* label, tag_t value){
+  if(bsearch(&value, label->array, label->size, sizeof(uint64_t), &ifc_compare)==NULL){
+    return false;
+  }
+  return true;
+}
+
+static inline bool ifc_is_labelled(struct ifc_context* context){
+  if(context->secrecy.size > 0 || context->integrity.size > 0)
+    return true;
+  return false;
+}
+
+static inline int ifc_add_privilege(struct ifc_context* context, uint8_t type, tag_t tag){
+  struct ifc_label* privilege=NULL;
+
+  switch(type){
+    case IFC_SECRECY_P:
+      privilege = &context->secrecy_p;
+      break;
+    case IFC_INTEGRITY_P:
+      privilege = &context->integrity_p;
+      break;
+    case IFC_SECRECY_N:
+      privilege = &context->secrecy_n;
+      break;
+    case IFC_INTEGRITY_N:
+      privilege = &context->integrity_n;
+      break;
+  }
+
+  if(privilege==NULL)
+    return -EINVAL;
+
+  if(privilege->size +1 >= IFC_LABEL_MAX_SIZE) // label is full
+    return -ENOMEM;
+
+  if(ifc_contains_value(privilege, tag)) // aleady contains tag
+    return -EINVAL;
+
+  privilege->array[privilege->size] = tag;
+  privilege->size++;
+  ifc_sort_label(privilege);
+  return 0;
+}
+
+static inline int ifc_remove_privilege(struct ifc_context* context, uint8_t type, tag_t tag){
+  struct ifc_label* privilege=NULL;
+  int i = 0;
+
+  switch(type){
+    case IFC_SECRECY_P:
+      privilege = &context->secrecy_p;
+      break;
+    case IFC_INTEGRITY_P:
+      privilege = &context->integrity_p;
+      break;
+    case IFC_SECRECY_N:
+      privilege = &context->secrecy_n;
+      break;
+    case IFC_INTEGRITY_N:
+      privilege = &context->integrity_n;
+      break;
+  }
+
+  if(privilege==NULL)
+    return -EINVAL;
+
+  if(privilege->size <= 0) // label is empty
+    return -EINVAL;
+
+  if(!ifc_contains_value(privilege, tag)) // does not contains the privilege to be removed
+    return -EINVAL;
+
+  /* remove the tag */
+  for(i=0; i < privilege->size; i++){
+    if(privilege->array[i]==tag)
+      break;
+  }
+  for(;i < privilege->size-1; i++){
+    privilege->array[i]=privilege->array[i+1];
+  }
+  privilege->size--;
+  return 0;
+}
+
+static inline int ifc_add_tag(struct ifc_context* context, uint8_t type, tag_t tag){
+  struct ifc_label* label=NULL;
+  struct ifc_label* privilege=NULL;
+
+  switch(type){
+    case IFC_SECRECY:
+      label = &context->secrecy;
+      privilege = &context->secrecy_p;
+      break;
+    case IFC_INTEGRITY:
+      label = &context->integrity;
+      privilege = &context->integrity_p;
+      break;
+  }
+
+  if(privilege==NULL || label==NULL)
+    return -EINVAL;
+
+  if(label->size + 1 >= IFC_LABEL_MAX_SIZE) // label is full
+    return -ENOMEM;
+
+  if(ifc_contains_value(label, tag)) // aleady contains tag
+    return -EINVAL;
+
+  if(!ifc_contains_value(privilege, tag)) // not appropriate privilege
+    return -EPERM;
+
+  label->array[label->size]=tag;
+  label->size++;
+  ifc_sort_label(label);
+  return 0;
+}
+
+static inline int ifc_add_tag_no_check(struct ifc_context* context, uint8_t type, tag_t tag){
+  struct ifc_label* label=NULL;
+
+  switch(type){
+    case IFC_SECRECY:
+      label = &context->secrecy;
+      break;
+    case IFC_INTEGRITY:
+      label = &context->integrity;
+      break;
+  }
+
+  if(label==NULL)
+    return -EINVAL;
+
+  if(label->size >= IFC_LABEL_MAX_SIZE) // label is full
+    return -ENOMEM;
+
+  if(ifc_contains_value(label, tag)) // aleady contains tag
+    return -EINVAL;
+
+  label->array[label->size]=tag;
+  label->size++;
+  ifc_sort_label(label);
+  return 0;
+}
+
+static inline int ifc_remove_tag(struct ifc_context* context, uint8_t type, tag_t tag){
+  struct ifc_label* label=NULL;
+  struct ifc_label* privilege=NULL;
+  int i = 0;
+
+  switch(type){
+    case IFC_SECRECY:
+      label = &context->secrecy;
+      privilege = &context->secrecy_n;
+      break;
+    case IFC_INTEGRITY:
+      label = &context->integrity;
+      privilege = &context->integrity_n;
+      break;
+  }
+
+  if(privilege==NULL || label==NULL)
+    return -EINVAL;
+
+  if(label->size <= 0) // label is empty
+    return -EINVAL;
+
+  if(!ifc_contains_value(label, tag)) // the tag is not there to removed
+    return -EINVAL;
+
+  if(!ifc_contains_value(privilege, tag)) // does not have the proper privileges
+    return -EPERM;
+
+  /* remove the tag */
+  for(i=0; i < label->size; i++){
+    if(label->array[i]==tag)
+      break;
+  }
+  for(;i < label->size-1; i++){
+    label->array[i]=label->array[i+1];
+  }
+  label->size--;
+  return 0;
+}
+
+static inline int ifc_remove_tag_no_check(struct ifc_context* context, uint8_t type, tag_t tag){
+  struct ifc_label* label=NULL;
+  int i = 0;
+
+  switch(type){
+    case IFC_SECRECY:
+      label = &context->secrecy;
+      break;
+    case IFC_INTEGRITY:
+      label = &context->integrity;
+      break;
+  }
+
+  if(label==NULL)
+    return -EINVAL;
+
+  if(label->size <= 0) // label is empty
+    return -EINVAL;
+
+  if(!ifc_contains_value(label, tag)) // the tag is not there to removed
+    return -EINVAL;
+
+  /* remove the tag */
+  for(i=0; i < label->size; i++){
+    if(label->array[i]==tag)
+      break;
+  }
+  for(;i < label->size-1; i++){
+    label->array[i]=label->array[i+1];
+  }
+  label->size--;
+  return 0;
+}
+
+static inline void print_label(struct ifc_label* label){
+  int i;
+  for(i=0; i < label->size; i++){
+    printk(KERN_INFO "IFC: %llu", label->array[i]);
+  }
+}
+
+static inline int ifc_merge_context(struct ifc_context* main, struct ifc_context* to_add){
+  int i;
+
+  // too conservative TODO change this
+  if(main->secrecy.size + to_add->secrecy.size > IFC_LABEL_MAX_SIZE)
+      return -ENOMEM;
+  if(main->integrity.size + to_add->integrity.size > IFC_LABEL_MAX_SIZE)
+      return -ENOMEM;
+
+  for(i=0; i<to_add->secrecy.size; i++){
+    ifc_add_tag_no_check(main, IFC_SECRECY, to_add->secrecy.array[i]);
+  }
+
+  for(i=0; i<to_add->integrity.size; i++){
+    ifc_add_tag_no_check(main, IFC_INTEGRITY, to_add->integrity.array[i]);
+  }
+  return 0;
+}
+
+static inline void print_context(struct ifc_context* context){
+  if(context->trusted==IFC_TRUSTED){
+    printk(KERN_INFO "TRUSTED");
+  }
+  printk(KERN_INFO "IFC SECRECY (%d)", context->secrecy.size);
+  print_label(&context->secrecy);
+  printk(KERN_INFO "IFC INTEGRITY (%d)", context->integrity.size);
+  print_label(&context->integrity);
+}
+
+static inline struct ifc_struct* ifc_from_pid(pid_t pid){
+  struct task_struct *dest = find_task_by_vpid(pid);
+  if(!dest)
+    return NULL;
+  return __task_cred(dest)->ifc;
+}
+
+#endif
+#endif
diff -uprN ./pristine/linux-4.4.25/security/ifc/Kconfig ./linux-4.4.25/security/ifc/Kconfig
--- ./pristine/linux-4.4.25/security/ifc/Kconfig	1969-12-31 16:00:00.000000000 -0800
+++ ./linux-4.4.25/security/ifc/Kconfig	2016-10-19 03:14:47.582690427 -0700
@@ -0,0 +1,9 @@
+config SECURITY_IFC
+         bool "CamFlow - IFC"
+         depends on SECURITY
+         select SECURITYFS
+         select CRYPTO_BLOWFISH_X86_64
+         default n
+         help
+          This selects IFC.
+          The IFC security module enforce DIFC.
diff -uprN ./pristine/linux-4.4.25/security/ifc/Makefile ./linux-4.4.25/security/ifc/Makefile
--- ./pristine/linux-4.4.25/security/ifc/Makefile	1969-12-31 16:00:00.000000000 -0800
+++ ./linux-4.4.25/security/ifc/Makefile	2016-10-19 03:14:47.582690427 -0700
@@ -0,0 +1,8 @@
+#
+# Makefile for Provenance LSM
+#
+obj-$(CONFIG_SECURITY_IFC) := ifc.o
+
+ifc-y := hooks.o fs.o bridge.o
+
+ccflags-y := -I$(srctree)/security/camflow -I$(srctree)/security/camflow/include -I$(srctree)/security/ifc/include -I$(srctree)/security/provenance/include
diff -uprN ./pristine/linux-4.4.25/security/Kconfig ./linux-4.4.25/security/Kconfig
--- ./pristine/linux-4.4.25/security/Kconfig	2016-10-16 08:48:03.000000000 -0700
+++ ./linux-4.4.25/security/Kconfig	2016-10-19 03:14:47.580690410 -0700
@@ -123,6 +123,8 @@ source security/smack/Kconfig
 source security/tomoyo/Kconfig
 source security/apparmor/Kconfig
 source security/yama/Kconfig
+source security/provenance/Kconfig
+source security/ifc/Kconfig
 
 source security/integrity/Kconfig
 
@@ -132,6 +134,8 @@ choice
 	default DEFAULT_SECURITY_SMACK if SECURITY_SMACK
 	default DEFAULT_SECURITY_TOMOYO if SECURITY_TOMOYO
 	default DEFAULT_SECURITY_APPARMOR if SECURITY_APPARMOR
+	default DEFAULT_SECURITY_PROVENANCE if SECURITY_PROVENANCE
+	default DEFAULT_SECURITY_IFC if SECURITY_IFC
 	default DEFAULT_SECURITY_DAC
 
 	help
@@ -150,6 +154,12 @@ choice
 	config DEFAULT_SECURITY_APPARMOR
 		bool "AppArmor" if SECURITY_APPARMOR=y
 
+	config DEFAULT_SECURITY_PROVENANCE
+		bool "CamFlow - Provenance" if SECURITY_PROVENANCE=y
+
+	config DEFAULT_SECURITY_IFC
+		bool "CamFlow - IFC" if SECURITY_IFC=y
+
 	config DEFAULT_SECURITY_DAC
 		bool "Unix Discretionary Access Controls"
 
@@ -161,7 +171,8 @@ config DEFAULT_SECURITY
 	default "smack" if DEFAULT_SECURITY_SMACK
 	default "tomoyo" if DEFAULT_SECURITY_TOMOYO
 	default "apparmor" if DEFAULT_SECURITY_APPARMOR
+	default "provenance" if DEFAULT_SECURITY_PROVENANCE
+	default "ifc" if DEFAULT_SECURITY_IFC
 	default "" if DEFAULT_SECURITY_DAC
 
 endmenu
-
diff -uprN ./pristine/linux-4.4.25/security/Makefile ./linux-4.4.25/security/Makefile
--- ./pristine/linux-4.4.25/security/Makefile	2016-10-16 08:48:03.000000000 -0700
+++ ./linux-4.4.25/security/Makefile	2016-10-19 03:14:47.580690410 -0700
@@ -8,6 +8,8 @@ subdir-$(CONFIG_SECURITY_SMACK)		+= smac
 subdir-$(CONFIG_SECURITY_TOMOYO)        += tomoyo
 subdir-$(CONFIG_SECURITY_APPARMOR)	+= apparmor
 subdir-$(CONFIG_SECURITY_YAMA)		+= yama
+subdir-$(CONFIG_SECURITY_PROVENANCE)	+= provenance
+subdir-$(CONFIG_SECURITY_IFC)	+= ifc
 
 # always enable default capabilities
 obj-y					+= commoncap.o
@@ -22,6 +24,8 @@ obj-$(CONFIG_AUDIT)			+= lsm_audit.o
 obj-$(CONFIG_SECURITY_TOMOYO)		+= tomoyo/
 obj-$(CONFIG_SECURITY_APPARMOR)		+= apparmor/
 obj-$(CONFIG_SECURITY_YAMA)		+= yama/
+obj-$(CONFIG_SECURITY_PROVENANCE)		+= provenance/
+obj-$(CONFIG_SECURITY_IFC)		+= ifc/
 obj-$(CONFIG_CGROUP_DEVICE)		+= device_cgroup.o
 
 # Object integrity file lists
diff -uprN ./pristine/linux-4.4.25/security/provenance/fs.c ./linux-4.4.25/security/provenance/fs.c
--- ./pristine/linux-4.4.25/security/provenance/fs.c	1969-12-31 16:00:00.000000000 -0800
+++ ./linux-4.4.25/security/provenance/fs.c	2016-10-19 03:14:47.582690427 -0700
@@ -0,0 +1,488 @@
+/*
+*
+* Author: Thomas Pasquier <thomas.pasquier@cl.cam.ac.uk>
+*
+* Copyright (C) 2015 University of Cambridge
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License version 2, as
+* published by the Free Software Foundation; either version 2 of the License, or
+*	(at your option) any later version.
+*
+*/
+
+#include <linux/security.h>
+#include <linux/camflow.h>
+
+#include "provenance.h"
+#include "provenance_inode.h"
+#include "provenance_task.h"
+#include "camflow_utils.h"
+
+#define TMPBUFLEN	12
+
+#define declare_file_operations(ops_name, write_op, read_op) static const struct file_operations ops_name = { \
+		.write		= write_op,\
+	  .read     = read_op,\
+		.llseek		= generic_file_llseek,\
+	}
+
+static ssize_t no_read(struct file *filp, char __user *buf,
+				size_t count, loff_t *ppos)
+{
+	return -EPERM; // write only
+}
+
+/*static ssize_t no_write(struct file *file, const char __user *buf,
+				 size_t count, loff_t *ppos)
+{
+	return -EPERM; // read only
+}*/ // not used anymore
+
+static inline void __init_opaque(void){
+	provenance_mark_as_opaque(PROV_ENABLE_FILE);
+	provenance_mark_as_opaque(PROV_ALL_FILE);
+	provenance_mark_as_opaque(PROV_NODE_FILE);
+	provenance_mark_as_opaque(PROV_RELATION_FILE);
+	provenance_mark_as_opaque(PROV_SELF_FILE);
+	provenance_mark_as_opaque(PROV_MACHINE_ID_FILE);
+	provenance_mark_as_opaque(PROV_NODE_FILTER_FILE);
+	provenance_mark_as_opaque(PROV_RELATION_FILTER_FILE);
+	provenance_mark_as_opaque(PROV_PROPAGATE_NODE_FILTER_FILE);
+	provenance_mark_as_opaque(PROV_PROPAGATE_RELATION_FILTER_FILE);
+	provenance_mark_as_opaque(PROV_FLUSH_FILE);
+	provenance_mark_as_opaque(PROV_FILE_FILE);
+}
+
+static inline ssize_t __write_flag(struct file *file, const char __user *buf,
+				 size_t count, loff_t *ppos, bool *flag)
+
+{
+  char* page = NULL;
+  ssize_t length;
+  bool new_value;
+  int tmp;
+
+  /* no partial write */
+  if(*ppos > 0)
+    return -EINVAL;
+
+  if(__kuid_val(current_euid())!=0)
+    return -EPERM;
+
+  page = (char *)get_zeroed_page(GFP_KERNEL);
+  if (!page)
+    return -ENOMEM;
+
+  length=-EFAULT;
+	if (copy_from_user(page, buf, count))
+		goto out;
+
+  length = -EINVAL;
+  if (sscanf(page, "%d", &tmp) != 1)
+		goto out;
+
+  new_value=tmp;
+  (*flag)=new_value;
+  length=count;
+out:
+  free_page((unsigned long)page);
+  return length;
+}
+
+static ssize_t __read_flag(struct file *filp, char __user *buf,
+				size_t count, loff_t *ppos, bool flag)
+{
+	char tmpbuf[TMPBUFLEN];
+	ssize_t length;
+  int tmp = flag;
+
+	length = scnprintf(tmpbuf, TMPBUFLEN, "%d", tmp);
+	return simple_read_from_buffer(buf, count, ppos, tmpbuf, length);
+}
+
+#define declare_write_flag_fcn(fcn_name, flag) static ssize_t fcn_name (struct file *file, const char __user *buf, size_t count, loff_t *ppos){\
+		return __write_flag(file, buf, count, ppos, &flag);\
+	}
+#define declare_read_flag_fcn(fcn_name, flag) static ssize_t fcn_name (struct file *filp, char __user *buf, size_t count, loff_t *ppos){\
+		return __read_flag(filp, buf, count, ppos, flag);\
+	}
+
+bool prov_enabled=false;
+declare_write_flag_fcn(prov_write_enable, prov_enabled);
+declare_read_flag_fcn(prov_read_enable, prov_enabled);
+declare_file_operations(prov_enable_ops, prov_write_enable, prov_read_enable);
+
+bool prov_all=false;
+declare_write_flag_fcn(prov_write_all, prov_all);
+declare_read_flag_fcn(prov_read_all, prov_all);
+declare_file_operations(prov_all_ops, prov_write_all, prov_read_all);
+
+static ssize_t prov_write_machine_id(struct file *file, const char __user *buf,
+				 size_t count, loff_t *ppos)
+{
+	uint32_t* tmp = (uint32_t*)buf;
+
+	// ideally should be decoupled from set machine id
+	__init_opaque();
+
+	if(__kuid_val(current_euid())!=0) // only allowed for root
+    return -EPERM;
+
+	if(count < sizeof(uint32_t))
+	{
+		return -ENOMEM;
+	}
+
+	if(copy_from_user(&prov_machine_id, tmp, sizeof(uint32_t)))
+	{
+		return -EAGAIN;
+	}
+
+	return count; // read only
+}
+
+static ssize_t prov_read_machine_id(struct file *filp, char __user *buf,
+				size_t count, loff_t *ppos)
+{
+	if(count < sizeof(uint32_t))
+	{
+		return -ENOMEM;
+	}
+
+	if(copy_to_user(buf, &prov_machine_id, sizeof(uint32_t)))
+	{
+		return -EAGAIN;
+	}
+	return count;
+}
+
+declare_file_operations(prov_machine_id_ops, prov_write_machine_id, prov_read_machine_id);
+
+static ssize_t prov_write_node(struct file *file, const char __user *buf,
+				 size_t count, loff_t *ppos)
+
+{
+	prov_msg_t* cprov = task_provenance();
+	long_prov_msg_t* node;
+
+	if(count < sizeof(struct disc_node_struct)){
+		count = -ENOMEM;
+		goto out;
+	}
+
+	node = (long_prov_msg_t*)kzalloc(sizeof(long_prov_msg_t), GFP_KERNEL); // revert back to cache if causes performance issue
+	if(copy_from_user(node, buf, sizeof(struct disc_node_struct))){
+		count = -ENOMEM;
+		goto out;
+	}
+	if(prov_type(node)==MSG_DISC_ENTITY || prov_type(node)==MSG_DISC_ACTIVITY || prov_type(node)==MSG_DISC_AGENT){
+		__record_node(cprov);
+		copy_node_info(&node->disc_node_info.parent, &cprov->node_info.identifier);
+		node_identifier(node).id=prov_next_node_id();
+	  node_identifier(node).boot_id=prov_boot_id;
+	  node_identifier(node).machine_id=prov_machine_id;
+		long_prov_write(node);
+	}else{ // the node is not of disclosed type
+		count = -EINVAL;
+		goto out;
+	}
+
+	if(copy_to_user((void*)buf, &node, sizeof(struct disc_node_struct))){
+		count = -ENOMEM;
+		goto out;
+	}
+
+out:
+	put_prov(cprov);
+	kfree(node);
+	return count;
+}
+
+declare_file_operations(prov_node_ops, prov_write_node, no_read);
+
+static ssize_t prov_write_relation(struct file *file, const char __user *buf,
+				 size_t count, loff_t *ppos)
+{
+	prov_msg_t relation;
+
+	if(count < sizeof(struct relation_struct))
+	{
+		return -ENOMEM;
+	}
+	if(copy_from_user(&relation, buf, sizeof(struct relation_struct))){
+		return -ENOMEM;
+	}
+	prov_type((&relation)) = MSG_RELATION;
+	prov_write(&relation);
+	return count;
+}
+
+declare_file_operations(prov_relation_ops, prov_write_relation, no_read);
+
+static ssize_t prov_write_self(struct file *file, const char __user *buf,
+				 size_t count, loff_t *ppos)
+{
+	struct prov_self_config msg;
+  prov_msg_t* prov = task_provenance();
+	prov_msg_t* setting;
+	uint8_t op;
+	int rtn=sizeof(struct prov_self_config);
+
+  if(count < sizeof(struct prov_self_config)){
+    rtn = -EINVAL;
+		goto out;
+  }
+	if( copy_from_user(&msg, buf, sizeof(struct prov_self_config)) ){
+		rtn = -ENOMEM;
+		goto out;
+	}
+
+	setting = &(msg.prov);
+	op = msg.op;
+
+	if( (op & PROV_SET_TRACKED)!=0 ){
+		if( provenance_is_tracked(setting) ){
+			set_tracked(prov);
+		}else{
+			clear_tracked(prov);
+		}
+	}
+
+	if( (op & PROV_SET_OPAQUE)!=0 ){
+		if( provenance_is_opaque(setting) ){
+			set_opaque(prov);
+		}else{
+			clear_opaque(prov);
+		}
+	}
+
+	if( (op & PROV_SET_PROPAGATE)!=0 ){
+		if( provenance_propagate(setting) ){
+			set_propagate(prov);
+		}else{
+			clear_propagate(prov);
+		}
+	}
+
+	if( (op & PROV_SET_TAINT)!=0 ){
+		prov_bloom_merge( prov_taint(prov), prov_taint(setting) );
+	}
+
+out:
+	put_prov(prov);
+  return rtn;
+}
+
+static ssize_t prov_read_self(struct file *filp, char __user *buf,
+				size_t count, loff_t *ppos)
+{
+	prov_msg_t* tmp = (prov_msg_t*)buf;
+	prov_msg_t* cprov = task_provenance();
+
+	if(count < sizeof(struct task_prov_struct))
+	{
+		count = -ENOMEM;
+		goto out;
+	}
+	if(copy_to_user(tmp, cprov, sizeof(prov_msg_t))){
+		count = -EAGAIN;
+		goto out;
+	}
+
+out:
+	put_prov(cprov);
+	return count; // write only
+}
+
+declare_file_operations(prov_self_ops, prov_write_self, prov_read_self);
+
+static inline ssize_t __write_filter(struct file *file, const char __user *buf,
+				 size_t count, uint32_t* filter){
+	struct prov_filter* setting;
+
+	if(__kuid_val(current_euid())!=0){
+	 return -EPERM;
+	}
+
+	if(count < sizeof(struct prov_filter)){
+	 return -ENOMEM;
+	}
+
+	setting = (struct prov_filter*)buf;
+
+	if(setting->add!=0){
+		(*filter)|=setting->filter;
+	}else{
+		(*filter)&=~(setting->filter);
+	}
+	return count;
+}
+
+static inline ssize_t __read_filter(struct file *filp, char __user *buf,
+				size_t count, uint32_t filter){
+	if(count < sizeof(uint32_t)){
+	  return -ENOMEM;
+	}
+
+	if(copy_to_user(buf, &filter, sizeof(uint32_t)))
+	{
+		return -EAGAIN;
+	}
+	return count;
+}
+
+#define declare_write_filter_fcn(fcn_name, filter) static ssize_t fcn_name ( struct file *file, const char __user *buf,size_t count, loff_t *ppos ){\
+		return __write_filter(file, buf, count, &filter);\
+	}
+#define declare_reader_filter_fcn(fcn_name, filter) static ssize_t fcn_name (struct file *filp, char __user *buf, size_t count, loff_t *ppos) { \
+		return __read_filter(filp, buf, count, filter);\
+	}
+
+uint32_t prov_node_filter;
+declare_write_filter_fcn(prov_write_node_filter, prov_node_filter);
+declare_reader_filter_fcn(prov_read_node_filter, prov_node_filter);
+declare_file_operations(prov_node_filter_ops, prov_write_node_filter, prov_read_node_filter);
+
+uint32_t prov_relation_filter = 0;
+declare_write_filter_fcn(prov_write_relation_filter, prov_relation_filter);
+declare_reader_filter_fcn(prov_read_relation_filter, prov_relation_filter);
+declare_file_operations(prov_relation_filter_ops, prov_write_relation_filter, prov_read_relation_filter);
+
+uint32_t prov_propagate_node_filter = 0;
+declare_write_filter_fcn(prov_write_propagate_node_filter, prov_propagate_node_filter);
+declare_reader_filter_fcn(prov_read_propagate_node_filter, prov_propagate_node_filter);
+declare_file_operations(prov_propagate_node_filter_ops, prov_write_propagate_node_filter, prov_read_propagate_node_filter);
+
+uint32_t prov_propagate_relation_filter = 0;
+declare_write_filter_fcn(prov_write_propagate_relation_filter, prov_propagate_relation_filter);
+declare_reader_filter_fcn(prov_read_propagate_relation_filter, prov_propagate_relation_filter);
+declare_file_operations(prov_propagate_relation_filter_ops, prov_write_propagate_relation_filter, prov_read_propagate_relation_filter);
+
+static ssize_t prov_write_flush(struct file *file, const char __user *buf,
+				 size_t count, loff_t *ppos)
+
+{
+	if(__kuid_val(current_euid())!=0) // only allowed for root
+    return -EPERM;
+
+  prov_flush();
+	return 0;
+}
+
+declare_file_operations(prov_flush_ops, prov_write_flush, no_read);
+
+static ssize_t prov_write_file(struct file *file, const char __user *buf,
+				 size_t count, loff_t *ppos)
+{
+	struct prov_file_config *msg;
+  struct inode* in;
+  prov_msg_t* prov;
+	prov_msg_t* setting;
+	uint8_t op;
+
+  if(__kuid_val(current_euid())!=0)
+    return -EPERM;
+
+  if(count < sizeof(struct prov_file_config)){
+    return -EINVAL;
+  }
+
+  msg = (struct prov_file_config*)buf;
+
+  in = file_name_to_inode(msg->name);
+  if(!in){
+    printk(KERN_ERR "Provenance: could not find %s file.", msg->name);
+    return -EINVAL;
+  }
+	op = msg->op;
+	setting = &msg->prov;
+  prov = inode_provenance(in);
+
+	if( (op & PROV_SET_TRACKED)!=0 ){
+		if( provenance_is_tracked(setting) ){
+			set_tracked(prov);
+		}else{
+			clear_tracked(prov);
+		}
+	}
+
+	if( (op & PROV_SET_OPAQUE)!=0 ){
+		if( provenance_is_opaque(setting) ){
+			set_opaque(prov);
+		}else{
+			clear_opaque(prov);
+		}
+	}
+
+	if( (op & PROV_SET_PROPAGATE)!=0 ){
+		if( provenance_propagate(setting) ){
+			set_propagate(prov);
+		}else{
+			clear_propagate(prov);
+		}
+	}
+
+	if( (op & PROV_SET_TAINT)!=0 ){
+		prov_bloom_merge( prov_taint(prov), prov_taint(setting) );
+	}
+	put_prov(prov);
+  return sizeof(struct prov_file_config);
+}
+
+static ssize_t prov_read_file(struct file *filp, char __user *buf,
+				size_t count, loff_t *ppos)
+{
+  struct prov_file_config *msg;
+  struct inode* in;
+  prov_msg_t* prov;
+	int rtn=sizeof(struct prov_file_config);
+
+  if(count < sizeof(struct prov_file_config)){
+    return -EINVAL;
+  }
+
+  msg = (struct prov_file_config*)buf;
+  in = file_name_to_inode(msg->name);
+  if(!in){
+    printk(KERN_ERR "Provenance: could not find %s file.", msg->name);
+    return -EINVAL;
+  }
+
+  prov = inode_provenance(in);
+  if(copy_to_user(&msg->prov, prov, sizeof(prov_msg_t))){
+    rtn = -ENOMEM;
+		goto out; // a bit superfluous, but would avoid error if code changes
+  }
+out:
+	put_prov(prov);
+  return rtn;
+}
+
+declare_file_operations(prov_file_ops, prov_write_file, prov_read_file);
+
+static int __init init_prov_fs(void)
+{
+   struct dentry *prov_dir;
+
+   prov_dir = securityfs_create_dir("provenance", NULL);
+
+   securityfs_create_file("enable", 0644, prov_dir, NULL, &prov_enable_ops);
+	 securityfs_create_file("all", 0644, prov_dir, NULL, &prov_all_ops);
+	 securityfs_create_file("node", 0666, prov_dir, NULL, &prov_node_ops);
+	 securityfs_create_file("relation", 0666, prov_dir, NULL, &prov_relation_ops);
+	 securityfs_create_file("self", 0666, prov_dir, NULL, &prov_self_ops);
+	 securityfs_create_file("machine_id", 0444, prov_dir, NULL, &prov_machine_id_ops);
+	 securityfs_create_file("node_filter", 0644, prov_dir, NULL, &prov_node_filter_ops);
+	 securityfs_create_file("relation_filter", 0644, prov_dir, NULL, &prov_relation_filter_ops);
+	 securityfs_create_file("propagate_node_filter", 0644, prov_dir, NULL, &prov_propagate_node_filter_ops);
+	 securityfs_create_file("propagate_relation_filter", 0644, prov_dir, NULL, &prov_propagate_relation_filter_ops);
+	 securityfs_create_file("flush", 0600, prov_dir, NULL, &prov_flush_ops);
+	 securityfs_create_file("file", 0644, prov_dir, NULL, &prov_file_ops);
+
+	 printk(KERN_INFO "Provenance fs ready.\n");
+
+   return 0;
+}
+
+late_initcall_sync(init_prov_fs);
diff -uprN ./pristine/linux-4.4.25/security/provenance/hooks.c ./linux-4.4.25/security/provenance/hooks.c
--- ./pristine/linux-4.4.25/security/provenance/hooks.c	1969-12-31 16:00:00.000000000 -0800
+++ ./linux-4.4.25/security/provenance/hooks.c	2016-10-19 03:14:47.583690435 -0700
@@ -0,0 +1,1159 @@
+/*
+*
+* Author: Thomas Pasquier <thomas.pasquier@cl.cam.ac.uk>
+*
+* Copyright (C) 2015 University of Cambridge
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License version 2, as
+* published by the Free Software Foundation; either version 2 of the License, or
+*	(at your option) any later version.
+*
+*/
+#include <linux/slab.h>
+#include <linux/lsm_hooks.h>
+#include <linux/msg.h>
+#include <net/sock.h>
+#include <linux/binfmts.h>
+#include <linux/random.h>
+#include <linux/xattr.h>
+#include <linux/camflow.h>
+#include <linux/file.h>
+
+#include "av_utils.h"
+#include "provenance.h"
+#include "provenance_net.h"
+#include "provenance_inode.h"
+#include "provenance_task.h"
+#include "provenance_long.h"
+#include "ifc.h"
+
+/*
+ * initialise the security for the init task
+ */
+static void cred_init_provenance(void)
+{
+	struct cred *cred = (struct cred *) current->real_cred;
+	prov_msg_t *prov = alloc_provenance(MSG_TASK, GFP_KERNEL);
+	if (!prov)
+		panic("Provenance:  Failed to initialize initial task.\n");
+  set_node_id(prov, ASSIGN_NODE_ID);
+  prov->task_info.uid=__kuid_val(cred->euid);
+  prov->task_info.gid=__kgid_val(cred->egid);
+	set_opaque(prov);
+	cred->provenance = prov;
+}
+
+/*
+* @cred points to the credentials.
+* @gfp indicates the atomicity of any memory allocations.
+* Only allocate sufficient memory and attach to @cred such that
+* cred_transfer() will not get ENOMEM.
+*/
+static int provenance_cred_alloc_blank(struct cred *cred, gfp_t gfp)
+{
+  prov_msg_t* prov  = alloc_provenance(MSG_TASK, gfp);
+
+  if(!prov)
+    return -ENOMEM;
+  set_node_id(prov, ASSIGN_NODE_ID);
+
+  prov->task_info.uid=__kuid_val(cred->euid);
+  prov->task_info.gid=__kgid_val(cred->egid);
+
+  cred->provenance = prov;
+  return 0;
+}
+
+/*
+* @cred points to the credentials.
+* Deallocate and clear the cred->security field in a set of credentials.
+*/
+static void provenance_cred_free(struct cred *cred)
+{
+  free_provenance(cred->provenance);
+  cred->provenance = NULL;
+}
+
+/*
+* @new points to the new credentials.
+* @old points to the original credentials.
+* @gfp indicates the atomicity of any memory allocations.
+* Prepare a new set of credentials by copying the data from the old set.
+*/
+static int provenance_cred_prepare(struct cred *new, const struct cred *old, gfp_t gfp)
+{
+  prov_msg_t* old_prov = old->provenance;
+  prov_msg_t* prov = alloc_provenance(MSG_TASK, gfp);
+#ifdef CONFIG_SECURITY_IFC
+	struct ifc_struct *new_ifc;
+#endif
+
+  if(!prov){
+    return -ENOMEM;
+  }
+  set_node_id(prov, ASSIGN_NODE_ID);
+	task_config_from_file(current);
+  prov->task_info.uid=__kuid_val(new->euid);
+  prov->task_info.gid=__kgid_val(new->egid);
+
+#ifdef CONFIG_SECURITY_IFC
+	new_ifc = new->ifc;
+	if(ifc_is_labelled(&new_ifc->context)){
+		set_tracked(prov);
+		prov_record_ifc(prov, &new_ifc->context);
+	}
+#endif
+
+	record_relation(RL_CLONE, old_prov, prov, FLOW_ALLOWED, NULL);
+  new->provenance = prov;
+  return 0;
+}
+
+/*
+* @new points to the new credentials.
+* @old points to the original credentials.
+* Transfer data from original creds to new creds
+*/
+static void provenance_cred_transfer(struct cred *new, const struct cred *old)
+{
+  const prov_msg_t *old_prov = old->provenance;
+	prov_msg_t *prov = new->provenance;
+
+  *prov=*old_prov;
+}
+
+/*
+* Update the module's state after setting one or more of the user
+* identity attributes of the current process.  The @flags parameter
+* indicates which of the set*uid system calls invoked this hook.  If
+* @new is the set of credentials that will be installed.  Modifications
+* should be made to this rather than to @current->cred.
+* @old is the set of credentials that are being replaces
+* @flags contains one of the LSM_SETID_* values.
+* Return 0 on success.
+*/
+static int provenance_task_fix_setuid(struct cred *new, const struct cred *old, int flags)
+{
+  prov_msg_t *old_prov = old->provenance;
+	prov_msg_t *prov = new->provenance;
+
+  record_relation(RL_CHANGE, old_prov, prov, FLOW_ALLOWED, NULL);
+  return 0;
+}
+
+/*
+* Allocate and attach a security structure to @inode->i_security.  The
+* i_security field is initialized to NULL when the inode structure is
+* allocated.
+* @inode contains the inode structure.
+* Return 0 if operation was successful.
+*/
+static int provenance_inode_alloc_security(struct inode *inode)
+{
+  prov_msg_t* iprov = alloc_provenance(MSG_INODE_UNKNOWN, GFP_KERNEL);
+  prov_msg_t* sprov;
+#ifdef CONFIG_SECURITY_IFC
+	struct ifc_struct *ifc=NULL;
+#endif
+
+  if(unlikely(!iprov))
+    return -ENOMEM;
+  set_node_id(iprov, inode->i_ino);
+
+  iprov->inode_info.uid=__kuid_val(inode->i_uid);
+  iprov->inode_info.gid=__kgid_val(inode->i_gid);
+  prov_copy_inode_mode(iprov, inode);
+  sprov = inode->i_sb->s_provenance;
+  memcpy(iprov->inode_info.sb_uuid, sprov->sb_info.uuid, 16*sizeof(uint8_t));
+
+	alloc_camflow(inode, GFP_KERNEL);
+  inode_set_provenance(inode, iprov);
+
+#ifdef CONFIG_SECURITY_IFC
+	ifc = inode_get_ifc(inode);
+	if(ifc_is_labelled(&ifc->context)){
+		set_tracked(iprov);
+		prov_record_ifc(iprov, &ifc->context);
+	}
+#endif
+  return 0;
+}
+
+/*
+* @inode contains the inode structure.
+* Deallocate the inode security structure and set @inode->i_security to
+* NULL.
+*/
+static void provenance_inode_free_security(struct inode *inode)
+{
+  prov_msg_t* prov = __raw_inode_provenance(inode);
+  if(!prov){
+    free_provenance(prov);
+	}
+	inode_set_provenance(inode, NULL);
+	free_camflow(inode);
+}
+
+/*
+* Check permission to create a regular file.
+* @dir contains inode structure of the parent of the new file.
+* @dentry contains the dentry structure for the file to be created.
+* @mode contains the file mode of the file to be created.
+* Return 0 if permission is granted.
+*/
+static int provenance_inode_create(struct inode *dir, struct dentry *dentry, umode_t mode)
+{
+	prov_msg_t* cprov = task_provenance();
+	prov_msg_t* iprov = inode_provenance(dir);
+	int rtn=0;
+
+	if(!iprov){ // alloc provenance if none there
+    rtn = -ENOMEM;
+		goto out;
+  }
+
+	record_relation(RL_CREATE, cprov, iprov, FLOW_ALLOWED, NULL);
+out:
+	put_prov(iprov);
+	put_prov(cprov);
+	return rtn;
+}
+
+/*
+* Check permission before accessing an inode.  This hook is called by the
+* existing Linux permission function, so a security module can use it to
+* provide additional checking for existing Linux permission checks.
+* Notice that this hook is called when a file is opened (as well as many
+* other operations), whereas the file_security_ops permission hook is
+* called when the actual read/write operations are performed.
+* @inode contains the inode structure to check.
+* @mask contains the permission mask.
+* Return 0 if permission is granted.
+*/
+static int provenance_inode_permission(struct inode *inode, int mask)
+{
+  prov_msg_t* cprov = task_provenance();
+  prov_msg_t* iprov;
+	uint32_t perms;
+	int rtn=0;
+
+	if(!mask){
+		goto out;
+	}
+
+	if(unlikely(IS_PRIVATE(inode))){
+		goto out;
+	}
+
+	iprov = inode_provenance(inode);
+  if(iprov==NULL){ // alloc provenance if none there
+    rtn = -ENOMEM;
+		goto out;
+  }
+
+	perms = file_mask_to_perms(inode->i_mode, mask);
+	if(is_inode_dir(inode)){
+		if((perms & (DIR__WRITE)) != 0){
+	    record_relation(RL_PERM_WRITE, cprov, iprov, FLOW_ALLOWED, NULL);
+	  }
+	  if((perms & (DIR__READ)) != 0){
+	    record_relation(RL_PERM_READ, iprov, cprov, FLOW_ALLOWED, NULL);
+	  }
+		if((perms & (DIR__SEARCH)) != 0){
+	    record_relation(RL_PERM_EXEC, iprov, cprov, FLOW_ALLOWED, NULL);
+	  }
+	}else if(is_inode_socket(inode)){
+		if((perms & (FILE__WRITE|FILE__APPEND)) != 0){
+	    record_relation(RL_PERM_WRITE, cprov, iprov, FLOW_ALLOWED, NULL);
+	  }
+	  if((perms & (FILE__READ)) != 0){
+	    record_relation(RL_PERM_READ, iprov, cprov, FLOW_ALLOWED, NULL);
+	  }
+	}else{
+		if((perms & (FILE__WRITE|FILE__APPEND)) != 0){
+	    record_relation(RL_PERM_WRITE, cprov, iprov, FLOW_ALLOWED, NULL);
+	  }
+	  if((perms & (FILE__READ)) != 0){
+	    record_relation(RL_PERM_READ, iprov, cprov, FLOW_ALLOWED, NULL);
+	  }
+		if((perms & (FILE__EXECUTE)) != 0){
+	    record_relation(RL_PERM_EXEC, iprov, cprov, FLOW_ALLOWED, NULL);
+	  }
+	}
+
+out:
+	put_prov(iprov);
+	put_prov(cprov);
+  return 0;
+}
+
+/*
+* Check permission before creating a new hard link to a file.
+* @old_dentry contains the dentry structure for an existing
+* link to the file.
+* @dir contains the inode structure of the parent directory
+* of the new link.
+* @new_dentry contains the dentry structure for the new link.
+* Return 0 if permission is granted.
+*/
+
+static int provenance_inode_link(struct dentry *old_dentry, struct inode *dir, struct dentry *new_dentry)
+{
+	prov_msg_t* cprov = task_provenance();
+  prov_msg_t* dprov;
+  prov_msg_t* iprov;
+	int rtn=0;
+
+	iprov = inode_provenance(old_dentry->d_inode); // inode pointed by dentry
+  if(!iprov){ // alloc provenance if none there
+    rtn = -ENOMEM;
+		goto out;
+  }
+
+	dprov = inode_provenance(dir);
+  if(!dprov){ // alloc provenance if none there
+    rtn = -ENOMEM;
+		goto out;
+  }
+	// record edges
+  record_relation(RL_LINK, cprov, dprov, FLOW_ALLOWED, NULL);
+  record_relation(RL_LINK, cprov, iprov, FLOW_ALLOWED, NULL);
+  record_relation(RL_LINK, dprov, iprov, FLOW_ALLOWED, NULL);
+	record_inode_name_from_dentry(new_dentry, iprov);
+out:
+	put_prov(dprov);
+	put_prov(iprov);
+	put_prov(cprov);
+  return rtn;
+}
+
+/*
+* Check file permissions before accessing an open file.  This hook is
+* called by various operations that read or write files.  A security
+* module can use this hook to perform additional checking on these
+* operations, e.g.  to revalidate permissions on use to support privilege
+* bracketing or policy changes.  Notice that this hook is used when the
+* actual read/write operations are performed, whereas the
+* inode_security_ops hook is called when a file is opened (as well as
+* many other operations).
+* Caveat:  Although this hook can be used to revalidate permissions for
+* various system call operations that read or write files, it does not
+* address the revalidation of permissions for memory-mapped files.
+* Security modules must handle this separately if they need such
+* revalidation.
+* @file contains the file structure being accessed.
+* @mask contains the requested permissions.
+* Return 0 if permission is granted.
+*/
+static int provenance_file_permission(struct file *file, int mask)
+{
+	prov_msg_t* cprov = task_provenance();
+  prov_msg_t* iprov;
+  struct inode *inode = file_inode(file);
+	uint32_t perms;
+	int rtn=0;
+
+	iprov = inode_provenance(inode);
+	if(iprov==NULL){ // alloc provenance if none there
+		rtn = -ENOMEM;
+		goto out;
+	}
+
+	perms = file_mask_to_perms(inode->i_mode, mask);
+	if(is_inode_dir(inode)){
+		if((perms & (DIR__WRITE)) != 0){
+			record_relation(RL_WRITE, cprov, iprov, FLOW_ALLOWED, file);
+		}
+		if((perms & (DIR__READ)) != 0){
+			record_relation(RL_READ, iprov, cprov, FLOW_ALLOWED, file);
+		}
+		if((perms & (DIR__SEARCH)) != 0){
+			record_relation(RL_SEARCH, iprov, cprov, FLOW_ALLOWED, file);
+		}
+	}else if(is_inode_socket(inode)){
+		if((perms & (FILE__WRITE|FILE__APPEND)) != 0){
+			record_relation(RL_SND, cprov, iprov, FLOW_ALLOWED, file);
+		}
+		if((perms & (FILE__READ)) != 0){
+			record_relation(RL_RCV, iprov, cprov, FLOW_ALLOWED, file);
+		}
+	}else{
+		if((perms & (FILE__WRITE|FILE__APPEND)) != 0){
+			record_relation(RL_WRITE, cprov, iprov, FLOW_ALLOWED, file);
+		}
+		if((perms & (FILE__READ)) != 0){
+			record_relation(RL_READ, iprov, cprov, FLOW_ALLOWED, file);
+		}
+		if((perms & (FILE__EXECUTE)) != 0){
+	    record_relation(RL_EXEC, iprov, cprov, FLOW_ALLOWED, file);
+	  }
+	}
+
+out:
+	put_prov(iprov);
+	put_prov(cprov);
+  return rtn;
+}
+
+/*
+* Save open-time permission checking state for later use upon
+* file_permission, and recheck access if anything has changed
+* since inode_permission.
+*/
+static int provenance_file_open(struct file *file, const struct cred *cred)
+{
+	prov_msg_t* cprov = task_provenance();
+	struct inode *inode = file_inode(file);
+	prov_msg_t* iprov = inode_provenance(inode);
+	int rtn=0;
+
+	if(!iprov){ // alloc provenance if none there
+    rtn = -ENOMEM;
+		goto out;
+  }
+	record_relation(RL_OPEN, iprov, cprov, FLOW_ALLOWED, file);
+
+out:
+	put_prov(iprov);
+	put_prov(cprov);
+	return rtn;
+}
+
+/*
+* Check permissions for a mmap operation.  The @file may be NULL, e.g.
+* if mapping anonymous memory.
+* @file contains the file structure for file to map (may be NULL).
+* @reqprot contains the protection requested by the application.
+* @prot contains the protection that will be applied by the kernel.
+* @flags contains the operational flags.
+* Return 0 if permission is granted.
+*/
+static int provenance_mmap_file(struct file *file, unsigned long reqprot, unsigned long prot, unsigned long flags)
+{
+  prov_msg_t* cprov = task_provenance();
+  prov_msg_t* iprov = NULL;
+	prov_msg_t* bprov = NULL;
+  struct inode *inode;
+	int rtn=0;
+
+  if(unlikely(file==NULL)){
+    goto out;
+  }
+	//provenance_record_file_name(file);
+
+  inode = file_inode(file);
+  iprov = inode_provenance(inode);
+	if( (flags & (MAP_SHARED) ) !=  0){
+	  if((prot & (PROT_WRITE)) != 0){
+	    record_relation(RL_MMAP_WRITE, cprov, iprov, FLOW_ALLOWED, file);
+	  }
+	  if((prot & (PROT_READ)) != 0){
+	    record_relation(RL_MMAP_READ, iprov, cprov, FLOW_ALLOWED, file);
+	  }
+
+		if((prot & (PROT_EXEC)) != 0){
+	    record_relation(RL_MMAP_EXEC, iprov, cprov, FLOW_ALLOWED, file);
+	  }
+	}else{
+		bprov = branch_mmap(iprov, cprov);
+		if(bprov==NULL){
+			goto out;
+		}
+		if((prot & (PROT_WRITE)) != 0){
+	    record_relation(RL_MMAP_WRITE, cprov, bprov, FLOW_ALLOWED, file);
+	  }
+	  if((prot & (PROT_READ)) != 0){
+	    record_relation(RL_MMAP_READ, bprov, cprov, FLOW_ALLOWED, file);
+	  }
+
+		if((prot & (PROT_EXEC)) != 0){
+	    record_relation(RL_MMAP_EXEC, bprov, cprov, FLOW_ALLOWED, file);
+	  }
+		free_provenance(bprov);
+	}
+
+out:
+	put_prov(iprov);
+	put_prov(cprov);
+  return rtn;
+}
+
+/*
+* @file contains the file structure.
+* @cmd contains the operation to perform.
+* @arg contains the operational arguments.
+* Check permission for an ioctl operation on @file.  Note that @arg
+* sometimes represents a user space pointer; in other cases, it may be a
+* simple integer value.  When @arg represents a user space pointer, it
+* should never be used by the security module.
+* Return 0 if permission is granted.
+*/
+static int provenance_file_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
+{
+  prov_msg_t* cprov = task_provenance();
+  prov_msg_t* iprov;
+  struct inode *inode = file_inode(file);
+	int rtn=0;
+
+	iprov = inode_provenance(inode);
+  if(!iprov){
+    rtn = -ENOMEM;
+		goto out;
+  }
+
+	// both way exchange
+  record_relation(RL_WRITE, cprov, iprov, FLOW_ALLOWED, NULL);
+  record_relation(RL_READ, iprov, cprov, FLOW_ALLOWED, NULL);
+
+out:
+	put_prov(iprov);
+	put_prov(cprov);
+  return rtn;
+}
+
+/* msg */
+
+/*
+* Allocate and attach a security structure to the msg->security field.
+* The security field is initialized to NULL when the structure is first
+* created.
+* @msg contains the message structure to be modified.
+* Return 0 if operation was successful and permission is granted.
+*/
+static int provenance_msg_msg_alloc_security(struct msg_msg *msg)
+{
+  prov_msg_t* cprov = task_provenance();
+  prov_msg_t* mprov;
+	int rtn=0;
+#ifdef CONFIG_SECURITY_IFC
+	struct ifc_struct* ifc= msg->ifc;
+#endif
+  /* alloc new prov struct with generated id */
+  mprov = alloc_provenance(MSG_MSG, GFP_KERNEL);
+
+  if(!mprov){
+    rtn = -ENOMEM;
+		goto out;
+	}
+
+  set_node_id(mprov, ASSIGN_NODE_ID);
+  mprov->msg_msg_info.type=msg->m_type;
+#ifdef CONFIG_SECURITY_IFC
+	if(!ifc){
+		if(ifc_is_labelled(&ifc->context)){
+			set_tracked(mprov);
+			prov_record_ifc(mprov, &ifc->context);
+		}
+	}
+#endif
+  msg->provenance = mprov;
+  record_relation(RL_CREATE, cprov, mprov, FLOW_ALLOWED, NULL);
+out:
+	put_prov(cprov);
+  return rtn;
+}
+
+/*
+* Deallocate the security structure for this message.
+* @msg contains the message structure to be modified.
+*/
+static void provenance_msg_msg_free_security(struct msg_msg *msg)
+{
+	prov_msg_t *prov = msg->provenance;
+  msg->provenance=NULL;
+  free_provenance(prov);
+}
+
+/*
+* Check permission before a message, @msg, is enqueued on the message
+* queue, @msq.
+* @msq contains the message queue to send message to.
+* @msg contains the message to be enqueued.
+* @msqflg contains operational flags.
+* Return 0 if permission is granted.
+*/
+static int provenance_msg_queue_msgsnd(struct msg_queue *msq, struct msg_msg *msg, int msqflg)
+{
+  prov_msg_t* cprov = task_provenance();
+  prov_msg_t* mprov = msg->provenance;
+
+  record_relation(RL_CREATE, cprov, mprov, FLOW_ALLOWED, NULL);
+	put_prov(cprov);
+  return 0;
+}
+
+/*
+* Check permission before a message, @msg, is removed from the message
+* queue, @msq.  The @target task structure contains a pointer to the
+* process that will be receiving the message (not equal to the current
+* process when inline receives are being performed).
+* @msq contains the message queue to retrieve message from.
+* @msg contains the message destination.
+* @target contains the task structure for recipient process.
+* @type contains the type of message requested.
+* @mode contains the operational flags.
+* Return 0 if permission is granted.
+*/
+static int provenance_msg_queue_msgrcv(struct msg_queue *msq, struct msg_msg *msg,
+				    struct task_struct *target,
+				    long type, int mode)
+{
+  prov_msg_t* cprov = target->cred->provenance;
+  prov_msg_t* mprov = msg->provenance;
+
+  record_relation(RL_READ, mprov, cprov, FLOW_ALLOWED, NULL);
+  return 0;
+}
+
+/*
+* Allocate and attach a security structure to the shp->shm_perm.security
+* field.  The security field is initialized to NULL when the structure is
+* first created.
+* @shp contains the shared memory structure to be modified.
+* Return 0 if operation was successful and permission is granted.
+*/
+static int provenance_shm_alloc_security(struct shmid_kernel *shp)
+{
+	prov_msg_t* cprov = task_provenance();
+  prov_msg_t* sprov = alloc_provenance(MSG_SHM, GFP_KERNEL);
+	int rtn=0;
+#ifdef CONFIG_SECURITY_IFC
+	struct ifc_struct* ifc= shp->shm_perm.ifc;
+#endif
+
+  if(!sprov){
+    rtn = -ENOMEM;
+		goto out;
+	}
+
+  set_node_id(sprov, ASSIGN_NODE_ID);
+  sprov->shm_info.mode=shp->shm_perm.mode;
+
+#ifdef CONFIG_SECURITY_IFC
+	if(!ifc){
+		if(ifc_is_labelled(&ifc->context)){
+			set_tracked(sprov);
+			prov_record_ifc(sprov, &ifc->context);
+		}
+	}
+#endif
+
+  shp->shm_perm.provenance=sprov;
+  record_relation(RL_ATTACH, sprov, cprov, FLOW_ALLOWED, NULL);
+  record_relation(RL_ATTACH, cprov, sprov, FLOW_ALLOWED, NULL);
+out:
+	put_prov(cprov);
+	return rtn;
+}
+
+/*
+* Deallocate the security struct for this memory segment.
+* @shp contains the shared memory structure to be modified.
+*/
+static void provenance_shm_free_security(struct shmid_kernel *shp)
+{
+  free_provenance(shp->shm_perm.provenance);
+  shp->shm_perm.provenance=NULL;
+}
+
+/*
+* Check permissions prior to allowing the shmat system call to attach the
+* shared memory segment @shp to the data segment of the calling process.
+* The attaching address is specified by @shmaddr.
+* @shp contains the shared memory structure to be modified.
+* @shmaddr contains the address to attach memory region to.
+* @shmflg contains the operational flags.
+* Return 0 if permission is granted.
+*/
+static int provenance_shm_shmat(struct shmid_kernel *shp,
+			     char __user *shmaddr, int shmflg)
+{
+  prov_msg_t* cprov = task_provenance();
+	prov_msg_t* sprov = shp->shm_perm.provenance;
+	int rtn=0;
+
+  if(!sprov){
+    rtn = -ENOMEM;
+		goto out;
+	}
+
+  if(shmflg & SHM_RDONLY){
+    record_relation(RL_ATTACH, sprov, cprov, FLOW_ALLOWED, NULL);
+  }else{
+    record_relation(RL_ATTACH, sprov, cprov, FLOW_ALLOWED, NULL);
+    record_relation(RL_ATTACH, cprov, sprov, FLOW_ALLOWED, NULL);
+  }
+
+out:
+	put_prov(cprov);
+	return rtn;
+}
+
+/*
+* Allocate and attach a security structure to the sk->sk_security field,
+* which is used to copy security attributes between local stream sockets.
+*/
+static int provenance_sk_alloc_security(struct sock *sk, int family, gfp_t priority)
+{
+  prov_msg_t* skprov = task_provenance();
+	int rtn=0;
+
+  if(!skprov){
+    rtn = -ENOMEM;
+		goto out;
+	}
+
+  sk->sk_provenance=skprov;
+
+out:
+	put_prov(skprov);
+  return 0;
+}
+
+/*
+* This hook allows a module to update or allocate a per-socket security
+* structure. Note that the security field was not added directly to the
+* socket structure, but rather, the socket security information is stored
+* in the associated inode.  Typically, the inode alloc_security hook will
+* allocate and and attach security information to
+* sock->inode->i_security.  This hook may be used to update the
+* sock->inode->i_security field with additional information that wasn't
+* available when the inode was allocated.
+* @sock contains the newly created socket structure.
+* @family contains the requested protocol family.
+* @type contains the requested communications type.
+* @protocol contains the requested protocol.
+* @kern set to 1 if a kernel socket.
+*/
+static int provenance_socket_post_create(struct socket *sock, int family,
+				      int type, int protocol, int kern)
+{
+  prov_msg_t* cprov  = task_provenance();
+  prov_msg_t* iprov = socket_inode_provenance(sock);
+
+  if(kern){
+    goto out;
+  }
+  record_relation(RL_CREATE, cprov, iprov, FLOW_ALLOWED, NULL);
+
+out:
+	put_prov(cprov);
+  return 0;
+}
+
+/*
+* Check permission before socket protocol layer bind operation is
+* performed and the socket @sock is bound to the address specified in the
+* @address parameter.
+* @sock contains the socket structure.
+* @address contains the address to bind to.
+* @addrlen contains the length of address.
+* Return 0 if permission is granted.
+*/
+static int provenance_socket_bind(struct socket *sock, struct sockaddr *address, int addrlen)
+{
+  prov_msg_t* cprov  = task_provenance();
+  prov_msg_t* iprov = socket_inode_provenance(sock);
+	int rtn = 0;
+
+  if(!iprov){
+    rtn = -ENOMEM;
+		goto out;
+	}
+
+  if(provenance_is_opaque(cprov)){
+    goto out;
+	}
+
+	provenance_record_address(iprov, address, addrlen);
+	record_relation(RL_BIND, cprov, iprov, FLOW_ALLOWED, NULL);
+
+out:
+	put_prov(cprov);
+  return rtn;
+}
+
+/*
+* Check permission before socket protocol layer connect operation
+* attempts to connect socket @sock to a remote address, @address.
+* @sock contains the socket structure.
+* @address contains the address of remote endpoint.
+* @addrlen contains the length of address.
+* Return 0 if permission is granted.
+*/
+static int provenance_socket_connect(struct socket *sock, struct sockaddr *address, int addrlen)
+{
+  prov_msg_t* cprov  = task_provenance();
+  prov_msg_t* iprov = socket_inode_provenance(sock);
+	int rtn=0;
+
+	if(!iprov){
+    rtn = -ENOMEM;
+		goto out;
+	}
+
+  if(provenance_is_opaque(cprov)){
+    goto out;
+	}
+
+	provenance_record_address(iprov, address, addrlen);
+	record_relation(RL_CONNECT, cprov, iprov, FLOW_ALLOWED, NULL);
+
+out:
+	put_prov(cprov);
+  return 0;
+}
+
+/*
+* Check permission before socket protocol layer listen operation.
+* @sock contains the socket structure.
+* @backlog contains the maximum length for the pending connection queue.
+* Return 0 if permission is granted.
+*/
+static int provenance_socket_listen(struct socket *sock, int backlog)
+{
+  prov_msg_t* cprov  = task_provenance();
+  prov_msg_t* iprov = socket_inode_provenance(sock);
+	int rtn=0;
+
+	if(!iprov){
+    rtn = -ENOMEM;
+		goto out;
+	}
+  record_relation(RL_LISTEN, cprov, iprov, FLOW_ALLOWED, NULL);
+
+out:
+	put_prov(cprov);
+  return 0;
+}
+
+/*
+* Check permission before accepting a new connection.  Note that the new
+* socket, @newsock, has been created and some information copied to it,
+* but the accept operation has not actually been performed.
+* @sock contains the listening socket structure.
+* @newsock contains the newly created server socket for connection.
+* Return 0 if permission is granted.
+*/
+static int provenance_socket_accept(struct socket *sock, struct socket *newsock)
+{
+  prov_msg_t* cprov  = task_provenance();
+  prov_msg_t* iprov = socket_inode_provenance(sock);
+  prov_msg_t* niprov = socket_inode_provenance(newsock);
+
+  record_relation(RL_CREATE, iprov, niprov, FLOW_ALLOWED, NULL);
+  record_relation(RL_ACCEPT, niprov, cprov, FLOW_ALLOWED, NULL);
+
+	put_prov(cprov);
+  return 0;
+}
+
+/*
+* Check permission before transmitting a message to another socket.
+* @sock contains the socket structure.
+* @msg contains the message to be transmitted.
+* @size contains the size of message.
+* Return 0 if permission is granted.
+*/
+static int provenance_socket_sendmsg(struct socket *sock, struct msghdr *msg,
+				  int size)
+{
+	prov_msg_t* cprov = task_provenance();
+	prov_msg_t* iprov = socket_inode_provenance(sock);
+	int rtn=0;
+
+	if(iprov==NULL){
+		rtn = -ENOMEM;
+		goto out;
+	}
+
+	record_relation(RL_SND, cprov, iprov, FLOW_ALLOWED, NULL);
+
+out:
+	put_prov(cprov);
+	return rtn;
+}
+
+/*
+* Check permission before receiving a message from a socket.
+* @sock contains the socket structure.
+* @msg contains the message structure.
+* @size contains the size of message structure.
+* @flags contains the operational flags.
+* Return 0 if permission is granted.
+*/
+static int provenance_socket_recvmsg(struct socket *sock, struct msghdr *msg,
+				  int size, int flags)
+{
+	prov_msg_t* cprov = task_provenance();
+	prov_msg_t* iprov = socket_inode_provenance(sock);
+	int rtn=0;
+
+	if(iprov==NULL){
+		rtn = -ENOMEM;
+		goto out;
+	}
+
+	record_relation(RL_RCV, iprov, cprov, FLOW_ALLOWED, NULL);
+
+out:
+	put_prov(cprov);
+	return rtn;
+}
+
+/*
+* Check permissions on incoming network packets.  This hook is distinct
+* from Netfilter's IP input hooks since it is the first time that the
+* incoming sk_buff @skb has been associated with a particular socket, @sk.
+* Must not sleep inside this hook because some callers hold spinlocks.
+* @sk contains the sock (not socket) associated with the incoming sk_buff.
+* @skb contains the incoming network data.
+*/
+static int provenance_socket_sock_rcv_skb(struct sock *sk, struct sk_buff *skb)
+{
+	prov_msg_t* cprov = sk_provenance(sk);
+	prov_msg_t* iprov;
+  prov_msg_t pckprov;
+	uint16_t family = sk->sk_family;
+	int rtn=0;
+
+	if(cprov==NULL){
+		goto out;
+	}
+
+	if(family!=PF_INET){ // we only handle IPv4 for now
+		goto out;
+	}
+
+	iprov = sk_inode_provenance(sk);
+	if(iprov==NULL){ // we could not get the provenance, we give up
+		goto out;
+	}
+	if(provenance_is_tracked(iprov)){
+    provenance_parse_skb_ipv4(skb, &pckprov);
+    record_pck_to_inode(&pckprov, iprov);
+		if(provenance_is_tracked(cprov)){
+			record_relation(RL_RCV, iprov, cprov, FLOW_ALLOWED, NULL);
+		}
+  }
+out:
+	return rtn;
+}
+
+/*
+* Check permissions before establishing a Unix domain stream connection
+* between @sock and @other.
+* @sock contains the sock structure.
+* @other contains the peer sock structure.
+* @newsk contains the new sock structure.
+* Return 0 if permission is granted.
+*/
+static int provenance_unix_stream_connect(struct sock *sock,
+					      struct sock *other,
+					      struct sock *newsk)
+{
+  /*prov_msg_t* cprov  = task_provenance();
+  prov_msg_t* skprov = sk_provenance(sock);
+  prov_msg_t* nskprov = sk_provenance(newsk);
+  prov_msg_t* okprov = sk_provenance(other);
+
+  record_relation(RL_CONNECT, cprov, skprov, FLOW_ALLOWED);
+  record_relation(RL_ASSOCIATE, skprov, nskprov, FLOW_ALLOWED);
+  record_relation(RL_ASSOCIATE, skprov, okprov, FLOW_ALLOWED);*/
+  return 0;
+}
+
+/*
+* Check permissions before connecting or sending datagrams from @sock to
+* @other.
+* @sock contains the socket structure.
+* @other contains the peer socket structure.
+* Return 0 if permission is granted.
+*/
+static int provenance_unix_may_send(struct socket *sock,
+					struct socket *other)
+{
+  /*prov_msg_t* skprov = socket_inode_provenance(sock);
+  prov_msg_t* okprov = socket_inode_provenance(other);
+
+  record_relation(RL_UNKNOWN, skprov, okprov, FLOW_ALLOWED);*/
+  return 0;
+}
+
+/* outdated description */
+/*
+* Save security information in the bprm->security field, typically based
+* on information about the bprm->file, for later use by the apply_creds
+* hook.  This hook may also optionally check permissions (e.g. for
+* transitions between security domains).
+* This hook may be called multiple times during a single execve, e.g. for
+* interpreters.  The hook can tell whether it has already been called by
+* checking to see if @bprm->security is non-NULL.  If so, then the hook
+* may decide either to retain the security information saved earlier or
+* to replace it.
+* @bprm contains the linux_binprm structure.
+* Return 0 if the hook is successful and permission is granted.
+*/
+static int provenance_bprm_set_creds(struct linux_binprm *bprm){
+	prov_msg_t* nprov = bprm_provenance(bprm);
+	struct inode *inode = file_inode(bprm->file);
+	prov_msg_t* iprov = inode_provenance(inode);
+	int rtn=0;
+
+  if(!nprov){
+		rtn = -ENOMEM;
+		goto out;
+  }
+
+	record_relation(RL_EXEC, iprov, nprov, FLOW_ALLOWED, NULL);
+
+out:
+	put_prov(iprov);
+	put_prov(nprov);
+  return rtn;
+}
+
+/*
+* Tidy up after the installation of the new security attributes of a
+* process being transformed by an execve operation.  The new credentials
+* have, by this point, been set to @current->cred.  @bprm points to the
+* linux_binprm structure.  This hook is a good place to perform state
+* changes on the process such as clearing out non-inheritable signal
+* state.  This is called immediately after commit_creds().
+*/
+ static void provenance_bprm_committing_creds(struct linux_binprm *bprm){
+	prov_msg_t* cprov  = task_provenance();
+	prov_msg_t* nprov = bprm_provenance(bprm);
+	struct inode *inode = file_inode(bprm->file);
+	prov_msg_t* iprov = inode_provenance(inode);
+
+	record_relation(RL_EXEC, cprov, nprov, FLOW_ALLOWED, NULL);
+	record_relation(RL_EXEC, iprov, nprov, FLOW_ALLOWED, NULL);
+	put_prov(iprov);
+	put_prov(nprov);
+	put_prov(cprov);
+ }
+
+/*
+* Allocate and attach a security structure to the sb->s_security field.
+* The s_security field is initialized to NULL when the structure is
+* allocated.
+* @sb contains the super_block structure to be modified.
+* Return 0 if operation was successful.
+*/
+static int provenance_sb_alloc_security(struct super_block *sb)
+{
+  prov_msg_t* sbprov  = alloc_provenance(MSG_SB, GFP_KERNEL);
+  if(!sbprov)
+    return -ENOMEM;
+  sb->s_provenance = sbprov;
+  return 0;
+}
+
+/*
+* Deallocate and clear the sb->s_security field.
+* @sb contains the super_block structure to be modified.
+*/
+static void provenance_sb_free_security(struct super_block *sb)
+{
+  free_provenance(sb->s_provenance);
+  sb->s_provenance=NULL;
+}
+
+static int provenance_sb_kern_mount(struct super_block *sb, int flags, void *data)
+{
+  int i;
+  uint8_t c=0;
+  prov_msg_t* sbprov = sb->s_provenance;
+  for(i=0; i<16; i++){
+    sbprov->sb_info.uuid[i]=sb->s_uuid[i];
+    c|=sb->s_uuid[i];
+  }
+  if(c==0){ // no uuid defined, generate random one
+    get_random_bytes(sbprov->sb_info.uuid, 16*sizeof(uint8_t));
+  }
+  return 0;
+}
+
+static struct security_hook_list provenance_hooks[] = {
+	/* task related hooks */
+  LSM_HOOK_INIT(cred_alloc_blank, provenance_cred_alloc_blank),
+  LSM_HOOK_INIT(cred_free, provenance_cred_free),
+  LSM_HOOK_INIT(cred_prepare, provenance_cred_prepare),
+  LSM_HOOK_INIT(cred_transfer, provenance_cred_transfer),
+  LSM_HOOK_INIT(task_fix_setuid, provenance_task_fix_setuid),
+
+	/* inode related hooks */
+  LSM_HOOK_INIT(inode_alloc_security, provenance_inode_alloc_security),
+  LSM_HOOK_INIT(inode_create, provenance_inode_create),
+  LSM_HOOK_INIT(inode_free_security, provenance_inode_free_security),
+  LSM_HOOK_INIT(inode_permission, provenance_inode_permission),
+  LSM_HOOK_INIT(inode_link, provenance_inode_link),
+
+	/* file related hooks */
+  LSM_HOOK_INIT(file_permission, provenance_file_permission),
+  LSM_HOOK_INIT(mmap_file, provenance_mmap_file),
+  LSM_HOOK_INIT(file_ioctl, provenance_file_ioctl),
+	LSM_HOOK_INIT(file_open, provenance_file_open),
+
+	/* msg related hooks */
+	LSM_HOOK_INIT(msg_msg_alloc_security, provenance_msg_msg_alloc_security),
+	LSM_HOOK_INIT(msg_msg_free_security, provenance_msg_msg_free_security),
+  LSM_HOOK_INIT(msg_queue_msgsnd, provenance_msg_queue_msgsnd),
+  LSM_HOOK_INIT(msg_queue_msgrcv, provenance_msg_queue_msgrcv),
+
+	/* shared memory related hooks */
+  LSM_HOOK_INIT(shm_alloc_security, provenance_shm_alloc_security),
+  LSM_HOOK_INIT(shm_free_security, provenance_shm_free_security),
+  LSM_HOOK_INIT(shm_shmat, provenance_shm_shmat),
+
+	/* socket related hooks */
+  LSM_HOOK_INIT(sk_alloc_security, provenance_sk_alloc_security),
+  LSM_HOOK_INIT(socket_post_create, provenance_socket_post_create),
+  LSM_HOOK_INIT(socket_bind, provenance_socket_bind),
+  LSM_HOOK_INIT(socket_connect, provenance_socket_connect),
+  LSM_HOOK_INIT(socket_listen, provenance_socket_listen),
+  LSM_HOOK_INIT(socket_accept, provenance_socket_accept),
+  LSM_HOOK_INIT(socket_sendmsg, provenance_socket_sendmsg),
+  LSM_HOOK_INIT(socket_recvmsg, provenance_socket_recvmsg),
+  LSM_HOOK_INIT(socket_sock_rcv_skb, provenance_socket_sock_rcv_skb),
+  LSM_HOOK_INIT(unix_stream_connect, provenance_unix_stream_connect),
+  LSM_HOOK_INIT(unix_may_send, provenance_unix_may_send),
+
+	/* exec related hooks */
+  LSM_HOOK_INIT(bprm_set_creds, provenance_bprm_set_creds),
+  LSM_HOOK_INIT(bprm_committing_creds, provenance_bprm_committing_creds),
+
+	/* file system related hooks */
+  LSM_HOOK_INIT(sb_alloc_security, provenance_sb_alloc_security),
+  LSM_HOOK_INIT(sb_free_security, provenance_sb_free_security),
+  LSM_HOOK_INIT(sb_kern_mount, provenance_sb_kern_mount)
+};
+
+#ifndef CONFIG_SECURITY_IFC
+struct kmem_cache *camflow_cache=NULL;
+#endif
+
+struct kmem_cache *provenance_cache=NULL;
+
+uint32_t prov_machine_id=1; /* TODO get a proper id somehow, for now set from userspace */
+uint32_t prov_boot_id=0;
+void __init provenance_add_hooks(void){
+	get_random_bytes(&prov_boot_id, sizeof(uint32_t)); // proper counter instead of random id?
+  provenance_cache = kmem_cache_create("provenance_struct",
+					    sizeof(prov_msg_t),
+					    0, SLAB_PANIC, NULL);
+
+#ifndef CONFIG_SECURITY_IFC
+	camflow_cache = kmem_cache_create("camflow_i_ptr",
+							sizeof(struct camflow_i_ptr),
+							0, SLAB_PANIC, NULL);
+#endif
+  cred_init_provenance();
+  /* register the provenance security hooks */
+  security_add_hooks(provenance_hooks, ARRAY_SIZE(provenance_hooks));
+
+	printk(KERN_INFO "Provenance Camflow %s\n", CAMFLOW_VERSION_STR);
+	printk(KERN_INFO "Provenance hooks ready.\n");
+}
diff -uprN ./pristine/linux-4.4.25/security/provenance/include/provenance_filter.h ./linux-4.4.25/security/provenance/include/provenance_filter.h
--- ./pristine/linux-4.4.25/security/provenance/include/provenance_filter.h	1969-12-31 16:00:00.000000000 -0800
+++ ./linux-4.4.25/security/provenance/include/provenance_filter.h	2016-10-19 03:14:47.583690435 -0700
@@ -0,0 +1,94 @@
+/*
+*
+* Author: Thomas Pasquier <tfjmp@seas.harvard.edu>
+*
+* Copyright (C) 2016 Harvard University
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License version 2, as
+* published by the Free Software Foundation; either version 2 of the License, or
+*	(at your option) any later version.
+*
+*/
+#ifndef _LINUX_PROVENANCE_FILTER_H
+#define _LINUX_PROVENANCE_FILTER_H
+
+#include <uapi/linux/provenance.h>
+
+extern bool prov_enabled;
+extern bool prov_all;
+
+#define HIT_FILTER(filter, data) ( (filter&data) != 0 )
+
+extern uint32_t prov_node_filter;
+extern uint32_t prov_propagate_node_filter;
+
+#define filter_node(node) __filter_node(prov_node_filter, node)
+#define filter_propagate_node(node) __filter_node(prov_propagate_node_filter, node)
+
+/* return either or not the node should be filtered out */
+static inline bool __filter_node(uint32_t filter, const prov_msg_t* node){
+  if(!prov_enabled){
+    return true;
+  }
+
+  if(provenance_is_opaque(node)){
+    return true;
+  }
+
+  // we hit an element of the black list ignore
+  if( HIT_FILTER(filter, node_identifier(node).type) ){
+    return true;
+  }
+
+  return false;
+}
+
+#define UPDATE_FILTER (RL_VERSION_PROCESS|RL_VERSION|RL_NAMED)
+static inline bool filter_update_node(uint32_t relation_type, prov_msg_t* to){
+  if( HIT_FILTER(relation_type, UPDATE_FILTER) ){ // not update if relation is of above type
+    return true;
+  }
+  return false;
+}
+
+extern uint32_t prov_relation_filter;
+extern uint32_t prov_propagate_relation_filter;
+
+/* return either or not the relation should be filtered out */
+static inline bool filter_relation(uint32_t type, uint8_t allowed){
+  if(allowed==FLOW_DISALLOWED && HIT_FILTER(prov_relation_filter, RL_DISALLOWED)){
+    return true;
+  }
+
+  if(allowed==FLOW_ALLOWED && HIT_FILTER(prov_relation_filter, RL_ALLOWED)){
+    return true;
+  }
+
+  // we hit an element of the black list ignore
+  if( HIT_FILTER(prov_relation_filter, type) ){
+    return true;
+  }
+
+  return false;
+}
+
+/* return either or not tracking should propagate */
+static inline bool filter_propagate_relation(uint32_t type, uint8_t allowed){
+  if(allowed==FLOW_DISALLOWED && HIT_FILTER(prov_propagate_relation_filter, RL_DISALLOWED)){
+    return true;
+  }
+
+  if(allowed==FLOW_ALLOWED && HIT_FILTER(prov_propagate_relation_filter, RL_ALLOWED)){
+    return true;
+  }
+
+  // the relation does not allow tracking propagation
+  if( HIT_FILTER(prov_propagate_relation_filter, type) ){
+    return true;
+  }
+
+  return false;
+}
+
+#endif
diff -uprN ./pristine/linux-4.4.25/security/provenance/include/provenance.h ./linux-4.4.25/security/provenance/include/provenance.h
--- ./pristine/linux-4.4.25/security/provenance/include/provenance.h	1969-12-31 16:00:00.000000000 -0800
+++ ./linux-4.4.25/security/provenance/include/provenance.h	2016-10-19 03:14:47.583690435 -0700
@@ -0,0 +1,262 @@
+/*
+*
+* Author: Thomas Pasquier <thomas.pasquier@cl.cam.ac.uk>
+*
+* Copyright (C) 2015 University of Cambridge
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License version 2, as
+* published by the Free Software Foundation; either version 2 of the License, or
+*	(at your option) any later version.
+*
+*/
+#ifndef _LINUX_PROVENANCE_H
+#define _LINUX_PROVENANCE_H
+
+#ifdef CONFIG_SECURITY_PROVENANCE
+
+#include <linux/slab.h>
+#include <linux/types.h>
+#include <linux/bug.h>
+#include <linux/socket.h>
+#include <linux/camflow.h>
+#include <uapi/linux/ifc.h>
+#include <uapi/linux/mman.h>
+#include <uapi/linux/camflow.h>
+#include <uapi/linux/provenance.h>
+#include <uapi/linux/stat.h>
+#include <linux/fs.h>
+
+#include "camflow_utils.h"
+#include "provenance_filter.h"
+#include "provenance_relay.h"
+
+#define ASSIGN_NODE_ID 0
+
+#define prov_next_relation_id() ((uint64_t)atomic64_inc_return(&prov_relation_id))
+#define prov_next_node_id() ((uint64_t)atomic64_inc_return(&prov_node_id))
+#define free_provenance(prov) kmem_cache_free(provenance_cache, prov)
+
+extern atomic64_t prov_relation_id;
+extern atomic64_t prov_node_id;
+extern struct kmem_cache *provenance_cache;
+
+static inline struct prov_msg_t* prov_from_pid(pid_t pid){
+  struct task_struct *dest = find_task_by_vpid(pid);
+  if(!dest)
+    return NULL;
+  return __task_cred(dest)->provenance;
+}
+
+#define get_mutex(n) &(n->node_info.lprov.l)
+#define lock_node(n) mutex_lock(get_mutex(n))
+#define unlock_node(n) mutex_unlock(get_mutex(n))
+#define init_mutex_node(n) mutex_init(get_mutex(n))
+
+static inline void put_prov(prov_msg_t* n){
+  if(likely(n!=NULL)){
+    unlock_node(n);
+  }
+}
+
+static inline prov_msg_t* alloc_provenance(uint32_t ntype, gfp_t gfp)
+{
+  prov_msg_t* prov =  kmem_cache_zalloc(provenance_cache, gfp);
+  if(!prov){
+    return NULL;
+  }
+  init_mutex_node(prov);
+  prov_type(prov)=ntype;
+  return prov;
+}
+
+extern uint32_t prov_machine_id;
+extern uint32_t prov_boot_id;
+
+static inline void set_node_id(prov_msg_t* node, uint64_t nid){
+  if(nid==ASSIGN_NODE_ID){
+    node_identifier(node).id=prov_next_node_id();
+  }else{
+    node_identifier(node).id=nid;
+  }
+  node_identifier(node).boot_id=prov_boot_id;
+  node_identifier(node).machine_id=prov_machine_id;
+}
+
+static inline void copy_node_info(prov_identifier_t* dest, prov_identifier_t* src){
+  memcpy(dest, src, sizeof(prov_identifier_t));
+}
+
+static inline void __record_node(prov_msg_t* node){
+  if(filter_node(node) || provenance_is_recorded(node)){ // filtered or already recorded
+    return;
+  }
+
+  set_recorded(node);
+  if(unlikely(node_identifier(node).machine_id!=prov_machine_id)){
+    node_identifier(node).machine_id=prov_machine_id;
+  }
+  prov_write(node);
+}
+
+static inline void __record_relation(uint32_t type,
+                                      prov_identifier_t* from,
+                                      prov_identifier_t* to,
+                                      prov_msg_t* relation,
+                                      uint8_t allowed,
+                                      struct file *file){
+  prov_type(relation)=MSG_RELATION;
+  relation_identifier(relation).id = prov_next_relation_id();
+  relation_identifier(relation).boot_id = prov_boot_id;
+  relation_identifier(relation).machine_id = prov_machine_id;
+  relation->relation_info.type=type;
+  relation->relation_info.allowed=allowed;
+  copy_node_info(&relation->relation_info.snd, from);
+  copy_node_info(&relation->relation_info.rcv, to);
+  if(file!=NULL){
+    relation->relation_info.set = FILE_INFO_SET;
+    mutex_lock(&(file->f_pos_lock));
+  	relation->relation_info.offset = file->f_pos;
+  	mutex_unlock(&(file->f_pos_lock));
+  }
+  prov_write(relation);
+}
+
+static inline void __update_version(uint32_t type, prov_msg_t* prov){
+  prov_msg_t old_prov;
+  prov_msg_t relation;
+
+  if(filter_update_node(type, prov)){ // the relation is filtered out
+    goto out;
+  }
+
+  memcpy(&old_prov, prov, sizeof(prov_msg_t));
+  node_identifier(prov).version++;
+  clear_recorded(prov);
+  if(node_identifier(prov).type == MSG_TASK){
+    __record_relation(RL_VERSION_PROCESS, &(old_prov.msg_info.identifier), &(prov->msg_info.identifier), &relation, FLOW_ALLOWED, NULL);
+  }else{
+    __record_relation(RL_VERSION, &(old_prov.msg_info.identifier), &(prov->msg_info.identifier), &relation, FLOW_ALLOWED, NULL);
+  }
+
+out:
+  return;
+}
+
+static inline void __propagate(uint32_t type,
+                            prov_msg_t* from,
+                            prov_msg_t* to,
+                            prov_msg_t* relation,
+                            uint8_t allowed){
+
+  if(!provenance_propagate(from)){
+    goto out;
+  }
+
+  if( filter_propagate_node(to) ){
+    goto out;
+  }
+
+  if( filter_propagate_relation(type, allowed) ){ // it is filtered
+    goto out;
+  }
+
+  set_tracked(to);// receiving node become tracked
+  set_propagate(to); // continue to propagate
+  prov_bloom_merge(prov_taint(to), prov_taint(from));
+  prov_bloom_merge(prov_taint(relation), prov_taint(from));
+out:
+  return;
+}
+
+static inline void record_relation(uint32_t type,
+                                    prov_msg_t* from,
+                                    prov_msg_t* to,
+                                    uint8_t allowed,
+                                    struct file *file){
+  prov_msg_t relation;
+
+  if( unlikely(from==NULL || to==NULL) ){ // should not occur
+    return;
+  }
+
+  if(!provenance_is_tracked(from) && !provenance_is_tracked(to) && !prov_all ){
+    return;
+  }
+
+  // one of the node should not appear in the record, ignore the relation
+  if(filter_node(from) || filter_node(to)){
+    return;
+  }
+
+  // should the relation appear
+  if(filter_relation(type, allowed)){
+    goto out;
+  }
+  memset(&relation, 0, sizeof(prov_msg_t));
+  __record_node(from);
+  __propagate(type, from, to, &relation, allowed);
+  __update_version(type, to);
+  __record_node(to);
+  __record_relation(type, &(from->msg_info.identifier), &(to->msg_info.identifier), &relation, allowed, file);
+out:
+  return;
+}
+
+// incoming packet
+static inline void record_pck_to_inode(prov_msg_t* pck, prov_msg_t* inode){
+  prov_msg_t relation;
+
+  if( unlikely(pck==NULL || inode==NULL) ){ // should not occur
+    return;
+  }
+
+  if(!provenance_is_tracked(inode) && !prov_all){
+    goto out;
+  }
+
+  // one of the node should not appear in the record, ignore the relation
+  if(filter_node(pck) || filter_node(inode)){
+    goto out;
+  }
+
+  if(filter_relation(RL_RCV, FLOW_ALLOWED)){
+    goto out;
+  }
+  memset(&relation, 0, sizeof(prov_msg_t));
+  prov_write(pck);
+  __update_version(RL_RCV, inode);
+  __record_node(inode);
+  __record_relation(RL_RCV, &(pck->msg_info.identifier), &(inode->msg_info.identifier), &relation, FLOW_ALLOWED, NULL);
+out:
+  return;
+}
+
+// outgoing packet
+static inline void record_inode_to_pck(prov_msg_t* inode, prov_msg_t* pck){
+  prov_msg_t relation;
+
+  if( unlikely(pck==NULL || inode==NULL) ){ // should not occur
+    return;
+  }
+
+  if(!provenance_is_tracked(inode) && !prov_all){
+    goto out;
+  }
+
+  if(filter_node(pck) || filter_node(inode)){
+    goto out;
+  }
+
+  if(filter_relation(RL_SND, FLOW_ALLOWED)){
+    goto out;
+  }
+  memset(&relation, 0, sizeof(prov_msg_t));
+  __record_node(inode);
+  prov_write(pck);
+  __record_relation(RL_SND, &(inode->msg_info.identifier), &(pck->msg_info.identifier), &relation, FLOW_ALLOWED, NULL);
+out:
+  return;
+}
+#endif
+#endif /* _LINUX_PROVENANCE_H */
diff -uprN ./pristine/linux-4.4.25/security/provenance/include/provenance_inode.h ./linux-4.4.25/security/provenance/include/provenance_inode.h
--- ./pristine/linux-4.4.25/security/provenance/include/provenance_inode.h	1969-12-31 16:00:00.000000000 -0800
+++ ./linux-4.4.25/security/provenance/include/provenance_inode.h	2016-10-19 03:14:47.583690435 -0700
@@ -0,0 +1,106 @@
+/*
+*
+* Author: Thomas Pasquier <tfjmp@seas.harvard.edu>
+*
+* Copyright (C) 2016 Harvard University
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License version 2, as
+* published by the Free Software Foundation; either version 2 of the License, or
+*	(at your option) any later version.
+*
+*/
+#ifndef CONFIG_SECURITY_PROVENANCE_INODE
+#define CONFIG_SECURITY_PROVENANCE_INODE
+#include <linux/file.h>
+
+#include "provenance_long.h" // for record_inode_name
+
+#define is_inode_dir(inode) S_ISDIR(inode->i_mode)
+#define is_inode_socket(inode) S_ISSOCK(inode->i_mode)
+#define is_inode_file(inode) S_ISREG(inode->i_mode)
+
+static inline void prov_copy_inode_mode(prov_msg_t* iprov, struct inode *inode){
+  uint32_t type = MSG_INODE_UNKNOWN;
+  iprov->inode_info.mode=inode->i_mode;
+
+  if(S_ISBLK(inode->i_mode)){
+    type=MSG_INODE_BLOCK;
+  }else if(S_ISCHR(inode->i_mode)){
+    type=MSG_INODE_CHAR;
+  }else if(S_ISDIR(inode->i_mode)){
+    type=MSG_INODE_DIRECTORY;
+  }else if(S_ISFIFO(inode->i_mode)){
+    type=MSG_INODE_FIFO;
+  }else if(S_ISLNK(inode->i_mode)){
+    type=MSG_INODE_LINK;
+  }else if(S_ISREG(inode->i_mode)){
+    type=MSG_INODE_FILE;
+  }else if(S_ISSOCK(inode->i_mode)){
+    type=MSG_INODE_SOCKET;
+  }
+  node_identifier(iprov).type=type;
+}
+
+static inline void provenance_mark_as_opaque(const char* name){
+  struct inode* in;
+  prov_msg_t* prov;
+
+  in = file_name_to_inode(name);
+  if(!in){
+    printk(KERN_ERR "Provenance: could not find %s file.", name);
+  }else{
+    prov = __raw_inode_provenance(in);
+    if(prov){
+      set_opaque(prov);
+    }
+  }
+}
+
+static inline prov_msg_t* inode_provenance(struct inode* inode){
+	prov_msg_t* iprov = __raw_inode_provenance(inode);
+  if(unlikely(iprov==NULL)){
+    return NULL;
+  }
+  lock_node(iprov);
+	prov_copy_inode_mode(iprov, inode);
+  if(is_inode_dir(inode) || is_inode_file(inode)){
+	   record_inode_name(inode, iprov);
+   }
+	return iprov;
+}
+
+static inline prov_msg_t* branch_mmap(prov_msg_t* iprov, prov_msg_t* cprov){ //used for private MMAP
+  prov_msg_t* prov;
+  prov_msg_t relation;
+
+  if( unlikely(iprov==NULL || cprov==NULL) ){ // should not occur
+    return NULL;
+  }
+
+  if(!provenance_is_tracked(iprov) && !provenance_is_tracked(cprov) && !prov_all ){
+    return NULL;
+  }
+
+  if( filter_node(iprov) ){
+    return NULL;
+  }
+
+  if(filter_relation(RL_CREATE, FLOW_ALLOWED)) {
+    return NULL;
+  }
+
+  prov = alloc_provenance(MSG_INODE_MMAP, GFP_KERNEL);
+
+  set_node_id(prov, ASSIGN_NODE_ID);
+  prov->inode_info.uid = iprov->inode_info.uid;
+  prov->inode_info.gid = iprov->inode_info.gid;
+  memcpy(prov->inode_info.sb_uuid, iprov->inode_info.sb_uuid, 16*sizeof(uint8_t));
+  prov->inode_info.mode = iprov->inode_info.mode;
+  __record_node(iprov);
+  __propagate(RL_CREATE, iprov, prov, &relation, FLOW_ALLOWED);
+  __record_node(prov);
+  __record_relation(RL_CREATE, &(iprov->msg_info.identifier), &(prov->msg_info.identifier), &relation, FLOW_ALLOWED, NULL);
+  return prov;
+}
+#endif
diff -uprN ./pristine/linux-4.4.25/security/provenance/include/provenance_long.h ./linux-4.4.25/security/provenance/include/provenance_long.h
--- ./pristine/linux-4.4.25/security/provenance/include/provenance_long.h	1969-12-31 16:00:00.000000000 -0800
+++ ./linux-4.4.25/security/provenance/include/provenance_long.h	2016-10-19 03:14:47.583690435 -0700
@@ -0,0 +1,188 @@
+/*
+*
+* Author: Thomas Pasquier <tfjmp@seas.harvard.edu>
+*
+* Copyright (C) 2016 Harvard University
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License version 2, as
+* published by the Free Software Foundation; either version 2 of the License, or
+*	(at your option) any later version.
+*
+*/
+#ifndef _LINUX_PROVENANCE_LONG_H
+#define _LINUX_PROVENANCE_LONG_H
+
+#include <linux/file.h>
+#include <uapi/linux/provenance.h>
+
+#include "provenance_net.h"
+
+extern uint32_t prov_machine_id;
+extern uint32_t prov_boot_id;
+
+static inline void __init_long_provenance(uint32_t ntype, long_prov_msg_t* prov){
+  prov_type(prov)=ntype;
+  node_identifier(prov).id=prov_next_node_id();
+  node_identifier(prov).boot_id=prov_boot_id;
+  node_identifier(prov).machine_id=prov_machine_id;
+}
+
+static inline void __long_record_node(long_prov_msg_t* node){
+  if(provenance_is_recorded(node) ){
+    return;
+  }
+  set_recorded(node);
+  long_prov_write(node);
+}
+
+static inline void __long_record_relation(uint32_t type, long_prov_msg_t* from, prov_msg_t* to, uint8_t allowed){
+  prov_msg_t relation;
+
+  if(unlikely(!prov_enabled)){ // capture is not enabled, ignore
+    return;
+  }
+  // don't record if to or from are opaque
+  if( unlikely(provenance_is_opaque(to)) ){
+    return;
+  }
+  __long_record_node(from);
+  __record_node(to);
+  memset(&relation, 0, sizeof(prov_msg_t));
+  __record_relation(type, &(from->msg_info.identifier), &(to->msg_info.identifier), &relation, allowed, NULL);
+}
+
+#ifdef CONFIG_SECURITY_IFC
+static inline void prov_record_ifc(prov_msg_t* prov, struct ifc_context *context){
+	long_prov_msg_t ifc_prov;
+
+  memset(&ifc_prov, 0, sizeof(long_prov_msg_t));
+  __init_long_provenance(MSG_IFC, &ifc_prov);
+  memcpy(&(ifc_prov->ifc_info.context), context, sizeof(struct ifc_context));
+  long_prov_write(&ifc_prov);
+  // TODO connect via relation to entity/activity
+}
+#endif
+
+static inline int prov_print(const char *fmt, ...)
+{
+  long_prov_msg_t msg;
+  int length;
+  va_list args;
+  va_start(args, fmt);
+
+  /* set message type */
+  __init_long_provenance(MSG_STR, &msg);
+  msg.str_info.length = vscnprintf(msg.str_info.str, 4096, fmt, args);
+  long_prov_write(&msg);
+  va_end(args);
+  length = msg.str_info.length;
+  return length;
+}
+
+static inline void __record_node_name(prov_msg_t* node, char* name){
+	long_prov_msg_t* fname_prov;
+
+  fname_prov = (long_prov_msg_t*)kzalloc(sizeof(long_prov_msg_t), GFP_KERNEL); // revert back to cache if causes performance issue
+  __init_long_provenance(MSG_FILE_NAME, fname_prov);
+	strlcpy(fname_prov->file_name_info.name, name, PATH_MAX);
+	fname_prov->file_name_info.length=strlen(fname_prov->file_name_info.name);
+	__long_record_relation(RL_NAMED, fname_prov, node, FLOW_ALLOWED);
+  kfree(fname_prov);
+	set_name_recorded(node);
+}
+
+static inline void record_inode_name_from_dentry(struct dentry *dentry, prov_msg_t* iprov){
+  char *buffer;
+	char *ptr;
+
+  if( !provenance_is_recorded(iprov) ){
+    return;
+  }
+
+  buffer = (char*)kzalloc(PATH_MAX, GFP_NOFS);
+	ptr = dentry_path_raw(dentry, buffer, PATH_MAX);
+	__record_node_name(iprov, ptr);
+	kfree(buffer);
+}
+
+static inline void record_inode_name(struct inode *inode, prov_msg_t* iprov){
+	struct dentry* dentry;
+
+	if( provenance_is_name_recorded(iprov) ){
+		return;
+	}
+	dentry = d_find_alias(inode);
+
+	if(!dentry){ // we did not find a dentry, not sure if it should ever happen
+		return;
+	}
+	record_inode_name_from_dentry(dentry, iprov);
+	dput(dentry);
+}
+
+static inline void record_task_name(struct task_struct *task, prov_msg_t* tprov){
+	const struct cred *cred;
+	struct mm_struct *mm;
+ 	struct file *exe_file;
+	char *buffer;
+	char *ptr;
+
+  if( !provenance_is_recorded(tprov) ){
+    return;
+  }
+
+	// name already recorded
+	if(provenance_is_name_recorded(tprov)){
+		return;
+	}
+
+	if(filter_node(tprov)){
+		return;
+	}
+
+	cred = get_task_cred(task);
+	if(!cred){
+		return;
+	}
+
+	mm = get_task_mm(task);
+	if (!mm){
+ 		goto out;
+	}
+	exe_file = get_mm_exe_file(mm);
+	mmput(mm);
+
+	if(exe_file){
+		buffer = (char*)kzalloc(PATH_MAX, GFP_KERNEL);
+		ptr = file_path(exe_file, buffer, PATH_MAX);
+		fput(exe_file);
+		__record_node_name(tprov, ptr);
+		kfree(buffer);
+	}
+
+out:
+	put_cred(cred);
+}
+
+static inline void provenance_record_address(prov_msg_t* skprov, struct sockaddr *address, int addrlen){
+	long_prov_msg_t* addr_info;
+
+  if( !provenance_is_recorded(skprov) ){
+    return;
+  }
+
+	if(provenance_is_name_recorded(skprov)){
+    return;
+  }
+
+  addr_info = (long_prov_msg_t*)kzalloc(sizeof(long_prov_msg_t), GFP_KERNEL); // revert back to cache if causes performance issue
+  __init_long_provenance(MSG_ADDR, addr_info);
+  addr_info->address_info.length=addrlen;
+  memcpy(&(addr_info->address_info.addr), address, addrlen);
+	__long_record_relation(RL_NAMED, addr_info, skprov, FLOW_ALLOWED);
+  kfree(addr_info);
+	set_name_recorded(skprov);
+}
+
+#endif
diff -uprN ./pristine/linux-4.4.25/security/provenance/include/provenance_net.h ./linux-4.4.25/security/provenance/include/provenance_net.h
--- ./pristine/linux-4.4.25/security/provenance/include/provenance_net.h	1969-12-31 16:00:00.000000000 -0800
+++ ./linux-4.4.25/security/provenance/include/provenance_net.h	2016-10-19 03:14:47.583690435 -0700
@@ -0,0 +1,129 @@
+/*
+*
+* Author: Thomas Pasquier <tfjmp@seas.harvard.edu>
+*
+* Copyright (C) 2016 Harvard University
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License version 2, as
+* published by the Free Software Foundation; either version 2 of the License, or
+*	(at your option) any later version.
+*
+*/
+#ifndef CONFIG_SECURITY_PROVENANCE_NET
+#define CONFIG_SECURITY_PROVENANCE_NET
+
+#include <net/sock.h>
+#include <net/ip.h>
+#include <linux/netfilter_ipv4.h>
+#include <linux/netfilter_ipv6.h>
+#include <linux/ip.h>
+#include <linux/tcp.h>
+#include <linux/udp.h>
+#include <linux/skbuff.h>
+
+#include "provenance.h"
+
+static inline prov_msg_t* socket_inode_provenance(struct socket *sock){
+  struct inode *inode = SOCK_INODE(sock);
+  prov_msg_t* iprov = __raw_inode_provenance(inode);
+  if(inode==NULL){
+    return NULL;
+  }
+  return iprov;
+}
+
+static inline prov_msg_t* sk_inode_provenance(struct sock *sk){
+  struct socket *sock = sk->sk_socket;
+  if(sock==NULL){
+    return NULL;
+  }
+  return socket_inode_provenance(sock);
+}
+
+static inline prov_msg_t* sk_provenance(struct sock *sk){
+  prov_msg_t* prov = sk->sk_provenance;
+  return prov;
+}
+
+static inline unsigned int provenance_parse_skb_ipv4(struct sk_buff *skb, prov_msg_t* prov){
+  struct packet_identifier* id;
+  int offset, ihlen;
+	struct iphdr _iph, *ih;
+  struct tcphdr _tcph, *th;
+  struct udphdr _udph, *uh;
+
+  offset = skb_network_offset(skb);
+  ih = skb_header_pointer(skb, offset, sizeof(_iph), &_iph); // we obtain the ip header
+  if(ih == NULL){
+    return -EINVAL;
+  }
+
+  ihlen = ih->ihl*4; // header size
+  if(ihlen < sizeof(_iph)){
+    return -EINVAL;
+  }
+
+  memset(prov, 0, sizeof(prov_msg_t));
+  id = &packet_identifier(prov); // we are going fo fill this
+
+  id->type = MSG_PACKET;
+  // collect IP element of prov identifier
+  id->id = ih->id;
+  id->snd_ip = ih->saddr;
+  id->rcv_ip = ih->daddr;
+  id->protocol = ih->protocol;
+  prov->pck_info.length = ih->tot_len;
+
+  // now we collect
+  switch(ih->protocol){
+    case IPPROTO_TCP:
+      if (ntohs(ih->frag_off) & IP_OFFSET){
+        break;
+      }
+
+      offset +=ihlen; //point to tcp packet
+      th = skb_header_pointer(skb, offset, sizeof(_tcph), &_tcph);
+      if(th==NULL){
+        break;
+      }
+
+      id->snd_port = th->source;
+      id->rcv_port = th->dest;
+      id->seq = th->seq;
+      break;
+    case IPPROTO_UDP:
+      if (ntohs(ih->frag_off) & IP_OFFSET){
+        break;
+      }
+
+      offset +=ihlen; //point to tcp packet
+      uh = skb_header_pointer(skb, offset, sizeof(_udph), &_udph);
+      if(uh==NULL){
+        break;
+      }
+
+      id->snd_port = uh->source;
+      id->rcv_port = uh->dest;
+      break;
+    default:
+      break;
+  }
+  return 0;
+}
+
+static inline prov_msg_t* skb_inode_prov(struct sk_buff *skb){
+  struct sock *sk;
+  if(skb==NULL){
+    return NULL;
+  }
+
+  sk = skb->sk;
+  if(sk==NULL){
+    return NULL;
+  }
+
+  return sk_inode_provenance(sk);
+}
+
+#endif
diff -uprN ./pristine/linux-4.4.25/security/provenance/include/provenance_relay.h ./linux-4.4.25/security/provenance/include/provenance_relay.h
--- ./pristine/linux-4.4.25/security/provenance/include/provenance_relay.h	1969-12-31 16:00:00.000000000 -0800
+++ ./linux-4.4.25/security/provenance/include/provenance_relay.h	2016-10-19 03:14:47.583690435 -0700
@@ -0,0 +1,66 @@
+/*
+*
+* Author: Thomas Pasquier <tfjmp@seas.harvard.edu>
+*
+* Copyright (C) 2016 Harvard University
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License version 2, as
+* published by the Free Software Foundation; either version 2 of the License, or
+*	(at your option) any later version.
+*
+*/
+#ifndef _LINUX_PROVENANCE_RELAY_H
+#define _LINUX_PROVENANCE_RELAY_H
+
+#include <linux/relay.h>
+#include <linux/spinlock.h>
+#include <linux/jiffies.h>
+
+#include "provenance_filter.h"
+
+extern struct rchan *prov_chan;
+extern spinlock_t prov_chan_lock;
+
+static inline void prov_write(prov_msg_t* msg)
+{
+  unsigned long flags;
+  spin_lock_irqsave(&prov_chan_lock, flags);
+  if(unlikely(prov_chan==NULL)) // not set yet
+  {
+    // TODO deal with record before relay is ready
+  }else{
+    prov_jiffies(msg) = get_jiffies_64();
+    relay_write(prov_chan, msg, sizeof(prov_msg_t));
+  }
+  spin_unlock_irqrestore(&prov_chan_lock, flags);
+}
+
+extern struct rchan *long_prov_chan;
+extern spinlock_t long_prov_chan_lock;
+
+static inline void long_prov_write(long_prov_msg_t* msg){
+  unsigned long flags;
+  spin_lock_irqsave(&long_prov_chan_lock, flags);
+  if(unlikely(long_prov_chan==NULL)) // not set yet
+  {
+    // TODO deal with record before relay is ready
+  }else{
+    prov_jiffies(msg) = get_jiffies_64();
+    relay_write(long_prov_chan, msg, sizeof(long_prov_msg_t));
+  }
+  spin_unlock_irqrestore(&long_prov_chan_lock, flags);
+}
+
+/* force sub-buffer switch */
+static inline void prov_flush( void ){
+  unsigned long flags;
+  spin_lock_irqsave(&prov_chan_lock, flags);
+  relay_flush(prov_chan);
+  spin_unlock_irqrestore(&prov_chan_lock, flags);
+  spin_lock_irqsave(&long_prov_chan_lock, flags);
+  relay_flush(long_prov_chan);
+  spin_unlock_irqrestore(&long_prov_chan_lock, flags);
+}
+
+#endif
diff -uprN ./pristine/linux-4.4.25/security/provenance/include/provenance_task.h ./linux-4.4.25/security/provenance/include/provenance_task.h
--- ./pristine/linux-4.4.25/security/provenance/include/provenance_task.h	1969-12-31 16:00:00.000000000 -0800
+++ ./linux-4.4.25/security/provenance/include/provenance_task.h	2016-10-19 03:14:47.583690435 -0700
@@ -0,0 +1,76 @@
+/*
+*
+* Author: Thomas Pasquier <tfjmp@seas.harvard.edu>
+*
+* Copyright (C) 2016 Harvard University
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License version 2, as
+* published by the Free Software Foundation; either version 2 of the License, or
+*	(at your option) any later version.
+*
+*/
+#ifndef CONFIG_SECURITY_PROVENANCE_TASK
+#define CONFIG_SECURITY_PROVENANCE_TASK
+
+#include <linux/cred.h>
+#include <linux/binfmts.h>
+
+#include "provenance_long.h" // for record_task_name
+#include "provenance_inode.h"
+
+#define current_pid() (current->pid)
+
+static inline prov_msg_t* task_provenance( void ){
+	prov_msg_t* tprov = current_provenance();
+	lock_node(tprov);
+	if( provenance_is_recorded(tprov) ){ // the node has been recorded we need its name
+		record_task_name(current, tprov);
+	}
+	return tprov;
+}
+
+static inline prov_msg_t* bprm_provenance( struct linux_binprm *bprm ){
+	prov_msg_t* prov = bprm->cred->provenance;
+	lock_node(prov);
+	return prov;
+}
+
+static inline void task_config_from_file(struct task_struct *task){
+	const struct cred *cred = get_task_cred(task);
+	struct mm_struct *mm;
+ 	struct file *exe_file;
+	struct inode *inode;
+	prov_msg_t* tprov;
+	prov_msg_t* iprov;
+
+	if(!cred)
+		return;
+
+	tprov = cred->provenance;
+
+	mm = get_task_mm(task);
+	if (!mm)
+ 		goto finished;
+	exe_file = get_mm_exe_file(mm);
+	mmput(mm);
+
+	if(exe_file){
+		inode = file_inode(exe_file);
+		iprov = inode_provenance(inode);
+		if(provenance_is_tracked(iprov)){
+			set_tracked(tprov);
+		}
+		if(provenance_is_opaque(iprov)){
+			set_opaque(tprov);
+		}
+		if(provenance_propagate(iprov)){
+			set_propagate(tprov);
+		}
+		put_prov(iprov);
+	}
+
+finished:
+	put_cred(cred);
+}
+#endif
diff -uprN ./pristine/linux-4.4.25/security/provenance/Kconfig ./linux-4.4.25/security/provenance/Kconfig
--- ./pristine/linux-4.4.25/security/provenance/Kconfig	1969-12-31 16:00:00.000000000 -0800
+++ ./linux-4.4.25/security/provenance/Kconfig	2016-10-19 03:14:47.582690427 -0700
@@ -0,0 +1,9 @@
+config SECURITY_PROVENANCE
+         bool "CamFlow - Provenance"
+         depends on SECURITY
+         select RELAY
+         select SECURITYFS
+         default n
+         help
+          This selects Provenance.
+          Provenance is an helper to capture provenance data.
diff -uprN ./pristine/linux-4.4.25/security/provenance/Makefile ./linux-4.4.25/security/provenance/Makefile
--- ./pristine/linux-4.4.25/security/provenance/Makefile	1969-12-31 16:00:00.000000000 -0800
+++ ./linux-4.4.25/security/provenance/Makefile	2016-10-19 03:14:47.582690427 -0700
@@ -0,0 +1,8 @@
+#
+# Makefile for Provenance LSM
+#
+obj-$(CONFIG_SECURITY_PROVENANCE) := provenance.o
+
+provenance-y := relay.o hooks.o fs.o netfilter.o
+
+ccflags-y := -I$(srctree)/security/camflow -I$(srctree)/security/camflow/include -I$(srctree)/security/ifc/include -I$(srctree)/security/provenance/include
diff -uprN ./pristine/linux-4.4.25/security/provenance/netfilter.c ./linux-4.4.25/security/provenance/netfilter.c
--- ./pristine/linux-4.4.25/security/provenance/netfilter.c	1969-12-31 16:00:00.000000000 -0800
+++ ./linux-4.4.25/security/provenance/netfilter.c	2016-10-19 03:14:47.583690435 -0700
@@ -0,0 +1,75 @@
+/*
+*
+* Author: Thomas Pasquier <tfjmp@seas.harvard.edu>
+*
+* Copyright (C) 2016 Havard University
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License version 2, as
+* published by the Free Software Foundation; either version 2 of the License, or
+*	(at your option) any later version.
+*
+*/
+
+#if defined(CONFIG_NETFILTER)
+
+#include <linux/camflow.h>
+
+#include "provenance.h"
+#include "provenance_net.h"
+#include "provenance_task.h"
+
+static inline unsigned int __ipv4_out(struct sk_buff *skb)
+{
+  prov_msg_t* cprov = current_provenance();
+  prov_msg_t* iprov = NULL;
+  prov_msg_t pckprov;
+
+  if(cprov==NULL){  // we could not get the provenance, we give up
+    goto out;
+  }
+
+  if(provenance_is_tracked(cprov)){
+    iprov = sk_inode_provenance(skb->sk);
+    if(iprov==NULL){  // we could not get the provenance, we give up
+      goto out;
+    }
+    provenance_parse_skb_ipv4(skb, &pckprov);
+    record_inode_to_pck(iprov, &pckprov);
+  }
+out:
+  return NF_ACCEPT;
+}
+
+static unsigned int provenance_ipv4_out(void *priv,
+					struct sk_buff *skb,
+					const struct nf_hook_state *state)
+{
+  return __ipv4_out(skb);
+}
+
+static struct nf_hook_ops provenance_nf_ops[] = {
+  {
+    .hook = provenance_ipv4_out,
+    .pf = NFPROTO_IPV4,
+    .hooknum = NF_INET_LOCAL_OUT,
+    .priority = NF_IP_PRI_LAST,
+  },
+};
+
+// will initialise the hooks
+static int __init provenance_nf_init(void)
+{
+  int err;
+
+  err = nf_register_hooks(provenance_nf_ops, ARRAY_SIZE(provenance_nf_ops));
+  if(err){
+    panic("Provenance: nf_register_hooks: error %d\n", err);
+  }
+
+  printk(KERN_INFO "Provenance netfilter ready.\n");
+
+  return 0;
+}
+__initcall(provenance_nf_init);
+#endif
diff -uprN ./pristine/linux-4.4.25/security/provenance/relay.c ./linux-4.4.25/security/provenance/relay.c
--- ./pristine/linux-4.4.25/security/provenance/relay.c	1969-12-31 16:00:00.000000000 -0800
+++ ./linux-4.4.25/security/provenance/relay.c	2016-10-19 03:14:47.583690435 -0700
@@ -0,0 +1,92 @@
+/*
+*
+* Author: Thomas Pasquier <thomas.pasquier@cl.cam.ac.uk>
+*
+* Copyright (C) 2015 University of Cambridge
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License version 2, as
+* published by the Free Software Foundation; either version 2 of the License, or
+*	(at your option) any later version.
+*
+*/
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/debugfs.h>
+
+#include "provenance.h"
+
+#define PROV_BASE_NAME "provenance"
+#define LONG_PROV_BASE_NAME "long_provenance"
+
+/* global variable, extern in provenance.h */
+ struct rchan *prov_chan=NULL;
+ struct rchan *long_prov_chan=NULL;
+ atomic64_t prov_relation_id=ATOMIC64_INIT(0);
+ atomic64_t prov_node_id=ATOMIC64_INIT(0);
+
+/*
+ * create_buf_file() callback.  Creates relay file in debugfs.
+ */
+static struct dentry *create_buf_file_handler(const char *filename,
+                                                struct dentry *parent,
+                                                umode_t mode,
+                                                struct rchan_buf *buf,
+                                                int *is_global)
+{
+        return debugfs_create_file(filename, mode, parent, buf,
+	                           &relay_file_operations);
+}
+
+/*
+ * remove_buf_file() callback.  Removes relay file from debugfs.
+ */
+static int remove_buf_file_handler(struct dentry *dentry)
+{
+        debugfs_remove(dentry);
+        return 0;
+}
+
+/*
+ * relay interface callbacks
+ */
+static struct rchan_callbacks relay_callbacks =
+{
+        .create_buf_file = create_buf_file_handler,
+        .remove_buf_file = remove_buf_file_handler,
+};
+
+#define PROV_RELAY_BUFF_EXP         22 // 4MB
+#define PROV_RELAY_BUFF_SIZE        ((1 << PROV_RELAY_BUFF_EXP)*sizeof(uint8_t))
+#define PROV_NB_SUBBUF              32
+
+DEFINE_SPINLOCK(prov_chan_lock);
+DEFINE_SPINLOCK(long_prov_chan_lock);
+
+static int __init relay_prov_init(void)
+{
+  unsigned long flags;
+  spin_lock_irqsave(&prov_chan_lock, flags);
+  prov_chan = relay_open(PROV_BASE_NAME, NULL, PROV_RELAY_BUFF_SIZE, PROV_NB_SUBBUF, &relay_callbacks, NULL);
+  if(prov_chan==NULL){
+    spin_unlock_irqrestore(&prov_chan_lock, flags);
+    printk(KERN_ERR "Provenance: relay_open failure\n");
+    return 0;
+  }
+  spin_unlock_irqrestore(&prov_chan_lock, flags);
+
+  spin_lock_irqsave(&long_prov_chan_lock, flags);
+  long_prov_chan = relay_open(LONG_PROV_BASE_NAME, NULL, PROV_RELAY_BUFF_SIZE, PROV_NB_SUBBUF, &relay_callbacks, NULL);
+  if(long_prov_chan==NULL){
+    spin_unlock_irqrestore(&long_prov_chan_lock, flags);
+    printk(KERN_ERR "Provenance: relay_open failure\n");
+    return 0;
+  }
+  spin_unlock_irqrestore(&long_prov_chan_lock, flags);
+
+  printk(KERN_INFO "Provenance relay ready.\n");
+  return 0;
+}
+
+core_initcall(relay_prov_init);
diff -uprN ./pristine/linux-4.4.25/security/security.c ./linux-4.4.25/security/security.c
--- ./pristine/linux-4.4.25/security/security.c	2016-10-16 08:48:03.000000000 -0700
+++ ./linux-4.4.25/security/security.c	2016-10-19 03:14:47.584690444 -0700
@@ -20,6 +20,7 @@
 #include <linux/integrity.h>
 #include <linux/ima.h>
 #include <linux/evm.h>
+#include <linux/camflow.h>
 #include <linux/fsnotify.h>
 #include <linux/mman.h>
 #include <linux/mount.h>
@@ -27,7 +28,11 @@
 #include <linux/backing-dev.h>
 #include <net/flow.h>
 
+#ifdef CONFIG_SECURITY_PROVENANCE
+#define MAX_LSM_EVM_XATTR	3
+#else
 #define MAX_LSM_EVM_XATTR	2
+#endif
 
 /* Maximum number of letters for an LSM name string */
 #define SECURITY_NAME_MAX	10
@@ -66,6 +71,16 @@ int __init security_init(void)
 	 */
 	do_security_initcalls();
 
+	/*
+	* Load IFC and Provenance module
+	*/
+#ifdef CONFIG_SECURITY_IFC
+	ifc_add_hooks();
+#endif
+#ifdef CONFIG_SECURITY_PROVENANCE
+	provenance_add_hooks();
+#endif
+
 	return 0;
 }
 
@@ -390,6 +405,7 @@ int security_inode_init_security(struct
 	ret = evm_inode_init_security(inode, lsm_xattr, evm_xattr);
 	if (ret)
 		goto out;
+
 	ret = initxattrs(inode, new_xattrs, fs_data);
 out:
 	for (xattr = new_xattrs; xattr->value != NULL; xattr++)
@@ -697,20 +713,43 @@ int security_inode_killpriv(struct dentr
 	return call_int_hook(inode_killpriv, 0, dentry);
 }
 
+/* updated from more recent kernel version */
 int security_inode_getsecurity(const struct inode *inode, const char *name, void **buffer, bool alloc)
 {
+	struct security_hook_list *hp;
+	int rc;
+
 	if (unlikely(IS_PRIVATE(inode)))
 		return -EOPNOTSUPP;
-	return call_int_hook(inode_getsecurity, -EOPNOTSUPP, inode, name,
-				buffer, alloc);
+	/*
+	 * Only one module will provide an attribute with a given name.
+	 */
+	list_for_each_entry(hp, &security_hook_heads.inode_getsecurity, list) {
+		rc = hp->hook.inode_getsecurity(inode, name, buffer, alloc);
+		if (rc != -EOPNOTSUPP)
+			return rc;
+	}
+	return -EOPNOTSUPP;
 }
 
+/* updated from more recent kernel version */
 int security_inode_setsecurity(struct inode *inode, const char *name, const void *value, size_t size, int flags)
 {
+	struct security_hook_list *hp;
+	int rc;
+
 	if (unlikely(IS_PRIVATE(inode)))
 		return -EOPNOTSUPP;
-	return call_int_hook(inode_setsecurity, -EOPNOTSUPP, inode, name,
-				value, size, flags);
+	/*
+	 * Only one module will provide an attribute with a given name.
+	 */
+	list_for_each_entry(hp, &security_hook_heads.inode_setsecurity, list) {
+		rc = hp->hook.inode_setsecurity(inode, name, value, size,
+								flags);
+		if (rc != -EOPNOTSUPP)
+			return rc;
+	}
+	return -EOPNOTSUPP;
 }
 
 int security_inode_listsecurity(struct inode *inode, char *buffer, size_t buffer_size)
